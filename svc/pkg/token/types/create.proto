syntax = "proto3";

package rivet.backend.pkg.token.create;

import "proto/common.proto";
import "proto/claims.proto";
import "proto/backend/net.proto";

message Request {
	message TokenConfig {
		// Expiration time in milliseconds.
		int64 ttl = 1;
	}

	message KindNew {
		repeated rivet.claims.Entitlement entitlements = 1;
	}

	message KindRefresh {
		// Token data to refresh.
		string refresh_token = 1;
	}

	// Service name that issued this token. Use `service_name::SERVICE_ID`
	// which is auto-generated by chirp-build.
	string issuer = 1;

	TokenConfig token_config = 2;

	// If provided, this will issue a separate refresh token to create this token.
	optional TokenConfig refresh_token_config = 3;

	optional rivet.backend.net.ClientInfo client = 4;

	// Label to attach to prefix the token with. This has no functionality
	// other than being useful for identifying tokens.
	optional string label = 5;

	// If we should include the refresh entitlement with the normal token's
	// claims. This should not be combined with `refresh_token_config`. Has no
	// effect if refreshing an existing token.
	//
	// Often used in 3rd party APIs in the interest of simplicity.
	bool combine_refresh_token = 6;

	// If the token should be inserted in to the database.
	bool ephemeral = 7;

	oneof kind {
		KindNew new = 100;
		KindRefresh refresh = 101;
	}
}

message Response {
	message TokenData {
		string token = 1;
		rivet.common.Uuid jti = 2;
	}

	TokenData token = 1;
	optional TokenData refresh_token = 2;
	rivet.common.Uuid session_id = 3;
}

