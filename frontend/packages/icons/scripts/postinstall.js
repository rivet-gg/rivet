const { isPackageExists, getPackageInfo } = require("local-pkg");
const fs = require("node:fs");
const dedent = require("dedent");
const { spawnSync } = require("node:child_process");
const { join, resolve } = require("node:path");
const manifest = require("./../manifest.json");
const vite = require("vite");

const packageExistsOptions = {
	paths: [
		join(process.cwd(), "src", "node_modules"),
		join(process.cwd(), "..", ".."),
	],
};

if (process.env.FONTAWESOME_PACKAGE_TOKEN) {
	fs.writeFileSync(
		"./src/.yarnrc.yml",
		dedent`
    nodeLinker: node-modules

    enableImmutableInstalls: false

    npmScopes:
      fortawesome:
          npmAlwaysAuth: true
          npmRegistryServer: 'https://npm.fontawesome.com/'
          npmAuthToken: \${FONTAWESOME_PACKAGE_TOKEN}
      awesome.me:
          npmAlwaysAuth: true
          npmRegistryServer: "https://npm.fontawesome.com/"
          npmAuthToken: \${FONTAWESOME_PACKAGE_TOKEN}
      `,
	);

	fs.writeFileSync("./src/yarn.lock", "");

	spawnSync(
		"yarn",
		["config", "set", "-H", "enableImmutableInstalls", "false"],
		{
			stdio: "inherit",
			cwd: join(process.cwd(), "src"),
		},
	);

	spawnSync("yarn", [], {
		stdio: "inherit",
		cwd: join(process.cwd(), "src"),
		env: {
			...process.env,
			CI: 0,
		},
	});
}

const isPro = isPackageExists(
	"@fortawesome/pro-solid-svg-icons",
	packageExistsOptions,
);

const banner = dedent`
  // This file is generated by scripts/postinstall.js
  // Do not modify this file directly
  // ${isPro ? "This file includes pro icons" : "This file does not include pro icons, all pro icons are replaced with square icon. To use pro icons, please add FONTAWESOME_PACKAGE_TOKEN to your environment and rebuild this package."} \n


`;

let indexTsSource = dedent`
  ${banner}
  export type IconProp = string | { prefix: string; iconName: string } | [string, string];
  import {FontAwesomeIcon } from "@fortawesome/react-fontawesome";
  import { createElement } from "react";
  export function Icon(props: Omit<import("@fortawesome/react-fontawesome").FontAwesomeIconProps, "icon"> & {icon: IconProp}) { return createElement(FontAwesomeIcon, props as import("@fortawesome/react-fontawesome").FontAwesomeIconProps)}
  export { default as iconPack } from "./icons-pack.gen";
`;

for (const [pkg, { icons }] of Object.entries(manifest)) {
	const pkgExists = pkg.includes("pro") ? isPro : true;
	const isCustom = pkg.startsWith("@awesome.me/kit-");

	if (isCustom) {
		if (!pkgExists) {
			const iconNames = icons.map(({ icon }) => icon);
			const exp = iconNames
				.map((icon) => `definition as ${icon}`)
				.join(", ");
			indexTsSource += `export { ${exp} } from "@fortawesome/free-solid-svg-icons/faSquare";\n`;
		} else {
			indexTsSource += `export * from "${pkg}";\n`;
		}
		continue;
	}

	for (const { icon, aliases } of icons) {
		if (!indexTsSource.includes(`export { definition as ${icon} }`)) {
			if (pkgExists) {
				indexTsSource += `export { definition as ${icon} } from "${pkg}/${icon}";\n`;
			} else {
				indexTsSource += `export { definition as ${icon} } from "@fortawesome/free-solid-svg-icons/faSquare";\n`;
			}
		}
		for (const alias of aliases) {
			if (
				alias === icon ||
				indexTsSource.includes(`export { definition as ${icon} }`)
			) {
				continue;
			}
			indexTsSource += `export { definition as ${alias} } from "${pkg}/${icon}";\n`;
		}
	}
}
fs.writeFileSync("src/index.gen.ts", `${indexTsSource}`);

let iconsPackTsSource = `${banner}\n
import {type IconPack} from "@fortawesome/fontawesome-common-types";\n`;

for (const [pkg, { icons }] of Object.entries(manifest)) {
	const pkgExists = pkg.includes("pro") ? isPro : true;
	const isCustom = pkg.startsWith("@awesome.me/kit-");

	if (isCustom) {
		const iconNames = icons.map(({ icon }) => icon);
		if (!pkgExists) {
			const exp = iconNames
				.map((icon) => `definition as ${icon}`)
				.join(", ");
			iconsPackTsSource += `import {${exp}} from "@fortawesome/free-solid-svg-icons/faSquare";\n`;
		} else {
			iconsPackTsSource += `import {${iconNames.join(",")}} from "${pkg}";\n`;
		}
		continue;
	}

	for (const { icon } of icons) {
		if (iconsPackTsSource.includes(`import {definition as ${icon}}`)) {
			continue;
		}
		if (pkgExists) {
			iconsPackTsSource += `import {definition as ${icon}} from "${pkg}/${icon}";\n`;
		} else {
			iconsPackTsSource += `import {definition as ${icon}} from "@fortawesome/free-solid-svg-icons/faSquare";\n`;
		}
	}
}

iconsPackTsSource += "export default {\n";

for (const [pkg, { icons }] of Object.entries(manifest)) {
	const pkgExists = pkg.includes("pro") ? isPro : true;

	for (const { icon, aliases } of icons) {
		if (!iconsPackTsSource.includes(`{...${icon},`)) {
			iconsPackTsSource += `  ${icon}: {...${icon}, prefix: "fas"},\n`;
		}
		for (const alias of aliases) {
			if (
				alias === icon ||
				iconsPackTsSource.includes(`${icon}: {...${icon}`)
			) {
				continue;
			}
			iconsPackTsSource += `  ${alias}: ${icon},\n`;
		}
	}
}

iconsPackTsSource += "} as IconPack;\n";

fs.writeFileSync("src/icons-pack.gen.ts", `${iconsPackTsSource}`);

async function build() {
	await vite.build({
		plugins: [],
		root: resolve(__dirname, "./src"),
		build: {
			outDir: resolve(__dirname, "../dist"),
			emptyOutDir: true,
			minify: true,
			lib: {
				name: "icons",
				entry: {
					index: resolve(__dirname, "../src/index.gen.ts"),
				},
			},
			rollupOptions: {
				external: [
					"@fortawesome/react-fontawesome",
					/^@fortawesome\/free-solid-svg-icons/,
					/^@fortawesome\/free-brands-svg-icons/,
					"react",
					"react-dom",
				],
			},
		},
	});
}

build();
