#!/usr/bin/env -S deno run -A

import { parse } from '@std/yaml';
import { resolve, join, dirname } from '@std/path';
import dedent from 'dedent';

const SPEC_PATH = resolve(import.meta.dirname, '../../sdks/api/full/openapi/openapi.yml');
const OUTPUT_PATH = resolve(import.meta.dirname, '../src/content/docs/api');
const ERRORS_PATH = join(OUTPUT_PATH, 'errors.mdx');
const ERRORS_DIR_PATH = resolve(import.meta.dirname, '../../packages/common/formatted-error/errors');

export async function main() {
  // Read existing index.mdx before removing directory
  let indexContent = `# API Overview

The Rivet API provides HTTP endpoints for managing your serverless infrastructure programmatically.

## Authentication

All API requests require [authentication tokens](/docs/tokens). Use these tokens with the \`Authorization\` header.

## Resources

- **Actors** - Create [Rivet Actors](/docs/actors) and [Rivet Containers](/docs/containers)
- **Builds** - Code deployments
- **Routes** - HTTP routing configuration for [Rivet Functions](/docs/functions)
- **Regions** - Global deployment locations ([more info](/docs/regions))

## SDKs

While you can use the HTTP API directly, we recommend using our official SDKs:

- [TypeScript & JavaScript](https://www.npmjs.com/package/@rivet-gg/api)
- [Go](https://github.com/rivet-gg/rivet/tree/main/sdks/api/runtime/go)
- [Rust](https://github.com/rivet-gg/rivet/tree/main/sdks/api/runtime/rust)
- [OpenAPI](https://github.com/rivet-gg/rivet/blob/main/sdks/api/runtime/openapi/openapi.yml)
- [Command Line Interface](/docs/cli)

## Error Handling

See [API Errors](/docs/api/errors) for all error codes.
`;
  try {
    const existingIndexPath = join(OUTPUT_PATH, 'index.mdx');
    indexContent = await Deno.readTextFile(existingIndexPath);
    console.log('Preserved existing index.mdx content before removal');
  } catch (error) {
    console.log('No existing index.mdx found, will use default content');
  }

  await Deno.remove(OUTPUT_PATH, { recursive: true });
  await Deno.mkdir(OUTPUT_PATH, { recursive: true });

  // Generate API docs
  await generateApiDocs(indexContent);
  
  // Generate Error docs
  await generateErrorDocs();
}

async function generateApiDocs(indexContent = `# API\nRead documentation for all low-level API endpoints here.`) {
  // Read spec
  const SPEC = parse(await Deno.readTextFile(SPEC_PATH));

  // Write spec
  await Deno.writeTextFile(
    join(OUTPUT_PATH, 'spec.json'),
    JSON.stringify({ definitions: SPEC.components.schemas })
  );

  const apiBaseUrl = SPEC.servers[0].url;

  // Create structure to organize APIs by group
  const apiGroups = {};
  let apiPages = [];
  
  for (let pathName in SPEC.paths) {
    for (let method in SPEC.paths[pathName]) {
      let specPath = SPEC.paths[pathName][method];

      if (!/^(actors|builds|regions|routes)_/.test(specPath.operationId)) continue;

      console.log('Registering', method, pathName);

      let fullUrl = apiBaseUrl + pathName;

      // Remove product prefix from operation ID
      let operationIdStripped = specPath.operationId.replace(`ee_`, '').split('_');
      
      // Extract group name and other parts
      const groupName = operationIdStripped[0];
      const restOfPath = operationIdStripped.slice(1);

      let file = dedent`
        {/* This file is auto-generated by \`generateApi.js\`.
          *
          * Do not edit this file directly.
          */}

        import { JsonSchemaPreview, PropertyLabel } from '@/components/JsonSchemaPreview';
        import API_SCHEMA from './${'../'.repeat(operationIdStripped.length - 1)}spec.json';
        \n
      `;

      let title = specPath.operationId.replace(/_/g, '.');
      file += `# ${title}\n\n`;

      if (specPath.description) {
        file += dedent`
          ## Description
          ${specPath.description}
          \n
        `;
      }

      let requestBody = specPath.requestBody?.content['application/json']?.schema;
      let responseBody = specPath.responses['200']?.content['application/json']?.schema;

      // Code examples
      let curlCommand;
      if (requestBody) {
        curlCommand = dedent`
          # Write the request body to body.json before running
          curl -X ${method.toUpperCase()} -d '@body.json' '${fullUrl}'
          \n
        `;
      } else {
        curlCommand = `curl -X ${method.toUpperCase()} '${fullUrl}'`;
      }
      file += dedent`
        ## Code Examples

        <CodeGroup title='Request' tag='${method.toUpperCase()}' label='${fullUrl}'>

        \`\`\`bash {{ "title": "cURL" }}
        ${curlCommand}
        \`\`\`

        \`\`\`ts
        // Create Rivet client
        import { RivetClient } from '@rivet-gg/api';
        const RIVET = new RivetClient({ token: '[YOUR TOKEN HERE]' });

        // Make request
        await RIVET.${specPath.operationId.replace(/_/g, '.')}({
          // Add your request body here
        });
        \`\`\`

        </CodeGroup>
        \n
      `;

      file += `## Schema\n`;

      // Request parameters
      if (specPath.parameters) {
        let properties = {};

        for (let parameter of specPath.parameters) {
          properties[parameter.name] = { in: parameter.in, ...parameter.schema };
        }

        let schema = {
          type: 'object',
          properties,
          required: specPath.parameters.filter(p => p.required).map(p => p.name)
        };

        file += `<JsonSchemaPreview className='not-prose mt-4' title='Request Parameters' schema={${JSON.stringify(
          schema
        )}} defs={API_SCHEMA.definitions}/>\n`;
      }

      // Request body
      if (requestBody) {
        file += `<JsonSchemaPreview className='not-prose mt-4' title='Request' schema={${JSON.stringify(
          requestBody
        )}} defs={API_SCHEMA.definitions}/>\n`;
      }

      // Response body
      if (responseBody) {
        file += `<JsonSchemaPreview className='not-prose mt-4' title='Response' schema={${JSON.stringify(
          responseBody
        )}} defs={API_SCHEMA.definitions}/>\n`;
      }

      let docName = camelToKebab(operationIdStripped.join('/'));
      let filePath = join(OUTPUT_PATH, `${docName}.mdx`);

      await Deno.mkdir(dirname(filePath), { recursive: true });
      await Deno.writeTextFile(filePath, file);

      // Sort by grouping similar endpoints together
      let sortingKey = `${pathName} ${method}`;
      
      // Create page entry
      const pageEntry = {
        title: title.split('.').join('.'), // Remove group prefix from title
        href: `/docs/api/${docName}`,
        sortingKey
      };
      
      // Add to appropriate group
      if (!apiGroups[groupName]) {
        apiGroups[groupName] = {
          title: capitalizeFirstLetter(groupName),
          pages: []
        };
      }
      
      apiGroups[groupName].pages.push(pageEntry);
    }
  }
  
  // Sort each group's pages
  for (const groupName in apiGroups) {
    apiGroups[groupName].pages.sort((a, b) => {
      if (a.sortingKey < b.sortingKey) return -1;
      else if (a.sortingKey > b.sortingKey) return 1;
      else return 0;
    });
  }
  
  // Create the final structure for the sidebar
  const groupEntries = Object.values(apiGroups);
  
  // Sort the groups alphabetically
  groupEntries.sort((a, b) => a.title.localeCompare(b.title));

  // Write the preserved index.mdx content
  await Deno.writeTextFile(
    join(OUTPUT_PATH, 'index.mdx'),
    indexContent
  );

  await Deno.writeTextFile(
    resolve(OUTPUT_PATH, '../../../generated/apiPages.json'),
    JSON.stringify({ groups: groupEntries }, null, 2)
  );
}

async function generateErrorDocs() {
  console.log('Generating error documentation');
  let errorPages = [];

  await processErrorDir(ERRORS_DIR_PATH, errorPages);

  await Deno.writeTextFile(
    ERRORS_PATH,
    `# Errors \n${errorPages.map(({ doc }) => doc).join('\n\n')}`
  );
}

async function processErrorDir(inputPath, pages) {
  console.log(`Processing dir ${inputPath}`);

  for await (const dirEntry of Deno.readDir(inputPath)) {
    let inputPathEntry = join(inputPath, dirEntry.name);

    if (dirEntry.isFile && dirEntry.name.endsWith('.md')) {
      console.log(`Processing file ${inputPathEntry}`);

      let errorDoc = await Deno.readTextFile(inputPathEntry);

      // Read metadata
      let titleMatch = errorDoc.match(/^#\s+(.*)$/m);
      let title = titleMatch ? titleMatch[1] : null;
      if (!title) throw new Error(`Missing title: ${inputPathEntry}`);
      
      let nameMatch = errorDoc.match(/^name\s*=\s*"([\w_]+)"\s*$/m);
      let name = nameMatch ? nameMatch[1] : null;
      if (!name) throw new Error(`Missing name: ${inputPathEntry}`);
      
      let httpStatusMatch = errorDoc.match(/^http_status\s*=\s*(\d+)\s*$/m);
      let httpStatus = httpStatusMatch ? parseInt(httpStatusMatch[1]) : null;
      if (httpStatus >= 500 && httpStatus < 600) {
        continue;
      }
      
      // Filter out errors for matchmaker, backend, cdn, kv
      if (name.startsWith("MATCHMAKER") || name.startsWith("BACKEND") || 
          name.startsWith("CDN") || name.startsWith("KV") || name.startsWith("IDENTITY")) {
        continue;
      }
      
      let isDeprecated = errorDoc.match(/^deprecated\s*=\s*true\s*$/m);
      let isExperimental = errorDoc.match(/^experimental\s*=\s*true\s*$/m);

      // Strip error doc
      errorDoc = errorDoc.replace(/---.*---\s+#[^\n]+\s+/gs, '');
      errorDoc = errorDoc.replace(/<!--(.*?)-->/gs, '');
      errorDoc = `## ${title}\n\n<Summary>{\`${name}\`}</Summary>\n\n${errorDoc}`;

      // Add to index of error pages if not deprecated
      if (!isDeprecated && !isExperimental) {
        pages.push({ title: title, name: name, doc: errorDoc });
      }
    } else if (dirEntry.isDirectory) {
      await processErrorDir(inputPathEntry, pages);
    }
  }

  pages.sort((a, b) => a.name.localeCompare(b.name));
}

function camelToKebab(input) {
  return input.replace(/(.)([A-Z])/g, '$1-$2').toLowerCase();
}

function capitalizeFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

await main();
