# Rivet Documentation - Complete

This file contains the complete documentation for Rivet, an open-source alternative to Durable Objects.

## Actions

# Actions

Actions are how your backend, frontend, or other actors can communicate with actors. Actions are defined as functions in the actor configuration and can be called from clients.

Actions are very lightweight. They can be called thousands of times per second safely.

Actions are executed via HTTP requests or via WebSockets if [using `.connect()`](/docs/actors/connections).

For advanced use cases that require direct access to HTTP requests or WebSocket connections, see [raw HTTP and WebSocket handling](/docs/actors/fetch-and-websocket-handler).

## Writing Actions

Actions are defined in the `actions` object when creating an actor:

```typescript
const mathUtils = actor(,
  actions: 
  }
});
```

Each action receives a context object (commonly named `c`) as its first parameter, which provides access to state, connections, and other utilities. Additional parameters follow after that.

## Calling Actions

Actions can be called in different ways depending on your use case:

```typescript }
const client = createClient("http://localhost:8080");
const counter = await client.counter.getOrCreate();
const result = await counter.increment(42);
console.log(result); // The value returned by the action
```

Learn more about [communicating with actors from the frontend](/docs/actors/communicating-between-actors).

```typescript }
const registry = setup(
});

const  = registry.runServer();

// Use the client to call actions
const counter = await client.counter.getOrCreate();
const result = await counter.increment(42);
console.log(result);
```

Learn more about [communicating with actors from the backend](/docs/actors/communicating-between-actors).

```typescript }
const actorA = actor(,
  actions: 
  }
});
```

Learn more about [communicating between actors](/docs/actors/communicating-between-actors).

Calling actions from the client are async and require an `await`, even if the action itself is not async.

### Type Safety

The actor client includes type safety out of the box. When you use `createClient()`, TypeScript automatically infers action parameter and return types:

```typescript }
// Create simple counter
const counter = actor(,
  actions: 
  }
});

// Create and the app
const registry = setup(
});
```

```typescript }
const client = createClient("http://localhost:8080");

// Type-safe client usage
const counter = await client.counter.get();
await counter.increment(123); // OK
await counter.increment("non-number type"); // TypeScript error
await counter.nonexistentMethod(123); // TypeScript error
```

## Error Handling

Actors provide robust error handling out of the box for actions.

### User Errors

`UserError` can be used to return rich error data to the client. You can provide:

-   A human-readable message
-   A machine-readable code that's useful for matching errors in a try-catch (optional)
-   A metadata object for providing richer error context (optional)

For example:

```typescript }
const user = actor(,
  actions: 
        });
      }
      
      // Rest of the user registration logic...
    }
  }
});
```

```typescript }
try  catch (error) 
}
```

### Internal Errors

All other errors will return an error with the code `internal_error` to the client. This helps keep your application secure, as errors can sometimes expose sensitive information.

## Schema Validation

If passing data to an actor from the frontend, use a library like [Zod](https://zod.dev/) to validate input data.

For example, to validate action parameters:

```typescript }
// Define schema for action parameters
const IncrementSchema = z.object();

const counter = actor(,
  actions:  = IncrementSchema.parse(params);
        c.state.count += count;
        return c.state.count;
      } catch (err) 
        });
      }
    }
  }
});
```

## Authentication

By default, actors' actions are only accessible from your server-side client.

In order to expose actions publicly to the external client, you'll need to define `onAuth`. More documentation on authentication is available [here](/docs/actors/authentication). Read more about the [types of clients](/docs/actors/clients)

## Streaming Return Data

Actions have a single return value. To stream realtime data in response to an action, use [events](/docs/actors/events).

## Using `ActionContext` Externally

When writing complex logic for actions, you may want to extract parts of your implementation into separate helper functions. When doing this, you'll need a way to properly type the context parameter.

Rivet provides the `ActionContextOf` utility type for exactly this purpose:

```typescript
const counter = actor(,
  
  actions: 
  }
});

// Simple helper function with typed context
function incrementCount(c: ActionContextOf) 
```

See [helper types](/docs/actors/helper-types) for more details on using `ActionContextOf` and other utility types.
## Authentication

# Authentication

Secure your actors with authentication and authorization

Rivet provides multiple authentication methods to secure your actors. Use `onAuth` for server-side validation or `onBeforeConnect` for actor-level authentication.

## Authentication Methods

### onAuth Hook (Recommended)

The `onAuth` hook runs on the HTTP server before clients can access actors. This is the preferred method for most authentication scenarios.

```typescript
const chatRoom = actor(, ) => 
    
    // Validate token and return user data
    const user = await validateJWT(token);
    return ;
  },
  
  state: ,
  
  actions:  = c.conn.auth;
      
      if (role !== "member") 
      
      const message = ;
      
      c.state.messages.push(message);
      c.broadcast("newMessage", message);
      return message;
    }
  }
});
```

### `onBeforeConnect` Hook

Use `onBeforeConnect` when you need access to actor state for authentication:

```typescript
const userProfileActor = actor(),
  
  state: ,
  
  onBeforeConnect: async (c, opts) =>  = opts;
    const userId = await validateUser(params.token);
    
    // Check if user can access this profile
    if (c.state.isPrivate && c.state.ownerId !== userId) 
  },
  
  createConnState: (c, opts, params: ) => ;
  },
  
  actions: 
      
      // Update profile...
    }
  }
});
```

Prefer `onAuth` over `onBeforeConnect` when possible, as `onAuth` runs on the HTTP server and uses fewer actor resources.

## Connection Parameters

Pass authentication data when connecting:

```typescript
// Client side
const chat = client.chatRoom.getOrCreate(["general"]);
const connection = chat.connect();

// Or with action calls
const counter = client.counter.getOrCreate(["user-counter"], );
```

## Intent-Based Authentication (Experimental)

The `onAuth` hook receives an `intents` parameter indicating what the client wants to do:

```typescript
const secureActor = actor(, ) =>  else if (intents.has("connect")) 
    
    throw new UserError("Unknown intent");
  },
  
  actions: 
  }
});
```

## Error Handling

### Authentication Errors

Use specific error types for different authentication failures:

```typescript
const protectedActor = actor() => 
    
    try  catch (error) 
      throw new Unauthorized("Invalid authentication token");
    }
  },
  
  actions: 
      return "Admin content";
    }
  }
});
```

### Client Error Handling

Handle authentication errors on the client:

```typescript
try  catch (error)  else if (error.code === "FORBIDDEN") 
}
```

## Integration with Auth Providers

### Better Auth Integration

  Complete integration guide for Better Auth

### JWT Authentication

```typescript
const jwtActor = actor(, ) => 
    
    try ;
    } catch (error) 
  },
  
  actions:  = c.conn.auth;
      
      if (!permissions.includes("write")) 
      
      // Perform action...
      return ;
    }
  }
});
```

### API Key Authentication

```typescript
const apiActor = actor(, ) => 
    
    // Validate with your API service
    const response = await fetch(`$/validate`, 
    });
    
    if (!response.ok) 
    
    const user = await response.json();
    return ;
  },
  
  actions: 
      
      return "Premium content";
    }
  }
});
```

## Role-Based Access Control

Implement RBAC with helper functions:

```typescript
// auth-helpers.ts
function requireRole(requiredRole: string) ;
    
    if (roleHierarchy[userRole]  ' required`);
    }
  };
}

// usage in actor
const forumActor = actor() => ,
  
  actions: ,
    
    editPost: (c, postId: string, content: string) => 
  }
});
```

## Testing Authentication

Mock authentication for testing:

```typescript
// test helpers
function createMockAuth(userData: any) ;
}

// in tests
describe("Protected Actor", () => )
    };
    
    const result = await mockActor.adminOnly();
    expect(result).toBe("Admin content");
  });
  
  it("denies non-admin actions", async () => )
    };
    
    await expect(mockActor.adminOnly()).rejects.toThrow("Admin access required");
  });
});
```

## Best Practices

1. **Use onAuth**: Prefer `onAuth` over `onBeforeConnect` for most authentication
2. **Validate Early**: Authenticate at the HTTP server level when possible
3. **Specific Errors**: Use appropriate error types (Unauthorized, Forbidden)
4. **Rate Limiting**: Consider rate limiting in your authentication logic
5. **Token Refresh**: Handle token expiration gracefully on the client
6. **Audit Logging**: Log authentication events for security monitoring
7. **Least Privilege**: Only grant the minimum permissions needed
## Actor Clients

# Actor Clients

Learn how to call actions and connect to actors from client applications using Rivet's TypeScript client library.

Rivet also supports [React](/docs/clients/react) and [Rust](/docs/clients/rust) clients.

Using the RivetKit client is completely optional. If you prefer to write your own networking logic, you can either:

- Make HTTP requests directly to the registry (see [OpenAPI spec](/docs/clients/openapi))
- Write your own HTTP endpoints and use the client returned from `registry.runServer` (see below)

## Client Setup

There are several ways to create a client for communicating with actors:

		From your backend server that hosts the registry:

		```typescript }
		const  = registry.createServer();

		const app = new Hono();

		app.post("/foo", () => );

		serve(app);
		```

		This client doesn't [require authentication](/docs/actors/authentication).

		For frontend applications or external services connecting to your Rivet backend:

		```typescript }
		// IMPORTANT: Must use `type`

		const client = createClient("http://localhost:8080");

		const response = await client.otherActor.getOrCreate().foo();
		```

		Configure the client with additional options:

		```typescript }
		const client = createClient("http://localhost:8080", );
		```

		This client [requires authentication](/docs/actors/authentication).

		**Important**: Use `import type` when importing the registry type in order to
		avoid accidentally bundling your backend code.

		```typescript }
		// âœ… Do this
		// ðŸš« Not this
		```

		From within an actor to communicate with other actors:

		```typescript }
		const myActor = actor(
			}
		});
		```

		This client doesn't [require authentication](/docs/actors/authentication).

		Read more about [communicating between actors](/docs/actors/communicating-between-actors).

## `ActorClient`

The `ActorClient` provides methods for finding and creating actors. All methods return an `ActorHandle` that you can use to call actions or establish connections.

### `get(key?, opts?)` - Find Existing Actor

Returns a handle to an existing actor or `null` if it doesn't exist:

```typescript
// Get existing actor by key
const handle = client.myActor.get(["actor-id"]);

if (handle)  else 
```

### `getOrCreate(key?, opts?)` - Find or Create Actor

Returns a handle to an existing actor or creates a new one if it doesn't exist:

```typescript
// Get or create actor (synchronous)
const counter = client.counter.getOrCreate(["my-counter"]);

// With initialization input
const game = client.game.getOrCreate(["game-123"], 
});

// Call actions immediately
const count = await counter.increment(5);
```

`get()` and `getOrCreate()` are synchronous and return immediately. The actor is created lazily when you first call an action.

### `create(key?, opts?)` - Create New Actor

Explicitly creates a new actor instance, failing if one already exists:

```typescript
// Create new actor (async)
const newGame = await client.game.create(["game-456"], 
});

// Actor is guaranteed to be newly created
await newGame.initialize();
```

### `getForId(id, opts?)` - Find by Internal ID

Connect to an actor using its internal system ID:

```typescript
// Connect by internal ID
const actorId = "55425f42-82f8-451f-82c1-6227c83c9372";
const actor = client.myActor.getForId(actorId);

await actor.performAction();
```

Prefer using keys over internal IDs for actor discovery. IDs are primarily for debugging and advanced use cases.

## `ActorHandle`

An `ActorHandle` represents a reference to an actor instance and provides methods for calling actions and establishing connections. You get an `ActorHandle` from the `ActorClient` methods like `get()`, `getOrCreate()`, and `create()`.

### Calling Actions

You can call actions directly on an `ActorHandle`:

```typescript
const counter = client.counter.getOrCreate(["my-counter"]);

// Call actions directly
const count = await counter.increment(5);
const currentValue = await counter.getCount();
await counter.reset();
```

Actions called on an `ActorHandle` are stateless - each call is independent and doesn't maintain a persistent connection to the actor.

### `fetch(input, init?)` - Raw HTTP Requests

Make direct HTTP requests to the actor's `onFetch` handler:

```typescript
const actor = client.myActor.getOrCreate(["key"]);

// GET request
const response = await actor.fetch("/api/hello", );
const data = await response.json();

// POST request with body
const postResponse = await actor.fetch("/api/echo", ,
  body: JSON.stringify()
});

// Can also pass a Request object
const request = new Request("/api/data", );
const requestResponse = await actor.fetch(request);
```

See [Fetch & WebSocket Handler](/docs/actors/fetch-and-websocket-handler) documentation for more information.

For most use cases, actions provide a higher-level API that's easier to work with than raw HTTP handlers.

### `websocket(path?, protocols?)` - Raw WebSocket Connections

Create direct WebSocket connections to the actor's `onWebSocket` handler:

```typescript
const actor = client.myActor.getOrCreate(["key"]);

// Basic WebSocket connection
const ws = await actor.websocket();
ws.addEventListener("message", (event) => );
ws.send("Hello WebSocket!");

// WebSocket with custom path
const streamWs = await actor.websocket("/stream");

// WebSocket with protocols
const protocolWs = await actor.websocket("/", ["chat", "v1"]);
```

See [Fetch & WebSocket Handler](/docs/actors/fetch-and-websocket-handler) documentation for more information.

For most use cases, actions & events provide a higher-level API that's easier to work with than raw HTTP handlers.

### `connect(params?)` - Establish Stateful Connection

To open a stateful connection using `ActorConn`, call `.connect()`:

```typescript
const counter = client.counter.getOrCreate(["live-counter"]);
const connection = counter.connect();

// Listen for events
connection.on("countChanged", (newCount: number) => );

// Call actions through the connection
const result = await connection.increment(1);

// Clean up when done
await connection.dispose();
```

## `ActorConn`

Real-time connections enable bidirectional communication between clients and actors through persistent connections. Rivet automatically negotiates between WebSocket (preferred for full duplex) and Server-Sent Events (SSE) as a fallback for restrictive environments.

For more information on connections, see the [connections documentation](/docs/actors/connections). For more information on handling events, see the [events documentation](/docs/actors/events).

### Calling Actions

You can also call actions through an `ActorConn`, just like with an `ActorHandle`:

```typescript
const connection = counter.connect();

// Call actions through the connection
const count = await connection.increment(5);
const currentValue = await connection.getCount();
```

### Reconnections

Connections automatically handle network failures with built-in reconnection logic:

- **Exponential backoff**: Retry delays increase progressively to avoid overwhelming the server
- **Action queuing**: Actions called while disconnected are queued and sent once reconnected
- **Event resubscription**: Event listeners are automatically restored on reconnection

### `on(eventName, callback)` - Listen for Events

Listen for events from the actor:

```typescript
// Listen for chat messages
connection.on("messageReceived", (message) => : $`);
});

// Listen for game state updates
connection.on("gameStateChanged", (gameState) => );

// Listen for player events
connection.on("playerJoined", (player) =>  joined the game`);
});
```

### `once(eventName, callback)` - Listen Once

Listen for an event only once:

```typescript
// Wait for game to start
connection.once("gameStarted", () => );
```

### `dispose()` - Clean Up Connection

Always dispose of connections when finished to free up resources:

```typescript
const connection = actor.connect();

try  finally 

// Or with automatic cleanup in React/frameworks
useEffect(() => ;
}, []);
```

**Important:** Disposing a connection:
- Closes the underlying WebSocket or SSE connection
- Removes all event listeners
- Cancels any pending reconnection attempts
- Prevents memory leaks in long-running applications

## Authentication

### Connection Parameters

Pass authentication data when connecting to actors:

```typescript
// With connection parameters
const chat = client.chatRoom.getOrCreate(["general"], 
});

const connection = chat.connect();

// Or for action calls
const result = await chat.sendMessage("Hello world!");
```

### onAuth Hook Validation

Actors can validate authentication using the `onAuth` hook:

```typescript
const protectedActor = actor( = opts;
    
    // Extract token from params or headers
    const token = params.authToken || req.headers.get("Authorization");
    
    if (!token) );
    }
    
    // Validate and return user data
    const user = await validateJWT(token);
    
    // Check permissions based on what the client is trying to do
    if (intents.has("create") && user.role !== "admin") );
    }
    
    return ;
  },
  
  actions:  = c.conn.auth;
      
      if (role !== "admin") );
      }
      
      return `Hello admin $`;
    }
  }
});
```

Learn more about [authentication patterns](/docs/actors/authentication).

## Type Safety

Rivet provides end-to-end type safety between clients and actors:

### Action Type Safety

TypeScript validates action signatures and return types:

```typescript
// TypeScript knows the action signatures
const counter = client.counter.getOrCreate(["my-counter"]);

const count: number = await counter.increment(5);   // âœ“ Correct
const invalid = await counter.increment("5");       // âœ— Type error

// IDE autocomplete shows available actions
counter./*  */
```

### Client Type Safety

Import types from your registry for full type safety:

```typescript
// Client is fully typed
const client = createClient("http://localhost:8080");

// IDE provides autocomplete for all actors
client./*  */
```

## Best Practices

### `ActorHandle` (Stateless) vs `ActorConn` (Stateful) Clients

**Use `ActorHandle` (Stateless) For:**
- Simple request-response operations
- One-off operations  
- Server-side integration

```typescript
// Good for simple operations
const result = await counter.increment(1);
const status = await server.getStatus();
```

**Use `ActorConn` (Stateful) Connections For:**
- Real-time updates needed
- Event-driven interactions
- Long-lived client sessions

```typescript
// Good for real-time features
const connection = chatRoom.connect();
connection.on("messageReceived", updateUI);
await connection.sendMessage("Hello!");
```

### Resource Management

Always clean up connections when finished:

```typescript
// Manual cleanup
const connection = actor.connect();
try  finally 
```

### Error Handling

Handle connection errors using the `.onError()` method:

```typescript }
const connection = actor.connect();

connection.onError((error) =>  else if (error.code === 'ACTOR_NOT_FOUND') 
});
```

```tsx }
function ConnectionErrorHandler() );

  useEffect(() => , 5000);
    });

    // Clean up error handler when component unmounts
    return unsubscribe;
  }, [actor.connection]);

  // ...rest of component...
}
```

### Execute Actions in Parallel

You can execute batch requests in parallel:

```typescript
// Batch multiple operations through a connection
const connection = actor.connect();
await Promise.all([
  connection.operation1(),
  connection.operation2(),
  connection.operation3(),
]);

// Use getOrCreate for actors you expect to exist
const existing = client.counter.getOrCreate(["known-counter"]);

// Use create only when you need a fresh instance
const fresh = await client.counter.create(["new-counter"]);
```

However, it's recommended to move this logic to run within the actor instead of the client if executing multiple actions is a common pattern.
## Communicating Between Actors

# Communicating Between Actors

Learn how actors can call other actors and share data

Actors can communicate with each other using the server-side actor client, enabling complex workflows and data sharing between different actor instances.

We recommend reading the [clients documentation](/docs/actors/clients) first. This guide focuses specifically on communication between actors.

## Using the Server-Side Actor Client

The server-side actor client allows actors to call other actors within the same registry. Access it via `c.client()` in your actor context:

```typescript
const orderProcessor = actor(,
  
  actions: );
      
      return ;
    }
  }
});
```

## Use Cases and Patterns

### Actor Orchestration

Use a coordinator actor to manage complex workflows:

```typescript
const workflowActor = actor(,
  
  actions: );
      return result;
    }
  }
});
```

### Data Aggregation

Collect data from multiple actors:

```typescript
const analyticsActor = actor(,
  
  actions: ,
        generatedAt: Date.now()
      };
      
      c.state.reports.push(report);
      return report;
    }
  }
});
```

### Event-Driven Architecture

Use connections to listen for events from other actors:

```typescript
const auditLogActor = actor(,
  
  actions: );
      });
      
      // Listen for order events
      orderActor.on("orderCompleted", (order) => );
      });
      
      return ;
    }
  }
});
```

### Batch Operations

Process multiple items in parallel:

```typescript
// Process items in parallel
const results = await Promise.all(
  items.map(item => client.processor.getOrCreate([item.type]).process(item))
);
```
## Connections

# Connections

Connections represent client connections to your actor. They provide a way to handle client authentication, manage connection-specific data, and control the connection lifecycle.

## Parameters

When clients connect to an actor, they can pass connection parameters that are handled during the connection process.

For example:

```typescript }
const client = createClient("http://localhost:8080");
const gameRoom = await client.gameRoom.get(
});
```

```typescript }
const gameRoom = actor(,
  
  // Handle connection setup
  createConnState: (c, opts, params: ) => 
    
    // Create connection state
    return ;
  },
  
  actions: 
});
```

## Connection State

There are two ways to define an actor's connection state:

		Define connection state as a constant value:

		```typescript
		const chatRoom = actor(,
		  
		  // Define default connection state as a constant
		  connState: ,
		  
		  onConnect: (c) => ,
		  
		  actions: 
		});
		```

		This value will be cloned for every new connection using `structuredClone`.

		Create connection state dynamically with a function called for each connection:

		```typescript
		const chatRoom = actor(,
		  
		  // Create connection state dynamically
		  createConnState: (c) => ;
		  },
		  
		  actions: );
		      c.broadcast("newMessage", );
		    }
		  }
		});
		```

## Connection Lifecycle Hooks

The connection lifecycle has several hooks:

- `onBeforeConnect`: Called before a client connects, returns the connection state
- `onConnect`: Called when a client successfully connects
- `onDisconnect`: Called when a client disconnects

See the documentation on [Actor Lifecycle](/docs/actors/lifecycle) for more details.

## Connection List

All active connections can be accessed through the context object's `conns` property. This is an array of all current connections.

This is frequently used with `conn.send(name, event)` to send messages directly to clients.

For example:

```typescript
const chatRoom = actor( },
  
  actions: );
      }
    }
  }
});
```

## Disconnecting clients

Connections can be disconnected from within an action:

```typescript
const secureRoom = actor(,
  
  actions: 
    }
  }
});
```

If you need to wait for the disconnection to complete, you can use `await`:

```typescript
await c.conn.disconnect('Too many requests');
```

This ensures the underlying network connections close cleanly before continuing.

## Connection Error Handling

Handle connection errors using the `.onError()` method:

```typescript }
const connection = actor.connect();

connection.onError((error) =>  else if (error.code === 'ACTOR_NOT_FOUND') 
});
```

```tsx }
function ConnectionErrorHandler() );

  useEffect(() => , 5000);
    });

    // Clean up error handler when component unmounts
    return unsubscribe;
  }, [actor.connection]);

  // ...rest of component...
}
```

## Offline & Auto-Reconnection

See [client documentation](/docs/actors/communicating-between-actors) for details on reconnection behavior.
## Ephemeral Variables

# Ephemeral Variables

In addition to persisted state, Rivet provides a way to store ephemeral data that is not saved to permanent storage using `vars`. This is useful for temporary data that only needs to exist while the actor is running or data that cannot be serialized.

`vars` is designed to complement `state`, not replace it. Most actors should use both: `state` for critical business data and `vars` for ephemeral or non-serializable data.

## Initializing Variables

There are two ways to define an actor's initial vars:

Define an actor vars as a constant value:

```typescript
// Define vars as a constant
const counter = actor(,
  
  // Define ephemeral variables
  vars: ,
  
  actions: 
});
```

This value will be cloned for every new actor using `structuredClone`.

Create actor state dynamically on each actors' start:

```typescript
// Define vars with initialization logic
const counter = actor(,
  
  // Define vars using a creation function
  createVars: (c: ActorInitContext, driver: any) => ;
  },
  
  actions: 
});
```

If accepting arguments to `createVars`, you **must** define the types: `createVars(c: ActorInitContext, driver: any)`

Otherwise, the return type will not be inferred and `c.vars` will be of type `unknown`.

## Using Variables

Vars can be accessed and modified through the context object with `c.vars`:

```typescript
const counter = actor(,
  
  // Create ephemeral objects that won't be serialized
  createVars: () => `);
    });
    
    return ;
  },
  
  actions: 
  }
});
```

## When to Use `vars` vs `state`

In practice, most actors will use both: `state` for critical business data and `vars` for ephemeral or non-serializable data.

Use `vars` when:

- You need to store temporary data that doesn't need to survive restarts
- You need to maintain runtime-only references that can't be serialized (database connections, event emitters, class instances, etc.)

Use `state` when:

- The data must be preserved across actor sleeps, restarts, updates, or crashes
- The information is essential to the actor's core functionality and business logic

## Advanced

### Accessing Driver Context

The `createVars` function receives a second parameter that provides access to driver-specific context. This allows you to access driver-specific functionality.

For example, the Redis driver exposes access to the Redis instance:

```typescript
const myActor = actor(,
  
  // The second parameter provides driver-specific context
  createVars: (ctx: ActorInitContext, driver: DriverContext) => (),
  
  actions: 
  }
});
```

Consult the documentation for each driver to learn more about their respective `DriverContext` types.
## Events

# Events

Events enable real-time communication from actors to clients. While clients use actions to send data to actors, events allow actors to push updates to connected clients instantly.

Events work through persistent connections such as WebSocket or SSE.

## Publishing Events from Actors

### Broadcasting to All Clients

Use `c.broadcast(eventName, data)` to send events to all connected clients:

```typescript
const chatRoom = actor(,
  
  actions: ;
      
      c.state.messages.push(message);
      
      // Broadcast to all connected clients
      c.broadcast('messageReceived', message);
      
      return message;
    },
  }
});
```

### Sending to Specific Connections

Send events to individual connections using `conn.send(eventName, data)`:

```typescript
const gameRoom = actor( as Record
  },
  
  createConnState: (c, opts, params: ) => (),
  
  actions: );
      } else 
    }
  }
});
```

Send events to all connections except the sender:

```typescript
const gameRoom = actor( as Record
  },
  
  createConnState: (c, opts, params: ) => (),
  
  actions: ) => );
          }
        }
      }
    }
  }
});
```

## Subscribing to Events from Clients

Clients must establish a connection to receive events from actors. Use `.connect()` to create a persistent connection, then listen for events.

### Basic Event Subscription

Use `connection.on(eventName, callback)` to listen for events:

```typescript }
const client = createClient("http://localhost:8080");

// Get actor handle and establish connection
const chatRoom = client.chatRoom.getOrCreate(["general"]);
const connection = chatRoom.connect();

// Listen for events
connection.on('messageReceived', (message) => : $`);
  displayMessage(message);
});

// Call actions through the connection
await connection.sendMessage("user-123", "Hello everyone!");
```

```tsx }
function ChatRoom() );

  // Listen for events
  chatRoom.useEvent("messageReceived", (message) => );

  // ...rest of component...
}
```

### One-time Event Listeners

Use `connection.once(eventName, callback)` for events that should only trigger once:

```typescript }
const gameRoom = client.gameRoom.getOrCreate(["room-456"]);
const connection = gameRoom.connect();

// Listen for game start (only once)
connection.once('gameStarted', () => );
```

```tsx }
function GameLobby() 
  });

  // Listen for game start (only once)
  useEffect(() => ;

    gameRoom.connection.once('gameStarted', handleGameStart);
  }, [gameRoom.connection]);

  // ...rest of component...
}
```

### Removing Event Listeners

Use the callback returned from `.on()` to remove event listeners:

```typescript }
// Add listener
const unsubscribe = connection.on('messageReceived', (message) => );

// Remove listener
unsubscribe();
```

```tsx }
function ConditionalListener() );

  useEffect(() => : $`]);
    });

    // Cleanup - remove listener when component unmounts or listening stops
    return () => ;
  }, [chatRoom.connection, isListening]);

  // ...rest of component...
}
```

## More About Connections

For more details on actor connections, including connection lifecycle, authentication, and advanced connection patterns, see the [Connections documentation](/docs/actors/connections).
## External SQL Database

# External SQL Database

While actors can serve as a complete database solution, they can also complement your existing databases. For example, you might use actors to handle frequently-changing data that needs real-time access, while keeping less frequently accessed data in your traditional database.

Actors can be used with common SQL databases, such as PostgreSQL and MySQL.

## Libraries

To facilitate interaction with SQL databases, you can use either ORM libraries or raw SQL drivers. Each has its own use cases and benefits:

-   **ORM Libraries**: Type-safe and easy way to interact with your database

    -   [Drizzle](https://orm.drizzle.team/)
    -   [Prisma](https://www.prisma.io/)

-   **Raw SQL Drivers**: Direct access to the database for more flexibility

    -   [PostgreSQL](https://node-postgres.com/)
    -   [MySQL](https://github.com/mysqljs/mysql)

## Hosting Providers

There are several options for places to host your SQL database:

-   [Supabase](https://supabase.com/)
-   [Neon](https://neon.tech/)
-   [PlanetScale](https://planetscale.com/)
-   [AWS RDS](https://aws.amazon.com/rds/)
-   [Google Cloud SQL](https://cloud.google.com/sql)

## Examples

### Basic PostgreSQL Connection

Here's a basic example of a user actor that creates a database record on start and tracks request counts:

```typescript }
interface ActorInput 

// Create a database connection pool
const pool = new Pool();

// Create the user actor
const userActor = actor(),
  
  // Insert user into database when actor starts
  onStart: async (c, opts) => ,
  
  actions: ;
    },
    
    // Get user data
    getUser: async (c) => ;
    }
  }
});

const registry = setup(,
});
```

```typescript }
const client = createClient("http://localhost:8080");

// Create user
const alice = await client.userActor.create("alice", 
});

alice.updateUser("alice2@example.com");

const userData = await alice.getUser();
console.log("User data:", userData);

// Create another user
const bob = await client.userActor.create("bob", 
});
const bobData = await bob.getUser();
```

### Using Drizzle ORM

Here's the same user actor pattern using Drizzle ORM for more type-safe database operations:

```typescript }
interface ActorInput 

// Define your schema
const users = pgTable("users", );

// Create a database connection
const pool = new Pool();

// Initialize Drizzle with the pool
const db = drizzle(pool);

// Create the user actor
const userActor = actor(),
  
  // Insert user into database when actor starts
  onStart: async (c, opts) => );
  },
  
  actions: )
        .where(eq(users.username, c.state.username));
      
      return ;
    },
    
    // Get user data
    getUser: async (c) => ;
    }
  }
});

const registry = setup(,
});
```

```typescript }
const client = createClient("http://localhost:8080");

// Create user
const alice = await client.userActor.create("alice", 
});

alice.updateUser("alice2@example.com");

const userData = await alice.getUser();
console.log("User data:", userData);

// Create another user
const bob = await client.userActor.create("bob", 
});
const bobData = await bob.getUser();
```
## Fetch and WebSocket Handler

# Fetch and WebSocket Handler

Actors can handle HTTP requests and WebSocket connections through the `onFetch` and `onWebSocket` handlers.

For most use cases, [actions](/docs/actors/actions) and [events](/docs/actors/events) provide high-level connection handling that's easier to work with. However, raw handlers are required when implementing custom use cases or integrating external libraries that need direct access to the underlying HTTP `Request`/`Response` objects or WebSocket connections.

## Defining Handlers

### `onFetch(c, request, )`

The `onFetch` handler processes HTTP requests sent to your actor. It receives the actor context and a standard `Request` object.

WebSocket upgrades are not currently supported in `onFetch`. Use `onWebSocket` instead.

```typescript
const httpActor = actor(,
    actions: ,
    onFetch(ctx, request) ), ,
            });
        }

        if (url.pathname === "/api/echo" && request.method === "POST") );
        }

        // Return 404 for unhandled paths
        return new Response("Not Found", );
    },
});
```

```typescript
function buildRouter(ctx: ActorContext) );
    });

    app.post("/api/echo", async (c) => );

    app.get("/api/stats", (c) => );
    });

    return app;
}

const honoActor = actor(,
    createVars(ctx) ;
    },
    actions: ,
    async onFetch(ctx, request) ,
});
```

Also see the [raw fetch handler example project](https://github.com/rivet-gg/rivetkit/tree/main/examples/raw-fetch-handler).

	`onFetch` can be used to expose Server-Sent Events from Rivet Actors.

### `onWebSocket(c, websocket, )`

The `onWebSocket` handler manages WebSocket connections. It receives the actor context, a `WebSocket` object, and the initial `Request`.

```typescript
const websocketActor = actor(,
    actions: ,
    onWebSocket(ctx, websocket) ));

        websocket.addEventListener("message", (event) => );
    },
});
```

Also see the [raw WebSocket handler with proxy example project](https://github.com/rivet-gg/rivetkit/tree/main/examples/raw-websocket-handler-proxy).

	Connection lifecycle hooks like `onConnect` and `onDisconnect` do not get called when opening WebSockets for `onWebSocket`. This is because `onWebSocket` provides a low-level connection. Use `ws.addEventListener("open")` and `ws.addEventListener("close")` instead.

## Accessing Your Handlers

There are three ways to access your actor's fetch and WebSocket handlers:

### Option A: From Backend via RivetKit Client

You can use the RivetKit client's built-in methods for raw HTTP and WebSocket access:

```typescript
const client = createClient("http://localhost:8080");

// HTTP requests using .fetch() method
const actor = client.myActor.getOrCreate(["key"]);
const response = await actor.fetch("/api/hello", );
const data = await response.json();

// POST request with JSON body
const postResponse = await actor.fetch("/api/echo", ,
    body: JSON.stringify(),
});
```

```typescript
const client = createClient("http://localhost:8080");

// WebSocket connections using .websocket() method
const actor = client.myActor.getOrCreate(["key"]);
const ws = await actor.websocket("/custom/path");

// Listen for messages
ws.addEventListener("message", (event) =>  else if (message.type === "echo")  else if (message.type === "pong") 
});

// Send messages
ws.send(JSON.stringify());

// Send ping
ws.send(JSON.stringify());
```

For more advanced use cases, you can forward requests to actor handlers from your server:

```typescript
const  = registry.createServer();

const app = new Hono();

// Forward requests to actor's fetch handler
app.all("/forward/:name/*", async (c) => `, "");
    const url = new URL(truncatedPath, c.req.url);
    const newRequest = new Request(url, c.req.raw);
    
    // Forward to actor's fetch handler
    const actor = client.counter.getOrCreate(name);
    const response = await actor.fetch(truncatedPath, newRequest);
    
    return response;
});

serve(app);
```

```typescript
const  = registry.createServer();

const app = new Hono();

// Forward WebSocket connections to actor's WebSocket handler
app.get("/ws/:name", upgradeWebSocket(async (c) => );

            actorWs.addEventListener("close", () => );
        },
        onMessage: (evt, ws) => ,
        onClose: (evt, ws) => ,
    };
}));

serve(app);
```

### Option B: From Frontend with RivetKit Client

Use the RivetKit client to make direct HTTP requests or WebSocket connections:

```typescript
const client = createClient("http://localhost:8080");

// HTTP requests
const actor = client.myActor.getOrCreate(["key"]);
const response = await actor.fetch("/api/hello", );
const data = await response.json();
console.log(data); // 

// POST request with data
const postResponse = await actor.fetch("/api/echo", ,
    body: JSON.stringify(),
});

// Handle response
if (postResponse.ok)  else 
```

```typescript
const client = createClient("http://localhost:8080");

// WebSocket connections
const actor = client.myActor.getOrCreate(["key"]);
const ws = await actor.websocket("/");

// Listen for messages
ws.addEventListener("message", (event) => );
            break;
            
        case "echo":
            console.log("Echo received:", message.data);
            displayMessage(message.data);
            break;
            
        case "pong":
            console.log("Pong received, latency:", Date.now() - message.timestamp);
            break;
            
        case "error":
            console.error("Error:", message.message);
            break;
    }
});

// Send messages
function sendMessage(text) ));
}

// Ping for latency testing
function ping() ));
}

// Handle connection errors
ws.addEventListener("error", (event) => );

ws.addEventListener("close", () => );
```

	The `.websocket()` method returns a barebones WebSocket. Unlike [actor connections](/docs/actors/connections), it does not provide automatic reconnection logic. You must implement reconnection logic yourself if needed.

### Option C: From Frontend via Direct RivetKit Router Access

You can access your actor handlers directly through the mounted RivetKit router. The router automatically handles the required headers for authentication and routing.

For HTTP requests, the router expects these headers:
- `X-RivetKit-Actor-Query`: JSON-encoded actor query
- `X-RivetKit-Encoding`: Encoding type (usually "json")
- `X-RivetKit-Conn-Params`: JSON-encoded connection parameters (optional)

```typescript
// Direct HTTP request to actor
const response = await fetch("http://localhost:8080/registry/actors/myActor/raw/http/api/hello", 
        }),
        "X-RivetKit-Encoding": "json",
        "X-RivetKit-Conn-Params": JSON.stringify()
    }
});

const data = await response.json();
console.log(data); // 

// POST request with data
const postResponse = await fetch("http://localhost:8080/registry/actors/myActor/raw/http/api/echo", 
        }),
        "X-RivetKit-Encoding": "json",
        "X-RivetKit-Conn-Params": JSON.stringify(),
        "Content-Type": "application/json"
    },
    body: JSON.stringify()
});

// Handle response
if (postResponse.ok)  else 
```

For WebSocket connections, authentication data is passed via WebSocket subprotocols:

```typescript
// Direct WebSocket connection to actor
const protocols = [
    `query.$
    }))}`,
    `encoding.json`,
    `conn_params.$))}`
];

const ws = new WebSocket("ws://localhost:8080/registry/actors/myActor/ws/", protocols);

// Listen for messages
ws.addEventListener("message", (event) => );
            
            // Send initial message
            ws.send(JSON.stringify());
            break;
            
        case "echo":
            console.log("Echo received:", message.data);
            break;
            
        case "pong":
            console.log("Pong received, latency:", Date.now() - message.timestamp);
            break;
            
        case "error":
            console.error("WebSocket error:", message.message);
            break;
    }
});

// Send ping for latency testing
function sendPing() ));
}

// Handle connection events
ws.addEventListener("open", () => );

ws.addEventListener("error", (event) => );

ws.addEventListener("close", (event) => );
```

	For Cloudflare Workers, you must include `"rivetkit"` as a protocol when using raw WebSockets:
	
	```typescript
	const protocols = [
	    "rivetkit", // Required for Cloudflare Workers
	    `query.$
	    }))}`,
	    `encoding.json`
	];
	```

## Authentication

If you are using the external client, authentication is handled through the `onAuth` handler. The `onAuth` handler is executed on the server before the request is sent to the actor, reducing resource load on the actor by filtering out unauthorized requests early.

If you are using the server-side client, then authentication is skipped by default.

See the [authentication documentation](/docs/actors/authentication) for detailed information on implementing authentication patterns.

## State Saves

State changes in `onFetch` and `onWebSocket` handlers are automatically saved after the handler finishes executing.

For `onWebSocket` handlers specifically, you'll need to manually save state using `c.saveState()` while the WebSocket connection is open if you want state changes to be persisted immediately. This is because WebSocket connections can remain open for extended periods, and state changes made during event handlers (like `message` events) won't be automatically saved until the connection closes.

```typescript
const websocketActor = actor(,
    actions: ,
    onWebSocket(ctx, websocket) ));
        });
    },
});
```

For more details on state management, see [State](/docs/actors/state).

## W3C Compliance

It's not possible to use the global `fetch` method or global WebSocket class to connect to an actor. This is because actors do not have traditional network interfaces to communicate with.

However, the `Request`, `Response`, and `WebSocket` types used with `.fetch()` and `.websocket()` comply with the W3C specification and will work wherever you pass them.
## Helper Types

# Helper Types

Rivet provides several TypeScript helper types to make it easier to work with actors in a type-safe way.

## `Context` Types

When working with actors, you often need to access the context object outside of the actor's handlers. Rivet provides helper types to extract the context types from actor definitions.

### `ActorContextOf`

Extracts the full actor context type from an actor definition. This is the type of the context object (`c`) available in [lifecycle hooks](/docs/actors/lifecycle) and in [actions](/docs/actors/actions).

```typescript
const chatRoom = actor(,
  actions: ,
  actions: 
  }
});

// Now you can use this type elsewhere
function logMessage(context: ActorContextOf, message: string) );
}
```

### `ActionContextOf`

Extracts the action context type from an actor definition. This is the type of the context object (`c`) available in [actions](/docs/actors/actions). This cannot be used in [lifecycle hooks](/docs/actors/lifecycle).

```typescript
const counterWithProcessing = actor(,
  actions: 
  }
});

function processCounterAction(context: ActionContextOf) 
```
## Overview

# Overview

Actors for long-lived processes with durable state, realtime, and hibernate when not in use.

## Quickstart

  Set up actors with Node.js, Bun, and web frameworks

  Build real-time React applications with actors

## Features

- **Long-Lived, Stateful Compute**: Each unit of compute is like a tiny server that remembers things between requests â€“ no need to re-fetch data from a database or worry about timeouts. Like AWS Lambda, but with memory and no timeouts.

- **Blazing-Fast Reads & Writes**: State is stored on the same machine as your compute, so reads and writes are ultra-fast. No database round trips, no latency spikes.

- **Realtime, Made Simple**: Update state and broadcast changes in realtime with WebSockets or SSE. No external pub/sub systems, no polling â€“ just built-in low-latency events.

- **Store Data Near Your Users**: Your state lives close to your users on the edge â€“ not in a faraway data center â€“ so every interaction feels instant. (Not all platforms supported.)

- **Infinitely Scalable**: Automatically scale from zero to millions of concurrent actors. Pay only for what you use with instant scaling and no cold starts.

- **Fault Tolerant**: Built-in error handling and recovery. Actors automatically restart on failure while preserving state integrity and continuing operations.

- **Type Safety**: End-to-end TypeScript safety between clients and actors with full type inference and compile-time checking.

## Use Cases

Actors are perfect for applications that need persistent state and real-time updates:

- **AI & Automation**
  - **AI agents**: Stateful AI assistants with conversation history
  - **AI sandbox orchestration**: Actors can orchestrate logic running inside of agents' sandboxes
  - **Durable workflows**: Long-running business processes with state persistence and recovery

- **Real-time Communication**
  - **Chat rooms**: Real-time messaging with message history and user presence
  - **Collaborative documents**: Multiple users editing documents simultaneously (Yjs integration)
  - **Multiplayer games**: Game state management with real-time updates
  - **Live events**: Broadcasting updates to many participants

- **Data & Synchronization**
  - **Local-first sync**: Offline-first applications with server synchronization
  - **Multi-tenant databases**: Isolated data stores for each user or tenant
  - **Scheduling**: Time-based task execution with persistent state

- **Infrastructure**
  - **Rate limiting**: Distributed rate limiting with persistent counters
  - **Stream processing**: Real-time data processing with persistent state

## Core Concepts

### State Management

Actors maintain persistent state that survives restarts, crashes, and deployments. State can be defined as a constant or created dynamically:

```typescript
const counter = actor(,
  
  actions: ,
    
    getCount: (c) => c.state.count,
  }
});
```

Learn more about [state management](/docs/actors/state).

### Actions

Actions are the primary way to interact with actors. They're type-safe functions that can modify state and communicate with clients:

```typescript
const chatRoom = actor(,
  
  actions: ;
      c.state.messages.push(message);
      c.broadcast("newMessage", message);
      return message;
    },
    
    getMessages: (c) => c.state.messages
  }
});
```

Actions can be called from your backend, your clients, or other actors:

```typescript
const room = client.chatRoom.getOrCreate(["general"]);
const message = await room.sendMessage("user-123", "Hello everyone!");
```

Learn more about [actions](/docs/actors/actions) and [communicating with actors](/docs/actors/communicating-between-actors).

### Real-time Communication & Events

Actors support real-time bidirectional communication through WebSocket and SSE connections. Clients can establish persistent connections to receive live updates.

For example, to send events to all connected clients:

```typescript
const liveAuction = actor(,
  
  actions: );
      return amount;
    }
  }
});
```

Clients connect and listen for real-time updates:

```typescript
const auction = client.liveAuction.getOrCreate(["auction-123"]);
const connection = auction.connect();

connection.on("newBid", (data) => `);
});

await auction.placeBid(150);
```

Learn more about [events](/docs/actors/events) and [client communication](/docs/actors/communicating-between-actors).

### Scheduling & Lifecycle

Actors support scheduled tasks and lifecycle management:

```typescript
const reminder = actor(,
  
  actions: ,
    
    sendReminder: (c) => );
    }
  }
});
```

Learn more about [actor lifecycle](/docs/actors/lifecycle).

### Type Safety

Rivet provides end-to-end TypeScript safety between clients and actors:

```typescript Actor
const userManager = actor( as Record },
  
  actions: ;
      return ;
    },
    
    getUser: (c, userId: string) => c.state.users[userId]
  }
});
```

```typescript Client
const manager = client.userManager.getOrCreate(["default"]);

const user = await manager.createUser("Alice");
// Type: 

const foundUser = await manager.getUser(user.userId);
// Type:  | undefined
```

## Frequently Asked Questions

        Some software makes sense to separate â€“ e.g., for data lakes or highly relational data. But at the end of the day, data has to be partitioned somewhere at some point.

        Usually "faster" databases like Cassandra, DynamoDB, or Vitess make consistency tradeoffs to get better performance. Stateful serverless forces you to think about how your data is sharded for better performance, better scalability, and less consistency footguns.

        See [Sharing and Joining State](/docs/actors/sharing-and-joining-state) for detailed strategies on combining data from multiple actors.

        OLAP, data lakes, graph databases, and highly relational data are currently not ideal use cases for the actor model.

        Yes, but only in the same way that storing data in a single database row creates a bottleneck.

		Just like a single database row can cause contention when multiple clients try to read and write the same data, a single actor can become a bottleneck if too many requests target it.

		The solution is the same: shard your data across multiple actors to distribute the load and scale seamlessly.

		However, actors handle much higher throughput than traditional database rows because they keep data in memory, making read and write operations significantly faster.
## Input Parameters

# Input Parameters

Pass initialization data to actors when creating instances

Actors can receive input parameters when created, allowing for flexible initialization and configuration. Input is passed during actor creation and is available in lifecycle hooks.

## Passing Input to Actors

Input is provided when creating actor instances using the `input` property:

```typescript
// Client side - create with input
const game = await client.game.create(["game-123"], 
});

// getOrCreate can also accept input (used only if creating)
const gameHandle = client.game.getOrCreate(["game-456"], 
});
```

## Accessing Input in Lifecycle Hooks

Input is available in lifecycle hooks via the `opts.input` parameter:

```typescript
interface ChatRoomInput 

const chatRoom = actor(,
    messages: [],
  }),
  
  onCreate: (c, opts, input: ChatRoomInput) => `);
    
    // Setup external services based on input
    if (input.isPrivate) 
  },
  
  actions: ),
  },
});
```

## Input Validation

You can validate input parameters in the `createState` or `onCreate` hooks:

```typescript
const GameInputSchema = z.object();

const game = actor(,
      gameState: "waiting",
    };
  },
  
  actions: ),
  },
});
```

## Input vs Connection Parameters

Input parameters are different from connection parameters:

- **Input**:
  - Passed when creating the actor instance
  - Use for actor-wide configuration
  - Available in lifecycle hooks
- **Connection parameters**:
  - Passed when connecting to an existing actor
  - Used for connection-specific configuration
  - Available in connection hooks

```typescript
// Actor creation with input
const room = await client.chatRoom.create(["room-123"], ,
  params: 
});
```

## Input Best Practices

### Use Type Safety

Define input types to ensure type safety:

```typescript
interface GameInput 

const game = actor(),
  
  actions: ,
});
```

### Store Input in State

If you need to access input data in actions, store it in the actor's state:

```typescript
const game = actor(,
    // Runtime state
    players: ,
    gameState: "waiting",
  }),
  
  actions: ,
  },
});
```
## Actor Keys

# Actor Keys

Actor keys uniquely identify actor instances within each actor type. Keys are used for addressing which specific actor to communicate with.

## Key Format

Actor keys can be either a string or an array of strings:

```typescript
// String key
const counter = client.counter.getOrCreate("my-counter");

// Array key (compound key)
const chatRoom = client.chatRoom.getOrCreate(["room", "general"]);
```

### Compound Keys & User Data

Array keys are useful when you need compound keys with user-provided data. Using arrays makes adding user data safe by preventing key injection attacks:

```typescript
// User-specific chat rooms
const userRoom = client.chatRoom.getOrCreate(["user", userId, "private"]);

// Game rooms by region and difficulty
const gameRoom = client.gameRoom.getOrCreate(["us-west", "hard", gameId]);

// Multi-tenant resources
const workspace = client.workspace.getOrCreate(["tenant", tenantId, workspaceId]);
```

This allows you to create hierarchical addressing schemes and organize actors by multiple dimensions.

Don't build keys using string interpolation like `"foo:$:bar"` when `userId` contains user data. If a user provides a value containing the delimiter (`:` in this example), it can break your key structure and cause key injection attacks.

### Omitting Keys

You can create actors without specifying a key in situations where there is a singleton actor (i.e. only one actor of a given type). For example:

```typescript
// Get the singleton session
const globalActor = client.globalActor.getOrCreate();
```

This pattern should be avoided, since a singleton actor usually means you have a single actor serving all traffic & your application will not scale. See [scaling documentation](/docs/actors/scaling) for more information.

### Key Uniqueness

Keys are unique within each actor name. Different actor types can use the same key:

```typescript
// These are different actors, same key is fine
const userChat = client.chatRoom.getOrCreate(["user-123"]);
const userProfile = client.userProfile.getOrCreate(["user-123"]);
```

## Accessing Keys in Metadata

Access the actor's key within the actor using the [metadata](/docs/actors/metadata) API:

```typescript }
const chatRoom = actor(
  }
});

const registry = setup(
});
```

```typescript }
const client = createClient("http://localhost:8080");

async function connectToRoom(roomName: string) 

// Usage example
const generalRoom = await connectToRoom("general");
```

## Configuration Examples

### Simple Configuration with Keys

Use keys to provide basic actor configuration:

```typescript }
const userSession = actor(
  }),
  
  actions: 
});

const registry = setup(
});
```

```typescript }
const client = createClient("http://localhost:8080");

// Pass user ID in the key for user-specific actors
const userSession = client.userSession.getOrCreate([userId]);
```

### Complex Configuration with Input

For more complex configuration, use [input parameters](/docs/actors/input):

```typescript }
const client = createClient("http://localhost:8080");

// Create with both key and input
const chatRoom = await client.chatRoom.create(["room", roomName], 
  }
});
```
## Lifecycle

# Lifecycle

Understand actor lifecycle hooks and initialization patterns

Actors follow a well-defined lifecycle with hooks at each stage. Understanding these hooks is essential for proper initialization, state management, and cleanup.

## Lifecycle Hooks

Actor lifecycle hooks are defined as functions in the actor configuration.

### `createState` and `state`

The `createState` function or `state` constant defines the initial state of the actor (see [state documentation](/docs/actors/state)). The `createState` function is called only once when the actor is first created.

### `createVars` and `vars`

The `createVars` function or `vars` constant defines ephemeral variables for the actor (see [state documentation](/docs/actors/state)). These variables are not persisted and are useful for storing runtime-only objects or temporary data.

The `createVars` function can also receive driver-specific context as its second parameter, allowing access to driver capabilities like Rivet KV or Cloudflare Durable Object storage.

```typescript
// In this example, assume we're using Redis
// Using vars constant
const counter1 = actor(,
  vars: ,
  actions: 
});

// Using createVars function
const counter2 = actor(,
  createVars: () => ;
  },
  actions: 
});

// Access driver-specific context
const exampleActor = actor(,
  // Access driver context in createVars
  createVars: (c: ActorInitContext, driverCtx: DriverContext) => (),
  actions: 
  }
});
```

### `onCreate`

The `onCreate` hook is called at the same time as `createState`, but unlike `createState`, it doesn't return any value. Use this hook for initialization logic that doesn't affect the initial state.

```typescript
// Using state constant
const counter1 = actor(,
  actions: 
});

// Using createState function
const counter2 = actor(;
  },
  actions: 
});

// Using onCreate
const counter3 = actor(,
  
  // Run initialization logic (logging, external service setup, etc.)
  onCreate: (c, opts, input: ) => ,
  
  actions: 
});
```

### `onStart`

This hook is called any time the actor is started (e.g. after restarting, upgrading code, or crashing).

This is called after the actor has been initialized but before any connections are accepted.

Use this hook to set up any resources or start any background tasks, such as `setInterval`.

```typescript
const counter = actor(,
  vars: ,
  
  onStart: (c) => , 10000);
    
    // Store interval ID in vars to clean up later if needed
    c.vars.intervalId = intervalId;
  },
  
  actions: 
    }
  }
});
```

### `onStateChange`

Called whenever the actor's state changes. This is often used to broadcast state updates.

```typescript
const counter = actor(,
  
  onStateChange: (c, newState) => );
  },
  
  actions: 
  }
});
```

### `createConnState` and `connState`

There are two ways to define the initial state for connections:
1. `connState`: Define a constant object that will be used as the initial state for all connections
2. `createConnState`: A function that dynamically creates initial connection state based on connection parameters

### `onBeforeConnect`

The `onBeforeConnect` hook is called whenever a new client connects to the actor. Clients can pass parameters when connecting, accessible via `params`. This hook is used for connection validation and can throw errors to reject connections.

The `onBeforeConnect` hook does NOT return connection state - it's used solely for validation.

```typescript
const chatRoom = actor(,
  
  // Method 1: Use a static default connection state
  connState: ,
  
  // Method 2: Dynamically create connection state
  createConnState: (c, opts, params: ) => ;
  },
  
  // Validate connections before accepting them
  onBeforeConnect: (c, opts, params: ) => 
    
    // Authentication is valid, connection will proceed
    // The actual connection state will come from connState or createConnState
  },
  
  actions: 
});
```

Connections cannot interact with the actor until this method completes successfully. Throwing an error will abort the connection. This can be used for authentication - see [Authentication](/docs/actors/authentication) for details.

### `onConnect`

Executed after the client has successfully connected.

```typescript
const chatRoom = actor(, messages: [] },
  
  onConnect: (c) => ;
    
    // Broadcast that a user joined
    c.broadcast("userJoined", );
    
    console.log(`User $ connected`);
  },
  
  actions: 
});
```

Messages will not be processed for this actor until this hook succeeds. Errors thrown from this hook will cause the client to disconnect.

### `onDisconnect`

Called when a client disconnects from the actor. Use this to clean up any connection-specific resources.

```typescript
const chatRoom = actor(, messages: [] },
  
  onDisconnect: (c) => 
    
    // Broadcast that a user left
    c.broadcast("userLeft", );
    
    console.log(`User $ disconnected`);
  },
  
  actions: 
});
```

### `onFetch`

The `onFetch` hook handles HTTP requests sent to your actor. It receives the actor context and a standard `Request` object, and should return a `Response` object or `void` to continue default routing.

```typescript
const apiActor = actor(,
  
  onFetch: (c, request) => ), 
      });
    }
    
    // Return void to continue to default routing
    return;
  },
  
  actions: 
});
```

### `onWebSocket`

The `onWebSocket` hook handles WebSocket connections to your actor. It receives the actor context, a `WebSocket` object, and the initial `Request`. Use this to set up WebSocket event listeners and handle real-time communication.

```typescript
const realtimeActor = actor(,
  
  onWebSocket: (c, websocket, request) => ));
    
    // Handle incoming messages
    websocket.addEventListener("message", (event) => ));
      }
    });
    
    // Handle connection close
    websocket.addEventListener("close", () => );
  },
  
  actions: 
});
```

### `onAuth`

The `onAuth` hook is called on the HTTP server before clients can interact with the actor. This hook is required for any public HTTP endpoint access and is used to validate client credentials and return authentication data that will be available on connections.

This hook runs on the HTTP server (not the actor) to reduce load and prevent denial of service attacks against individual actors. Only called for public endpoints - calls to actors from within the backend do not trigger this handler.

```typescript
const secureActor = actor() => 
    
    const token = authHeader.slice(7);
    
    // Validate token with your auth service
    const user = await validateAuthToken(token);
    if (!user) 
    
    // Return auth data (must be serializable)
    return ;
  },
  
  state:  },
  
  onConnect: (c) =>  with role $ connected`);
    
    c.state.activeUsers[userId] = ;
  },
  
  actions: 
      
      return ;
    }
  }
});
```

### `onBeforeActionResponse`

The `onBeforeActionResponse` hook is called before sending an action response to the client. Use this hook to modify or transform the output of an action before it's sent to the client. This is useful for formatting responses, adding metadata, or applying transformations to the output.

```typescript
const loggingActor = actor(,
  
  onBeforeActionResponse: (c, actionName, args, output) =>  called with args:`, args);
    console.log(`Action $ returned:`, output);
    
    // Add metadata to all responses
    return 
    };
  },
  
  actions: ,
        lastActive: Date.now()
      };
    },
    
    getStats: (c) => ;
    }
  }
});
```

## Destroying Actors

_Destroying actors is not available yet._

## Advanced

### Running Background Tasks

The `c.runInBackground` method allows you to execute promises asynchronously without blocking the actor's main execution flow. The actor is prevented from sleeping while the promise passed to `runInBackground` is still active. This is useful for fire-and-forget operations where you don't need to wait for completion.

Common use cases:
- **Analytics and logging**: Send events to external services without delaying responses
- **State sync**: Populate external databases or APIs with updates to actor state in the background

```typescript
const gameRoom = actor(, scores:  },
  
  actions: ;
      
      // Send analytics event without blocking
      c.runInBackground(
        fetch('https://analytics.example.com/events', )
        }).then(() => console.log('Analytics sent'))
      );
      
      return ;
    },
  }
});
```

### Using `ActorContext` Type Externally

When extracting logic from lifecycle hooks or actions into external functions, you'll often need to define the type of the context parameter. Rivet provides helper types that make it easy to extract and pass these context types to external functions.

```typescript
const myActor = actor(,
  
  // Use external function in lifecycle hook
  onStart: (c) => logActorStarted(c)
});

// Simple external function with typed context
function logActorStarted(c: ActorContextOf) `);
}
```

See [Helper Types](/docs/actors/helper-types) for more details on using `ActorContextOf`.

## Full Example

```typescript
interface CounterInput 

const counter = actor(
    
    const token = authHeader.slice(7);
    const user = await validateAuthToken(token);
    if (!user) 
    
    return ;
  },
  
  // Initialize state with input
  createState: (c: ActorInitContext, input: CounterInput) => (),
  
  // Initialize actor (run setup that doesn't affect initial state)
  onCreate: (c, opts, input: ) => " initialized`);
    // Set up external resources, logging, etc.
  },
  
  // Define default connection state
  connState: ,
  
  createConnState: (c, opts) => ;
  },
  
  // Lifecycle hooks
  onStart: (c) => " started with count:`, c.state.count);
  },
  
  onStateChange: (c, newState) => );
  },
  
  onBeforeConnect: (c, ) =>  attempting to connect`);
  },
  
  onConnect: (c) =>  connected to "$"`);
  },
  
  onDisconnect: (c) =>  disconnected from "$"`);
  },
  
  // Transform all action responses
  onBeforeActionResponse: (c, actionName, args, output) => 
    };
  },
  
  // Define actions
  actions: ,
    
    reset: (c) => 
      
      c.state.count = 0;
      return c.state.count;
    },
    
    getInfo: (c) => (),
  }
});

default counter;
```
## Metadata

# Metadata

Metadata provides information about the currently running actor.

## Actor ID

Get the unique instance ID of the actor:

```typescript
const actorId = c.actorId;
```

## Actor Name

Get the actor type name:

```typescript
const actorName = c.name;
```

This is useful when you need to know which actor type is running, especially if you have generic utility functions that are shared between different actor implementations.

## Actor Key

Get the actor key used to identify this actor instance:

```typescript
const actorKey = c.key;
```

The key is used to route requests to the correct actor instance and can include parameters passed when creating the actor.

Learn more about using keys for actor addressing and configuration in the [keys documentation](/docs/actors/keys).

## Region

Region can be accessed from the context object via `c.region`.

```typescript
const region = c.region;
```

`c.region` is only supported on Rivet at the moment.

## Example Usage

```typescript }
const chatRoom = actor(,
  
  actions: ;
    }
  }
});

const registry = setup(
});
```

```typescript }
const client = createClient("http://localhost:8080");

// Connect to a chat room
const chatRoom = await client.chatRoom.get("general");

// Get actor metadata
const metadata = await chatRoom.getMetadata();
console.log("Actor metadata:", metadata);
```
## Node.js & Bun Quickstart

# Node.js & Bun Quickstart

Get started with Rivet Actors in Node.js and Bun

```sh
npm install @rivetkit/actor
```

Create a simple counter actor:

```ts }
const counter = actor(,
	actions: ,
		getCount: (c) => c.state.count,
	},
});

const registry = setup(,
});
```

Choose your preferred web framework:

```ts }
// Start Rivet with file system driver (for development)
const  = registry.createServer();

// Setup Hono app
const app = new Hono();

// Example API endpoint
app.post("/increment/:name", async (c) => );
});

// Start server with Rivet
serve(app);
```

```ts }
// Start Rivet
const  = registry.createServer();

// Setup Express app
const app = express();
app.use(express.json());

// Mount Rivet handler
app.use("/registry", handler);

// Example API endpoints
app.post("/increment/:name", async (req, res) =>  = req.params;

      const counter = client.counter.getOrCreate(name);
      const newCount = await counter.increment(1);
      
      res.json();
});

app.listen(8080, () => );
```

```ts }
// Start Rivet
const  = registry.createServer();

// Setup Elysia app
const app = new Elysia()
	.mount("/registry", handler)
	.post("/increment/:name", async () =>  = params;

		const counter = client.counter.getOrCreate(name);
		const newCount = await counter.increment(1);

		return ;
	})
	.listen(8080);

console.log("Server running at http://localhost:8080");
```

The `/registry` endpoint is automatically mounted by Rivet and is required for client communication. When using `serve()` with Hono, this is handled automatically.

```sh }
npx tsx --watch server.ts
```

```sh }
bun --watch server.ts
```

Your server is now running at `http://localhost:8080`

Test your counter actor using HTTP requests:

```ts }
// Increment counter
const response = await fetch("http://localhost:8080/increment/my-counter", );

const result = await response.json();
console.log("Count:", result.count); // 1
```

```sh curl
# Increment counter
curl -X POST http://localhost:8080/increment/my-counter
```

## Configuration Options

### Connect Frontend To The Rivet Actor

Create a type-safe client to connect from your frontend:

```ts }
// Create typed client
const client = createClient("http://localhost:8080");

// Use the counter actor directly
const counter = client.counter.getOrCreate(["my-counter"]);

// Call actions
const count = await counter.increment(3);
console.log("New count:", count);

// Get current state
const currentCount = await counter.getCount();
console.log("Current count:", currentCount);

// Listen to real-time events
const connection = counter.connect();
connection.on("countChanged", (newCount) => );

// Increment through connection
await connection.increment(1);
```

See the [JavaScript client documentation](/clients/javascript) for more information.

```tsx }
const client = createClient("http://localhost:8080");
const  = createRivetKit(client);

function Counter() );

	counter.useEvent("countChanged", (newCount: number) => );

	const increment = async () => ;

	return (
		
			Count: 
			Increment
		
	);
}
```

See the [React documentation](/clients/react) for more information.

```rust }
use rivetkit_client::;
use serde_json::json;

#[tokio::main]
async fn main() -> Result> ", count);
    }).await;
    
    // Call increment action
    let result = counter.action("increment", vec![json!(1)]).await?;
    println!("New count: ", result);
    
    Ok(())
}
```

See the [Rust client documentation](/clients/rust) for more information.
## Quickstart

# Quickstart

  Set up actors with Node.js, Bun, and web frameworks

  Build real-time React applications with actors
## Next.js Quickstart

# Next.js Quickstart

Get started with Rivet Actors in Next.js

```sh
npx create-next-app@latest my-app
cd my-app
```

Create a simple counter actor:

```ts }
const counter = actor(,
	actions: ,
		getCount: (c) => c.state.count,
	},
});

const registry = setup(,
});
```

Create a RivetKit client to connect to your actor:

```ts }
"use client";
const client = createClient(`$api`, );

const  = createRivetKit(client);

```

It's important to use SSE (Server-Sent Events) for real-time updates in Next.js.

```ts }
const server = registry.createServer(,
});

// Export the Next.js handler for the API routes
const  = toNextHandler(server);
```

```tsx }
"use client";
function Counter() );
	const [count, setCount] = useState(0);

	counter.on("countChanged", (newCount) => );

	const increment = () => ;

	return (
		
			Count: 
			Increment
		
	);
}
```

Make sure to import the `Counter` component in your page or layout.

For more examples how to connect to your actors using React, check the [RivetKit React documentation](http://rivet.gg/docs/clients/react/).
## React Quickstart

# React Quickstart

Build real-time React applications with Rivet Actors

```sh
npm install @rivetkit/actor @rivetkit/react
```

Create your actor registry on the backend:

```ts }
const counter = actor(,  // Skip authentication (can be configured later)
	state: ,
	actions: ,
		getCount: (c) => c.state.count,
	},
});

const registry = setup(,
});
```

Start a server to run your actors:

```ts }
// Run server with default configuration (port 8080)
registry.runServer();
```

Set up your React application:

```tsx }
// Create typed client
const client = createClient("http://localhost:8080");
const  = createRivetKit(client);

function App() );

	// Listen for real-time count updates
	counter.useEvent("countChanged", (newCount: number) => );

	const increment = async () => ;

	const incrementBy = async (amount: number) => ;

	return (
		
			Rivet Counter
			Count: 

					Counter Name:
					 setCounterName(e.target.value)}
						style=}
					/>

					+1
				
				 incrementBy(5)}>
					+5
				
				 incrementBy(10)}>
					+10

				Connection Status: 
				Try opening multiple tabs to see real-time sync.

	);
}

default App;
```

Configure Vite for development:

```ts }
default defineConfig(,
})
```

Start both the backend and frontend:

**Terminal 1**: Start the backend

```sh Backend
npx tsx --watch backend/server.ts
```

**Terminal 2**: Start the frontend

```sh Frontend  
npx vite
```

Open `http://localhost:5173` in your browser. Try opening multiple tabs to see real-time sync in action.

## Configuration Options

### Add Your Own Backend Endpoints

Add custom HTTP endpoints alongside your actors to handle additional business logic, authentication, and integrations with external services.

See [backend quickstart](/docs/actors/quickstart/backend) for more information.
## Scaling & Concurrency

# Scaling & Concurrency

This document covers how actors are able to scale better than traditional applications & provides tips on architecting your actors.

## How actors scale

Actors scale by design through these key properties:

| Property                             | Description                                                                                                                                                                                                                                                                                     |
| ------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Independent State**                | Each actor manages its own private data separately from other actors, so they never conflict with each other when running at the same time (i.e. using locking mechanisms).                                                                                                                     |
| **Action- & Event-Based Communication** | Actors communicate through asynchronous [actions](/docs/actors/actions) or [events](/docs/actors/events), making it easy to distribute them across different machines.                                                                                                                                               |
| **Location Transparency**            | Unlike traditional servers, actors don't need to know which machine other actors are running on in order to communicate with each other. They can run on the same machine, across a network, and across the world. Actors handle the network routing for you under the hood.                    |
| **Horizontal Scaling**               | Actors distribute workload by splitting responsibilities into small, focused units. Since each actor handles a limited scope (like a single user, document, or chat room), the system automatically spreads load across many independent actors rather than concentrating it in a single place. |

## Tips for architecting actors for scale

Here are key principles for architecting your actor system:

**Single Responsibility**

- Each actor should represent one specific entity or concept from your application (e.g., `User`, `Document`, `ChatRoom`).
- This makes your system scale better, since actors have small scopes and do not conflict with each other.

**State Management**

- Each actor owns and manages only its own state
- Use [actions](/docs/actors/actions) to request data from other actors
- Keep state minimal and relevant to the actor's core responsibility

**Granularity Guidelines**

- Too coarse: Actors handling too many responsibilities become bottlenecks
- Too fine: Excessive actors create unnecessary communication overhead
- Aim for actors that can operate independently with minimal cross-actor communication

### Examples

**Good actor boundaries**

- `User`: Manages user profile, preferences, and authentication
- `Document`: Handles document content, metadata, and versioning
- `ChatRoom`: Manages participants and message history

**Poor actor boundaries**

- `Application`: Too broad, handles everything
- `DocumentWordCount`: Too granular, should be part of DocumentActor
## Schedule

# Schedule

Scheduling is used to trigger events in the future. The actor scheduler is like `setTimeout`, except the timeout will persist even if the actor restarts, upgrades, or crashes.

	Scheduling is supported on the Rivet Cloud, Cloudflare Workers, file system, and memory drivers.

	Follow [this issue](https://github.com/rivet-gg/rivetkit/issues/1095) for Redis support.

## Use Cases

Scheduling is helpful for long-running timeouts like month-long billing periods or account trials.

## Scheduling

### `c.schedule.after(duration, actionName, ...args)`

Schedules a function to be executed after a specified duration. This function persists across actor restarts, upgrades, or crashes.

Parameters:

- `duration` (number): The delay in milliseconds.
- `actionName` (string): The name of the action to be executed.
- `...args` (unknown[]): Additional arguments to pass to the function.

### `c.schedule.at(timestamp, actionName, ...args)`

Schedules a function to be executed at a specific timestamp. This function persists across actor restarts, upgrades, or crashes.

Parameters:

- `timestamp` (number): The exact time in milliseconds since the Unix epoch when the function should be executed.
- `actionName` (string): The name of the action to be executed.
- `...args` (unknown[]): Additional arguments to pass to the function.

## Full Example

```typescript
const reminderService = actor(
  },
  
  actions: ;
      
      // Schedule the sendReminder action to run after the delay
      c.schedule.after(delayMs, "sendReminder", reminderId);
      
      return ;
    },
    
    sendReminder: (c, reminderId) => );
        });
      } else 
      
      // Clean up the processed reminder
      delete c.state.reminders[reminderId];
    }
  }
});
```
## Sharing and Joining State

# Sharing and Joining State

Actors store data separately by design, so combining data from multiple actors works differently than traditional databases. This pattern is similar to patterns you'll see in distributed like Cassandra, DynamoDB, and ClickHouse.

Here are your options based on your needs:

## Few actors, need latest data

- Call actions on each actor to get their data
- Actions are fast, so this works well for small numbers of actors
- Trade-off: More work when reading data, but writing is simple

## Many actors, need latest data

- Have actors automatically send updates to other actors that need them
- This keeps everyone in sync without extra calls
- Trade-off: More work when data changes, but reading is fast

## Many actors, okay with slightly old data

- Write data to a separate OLAP database like ClickHouse when updating state
- Query the analytics database for fast joins
- Trade-off: Extra database to maintain, but great performance

## Many actors, need latest data (not recommended)

- Write data to a transactional OLTP database like Postgres or MySQL when updating state
- This works but adds complexity you usually don't need
- Trade-off: Heavy database overhead for minimal benefit
## State

# State

Actor state provides the best of both worlds: it's stored in-memory and persisted automatically. This lets you work with the data without added latency while still being able to survive crashes & upgrades.

Actors can also be used with external SQL databases. This can be useful to integrate actors with existing
applications or for storing relational data. Read more [here](/docs/actors/external-sql).

## Initializing State

There are two ways to define an actor's initial state:

Define an actor state as a constant value:

```typescript
// Simple state with a constant
const counter = actor(,
  
  actions: 
});
```

This value will be cloned for every new actor using `structuredClone`.

Create actor state dynamically on each actors' creation:

```typescript
// State with initialization logic
const counter = actor(;
  },
  
  actions: 
});
```

To accept a custom input parameters for the initial state, use:

```typescript
interface CounterInput 

// State with initialization logic
const counter = actor(;
  },
  
  actions: 
});
```

Read more about [input parameters](/docs/actors/input) here.

If accepting arguments to `createState`, you **must** define the types: `createSTate(c: ActorInitContext, input: MyType)`

Otherwise, the return type will not be inferred and `c.vars` will be of type `unknown`.

The `createState` function is called once when the actor is first created. See [Lifecycle](/docs/actors/lifecycle) for more details.

## Modifying State

To update state, modify the `state` property on the context object (`c.state`) in your actions:

```typescript
const counter = actor(,
  
  actions: ,
    
    add: (c, value) => 
  }
});
```

Only state stored in the `state` object will be persisted. Any other variables or properties outside of this are not persisted.

## State Saves

Actors automatically handle persisting state transparently. This happens at the end of every action if the state has changed. State is also automatically saved after `onFetch` and `onWebSocket` handlers finish executing.

For `onWebSocket` handlers specifically, you'll need to manually save state using `c.saveState()` while the WebSocket connection is open if you want state changes to be persisted immediately. This is because WebSocket connections can remain open for extended periods, and state changes made during event handlers (like `message` events) won't be automatically saved until the connection closes.

In other cases where you need to force a state change mid-action, you can use `c.saveState()`. This should only be used if your action makes an important state change that needs to be persisted before the action completes.

```typescript
const criticalProcess = actor(,
  
  actions: `);
      
      // Force save state before the async operation
      c.saveState();
      
      // Long-running operation that might fail
      await someRiskyOperation();
      
      // Update state again
      c.state.steps.push(`Completed step $`);
      
      return c.state.currentStep;
    }
  }
});
```

## State Isolation

Each actor's state is completely isolated, meaning it cannot be accessed directly by other actors or clients.

To interact with an actor's state, you must use [Actions](/docs/actors/actions). Actions provide a controlled way to read from and write to the state.

If you need a shared state between multiple actors, see [sharing and joining state](/docs/actors/sharing-and-joining-state).

## Ephemeral Variables

In addition to persisted state, actors can store ephemeral data that is not saved to permanent storage using `vars`. This is useful for temporary data or non-serializable objects like database connections or event emitters.

For complete documentation on ephemeral variables, see [Ephemeral Variables](/docs/actors/ephemeral-variables).

## Type Limitations

State is currently constrained to the following types:

- `null`
- `undefined`
- `boolean`
- `string`
- `number`
- `BigInt`
- `Date`
- `RegExp`
- `Error`
- Typed arrays (`Uint8Array`, `Int8Array`, `Float32Array`, etc.)
- `Map`
- `Set`
- `Array`
- Plain objects
## Testing

# Testing

Rivet provides a straightforward testing framework to build reliable and maintainable applications. This guide covers how to write effective tests for your actor-based services.

## Setup

To set up testing with Rivet:

```bash
# Install Vitest
npm install -D vitest

# Run tests
npm test
```

## Basic Testing Setup

Rivet includes a test helper called `setupTest` that configures a test environment with in-memory drivers for your actors. This allows for fast, isolated tests without external dependencies.

```ts tests/my-actor.test.ts
test("my actor test", async (test) =>  = await setupTest(test, app);
  
  // Now you can interact with your actor through the client
  const myActor = await client.myActor.get();
  
  // Test your actor's functionality
  await myActor.someAction();
  
  // Make assertions
  const result = await myActor.getState();
  expect(result).toEqual("updated");
});
```

```ts src/index.ts
const myActor = actor(,
  actions: ,
    getState: (c) => 
  }
});

const registry = setup(
});
```

## Testing Actor State

The test framework uses in-memory drivers that persist state within each test, allowing you to verify that your actor correctly maintains state between operations.

```ts tests/counter.test.ts
test("actor should persist state", async (test) =>  = await setupTest(test, app);
  const counter = await client.counter.get();
  
  // Initial state
  expect(await counter.getCount()).toBe(0);
  
  // Modify state
  await counter.increment();
  
  // Verify state was updated
  expect(await counter.getCount()).toBe(1);
});
```

```ts src/index.ts
const counter = actor(,
  actions: ,
    getCount: (c) => 
  }
});

const registry = setup(
});
```

## Testing Events

For actors that emit events, you can verify events are correctly triggered by subscribing to them:

```ts tests/chat-room.test.ts
test("actor should emit events", async (test) =>  = await setupTest(test, app);
  const chatRoom = await client.chatRoom.get();
  
  // Set up event handler with a mock function
  const mockHandler = vi.fn();
  chatRoom.on("newMessage", mockHandler);
  
  // Trigger the event
  await chatRoom.sendMessage("testUser", "Hello world");
  
  // Wait for the event to be emitted
  await vi.waitFor(() => );
});
```

```ts src/index.ts
const chatRoom = actor(,
  actions: );
      c.broadcast("newMessage", username, message);
    },
    getHistory: (c) => ,
  },
});

// Create and the app
const registry = setup(
});
```

## Testing Schedules

Rivet's schedule functionality can be tested using Vitest's time manipulation utilities:

```ts tests/scheduler.test.ts
test("scheduled tasks should execute", async (test) =>  = await setupTest(test, app);
  const scheduler = await client.scheduler.get();
  
  // Set up a scheduled task
  await scheduler.scheduleTask("reminder", 60000); // 1 minute in the future
  
  // Fast-forward time by 1 minute
  await vi.advanceTimersByTimeAsync(60000);
  
  // Verify the scheduled task executed
  expect(await scheduler.getCompletedTasks()).toContain("reminder");
});
```

```ts src/index.ts
const scheduler = actor(,
  actions: ;
    },
    completeTask: (c, taskName: string) => ;
    },
    getCompletedTasks: (c) => 
  }
});

const registry = setup(
});
```

The `setupTest` function automatically calls `vi.useFakeTimers()`, allowing you to control time in your tests with functions like `vi.advanceTimersByTimeAsync()`. This makes it possible to test scheduled operations without waiting for real time to pass.

## Best Practices

1. **Isolate tests**: Each test should run independently, avoiding shared state.
2. **Test edge cases**: Verify how your actor handles invalid inputs, concurrent operations, and error conditions.
3. **Mock time**: Use Vitest's timer mocks for testing scheduled operations.
4. **Use realistic data**: Test with data that resembles production scenarios.

Rivet's testing framework automatically handles server setup and teardown, so you can focus on writing effective tests for your business logic.
## Node.js & Bun

# Node.js & Bun

The Rivet JavaScript client allows you to connect to and interact with actors from browser and Node.js applications.

## Basic Usage

Install the RivetKit package:

  Make sure you have a running Rivet actor server to connect to. You can follow the [Node.js & Bun Quickstart](https://rivet.gg/docs/actors/quickstart/backend/) to set up a simple actor server.

Create client and connect to actors and listen for real-time updates:

```tsx }
async function main() 

	await new Promise((resolve) => setTimeout(resolve, 10000));
	await counter.dispose();
}

main();

```

## API Reference

Follows the same [API as the Node.js client](http://rivet.gg/docs/actors/clients/#actor-client), allowing you to use the same methods and properties for interacting with actors.
## Next.js

# Next.js

The Rivet Next.js client allows you to connect to and interact with actors in Next.js applications.

	Check out the complete example

	Use Next.js API routes to run RivetKit Registry

## Basic Usage

Install the RivetKit React package:

  Follow the [Next.js backend integration guide](https://rivet.gg/docs/integrations/next-js/) to set up your Next.js backend with Rivet.

Create a RivetKit client to connect to your actor:

```ts }
"use client";
const client = createClient(`$api`, );

const  = createRivetKit(client);

```

It's important to use SSE (Server-Sent Events) for real-time updates in Next.js.

Connect to actors and listen for real-time updates:
```tsx }
"use client";
function Counter() );
	const [count, setCount] = useState(0);

	counter.on("countChanged", (newCount) => );

	const increment = () => ;

	return (
		
			Count: 
			Increment
		
	);
}
```

Make sure to import the `Counter` component in your page or layout.

## API Reference

It's the same as the [React client API reference](https://rivet.gg/docs/clients/react#api-reference), since the RivetKit React package is used in both Next.js and React applications.
## OpenAPI

# OpenAPI

The Rivet OpenAPI spec is available [here](https://github.com/rivet-gg/rivetkit/blob/main/clients/openapi/openapi.json)
## React

# React

Learn how to create real-time, stateful React applications with Rivet's actor model. The React integration provides intuitive hooks for managing actor connections and real-time updates.

## Basic Usage

Install the RivetKit React package:

  Make sure you have a running Rivet actor server to connect to. You can follow the [Node.js & Bun Quickstart](https://rivet.gg/docs/actors/quickstart/backend/) to set up a simple actor server.

Connect to actors and listen for real-time updates:

```tsx }
function App() );

  // Listen for real-time count updates
  counter.useEvent("countChanged", (newCount: number) => );

  const increment = async () => ;

  return (
    
      Rivet Counter
      Count: 

          Counter Name:
           setCounterName(e.target.value)}
            style=}
          />

        Increment

        Status: 

  );
}

default App;
```

## API Reference

### `createRivetKit(client, options?)`

Creates the Rivet hooks for React integration.

```tsx
const client = createClient("http://localhost:8080");
const  = createRivetKit(client);
```

#### Parameters

- `client`: The Rivet client created with `createClient`
- `options`: Optional configuration object

#### Returns

An object containing:
- `useActor`: Hook for connecting to actors

### `useActor(options)`

Hook that connects to an actor and manages the connection lifecycle.

```tsx
const actor = useActor(,
  enabled: true
});
```

#### Parameters

- `options`: Object containing:
  - `name`: The name of the actor type (string)
  - `key`: Array of strings identifying the specific actor instance
  - `params`: Optional parameters passed to the actor connection
  - `createWithInput`: Optional input to pass to the actor on creation
  - `createInRegion`: Optional region to create the actor in if does not exist
  - `enabled`: Optional boolean to conditionally enable/disable the connection (default: true)
  - `enabled`: Optional boolean to conditionally enable/disable the connection (default: true)

#### Returns

Actor object with the following properties:
- `connection`: The actor connection for calling actions, or `null` if not connected
- `isConnected`: Boolean indicating if the actor is connected
- `state`: Current actor state (if available)
- `useEvent(eventName, handler)`: Method to subscribe to actor events

### `actor.useEvent(eventName, handler)`

Subscribe to events emitted by the actor.

```tsx
const actor = useActor();

actor.useEvent("countChanged", (newCount: number) => );
```

#### Parameters

- `eventName`: The name of the event to listen for (string)
- `handler`: Function called when the event is emitted

#### Lifecycle

The event subscription is automatically managed:
- Subscribes when the actor connects
- Cleans up when the component unmounts or actor disconnects
- Re-subscribes on reconnection

## Advanced Patterns

### Multiple Actors

Connect to multiple actors in a single component:

```tsx
function Dashboard() );
  
  const notifications = useActor();

  userProfile.useEvent("profileUpdated", (profile) => );

  notifications.useEvent("newNotification", (notification) => );

  return (

  );
}
```

### Conditional Connections

Control when actors connect using the `enabled` option:

```tsx
function ConditionalActor() );

  return (
    
       setEnabled(!enabled)}>

      )}
    
  );
}
```

### Real-time Collaboration

Build collaborative features with multiple event listeners:

```tsx
function CollaborativeEditor() );
  
  const document = useActor(
  });

  // Listen for content changes
  document.useEvent("contentChanged", (newContent) => );

  // Listen for cursor movements
  document.useEvent("cursorMoved", () => ));
  });

  // Listen for user join/leave
  document.useEvent("userJoined", () =>  joined the document`);
  });

  document.useEvent("userLeft", () =>  = prev;
      return rest;
    });
  });

  const updateContent = async (newContent: string) => ;

  return (

  );
}
```

### Authentication

Connect authenticated actors in React:

```tsx
function AuthenticatedApp() ,
		enabled: !!authToken // Only connect when authenticated
	});

	const login = async () => ;

	if (!authToken) 

	return (
		
			Authenticated Counter

	);
}
```

Learn more about [authentication](/docs/actors/authentication).
## Rust

# Rust

The Rivet Rust client provides a way to connect to and interact with actors from Rust applications.

## Quickstart

    Add RivetKit client to your `Cargo.toml`:
    
    ```toml
    [dependencies]
    rivetkit-client = "0.1.0"
    ```

      Make sure you have a running Rivet actor server to connect to. You can follow the [Node.js & Bun Quickstart](https://rivet.gg/docs/actors/quickstart/backend/) to set up a simple actor server.

    ```rust src/main.rs
    use rivetkit_client::;
    use serde_json::json;

    #[tokio::main]
    async fn main() -> anyhow::Result : ", username, message);
        }).await;

        // Send message to room
        chat_room.action("sendMessage", vec![
            json!("william"),
            json!("All the world's a stage.")
        ]).await?;

        // When finished
        client.disconnect();

        Ok(())
    }
    ```

    In a separate terminal, run your client code:
    
    ```sh
    cargo run
    ```

    Run it again to see the state update.

## API Reference

_Coming Soon_

For detailed API documentation, please refer to the [RivetKit Rust client implementation](https://github.com/rivet-gg/rivetkit/blob/main/clients/rust).
## Build Your Own

# Build Your Own

Each driver implements common interfaces defined by RivetKit, including:

- **ActorDriver**: Manages actor state, lifecycle, and persistence
- **ManagerDriver**: Handles actor discovery, routing, and scaling

## Source Code Locations

Get started by looking at source code for the driver interfaces and existing drivers:

- **Driver Interfaces**
  - **ActorDriver*** [Source Code](https://github.com/rivet-gg/rivetkit/blob/main/packages/core/src/actor/driver.ts)
  - **ManagerDriver*** [Source Code](https://github.com/rivet-gg/rivetkit/blob/main/packages/core/src/manager/driver.ts)
- **Driver Implementations**: [Source Code](https://github.com/rivet-gg/rivetkit/tree/main/packages/core/src/drivers)
## File System

# File System

The File System driver is the default driver for Rivet Actors, providing local file-based storage for state management and inter-actor communication. If no driver is specified in your configuration, the File System driver will be used automatically.

The File System driver is ideal for development and single-node deployments. For production applications that need to scale horizontally across multiple machines, use the [Redis driver](/docs/drivers/redis).

## Feature Support

| Feature | Supported |
| --- | --- |
| Horizontal scaling | No |
| WebSockets | Yes |
| SSE | Yes |
| Edge | No |
| Scheduling | Yes |

## Setup

The File System driver is included with `@rivetkit/actor` - no additional packages needed:

```bash
npm install @rivetkit/actor
```

Use the default configuration with automatic path based on your current working directory:

```typescript }
const driver = createFileSystemDriver();
const  = registry.runServer();

// ...rest of your server...
```

The default path is stored in your system's data path. The path is unique to the current working directory, so you can safely run multiple projects on the same machine.

Specify a custom path for actor storage:

```typescript }
const driver = createFileSystemDriver();
const  = registry.runServer();

// ...rest of your server...
```

**Configuration Options:**

- `path` - Custom directory path for storing actor data (optional)

## Data Management

The path where your actors are stored is printed when you start your project. To reset your actors, delete the folder that is printed.

If running on a single node, make sure to back up your actors folder regularly. `rsync` works nicely with this because each actor is stored as its own file.

## Examples

Basic File System driver setup and configuration example.
## Memory

# Memory

The Memory driver stores all actor state and communication in memory, making it ideal for testing, development, and prototyping scenarios where persistence is not required.

The Memory driver does not persist data between server restarts. For production applications that need to scale horizontally across multiple machines, use the [Redis driver](/docs/drivers/redis).

## Feature Support

| Feature | Supported |
| --- | --- |
| Horizontal scaling | No |
| WebSockets | Yes |
| SSE | Yes |
| Edge | No |
| Scheduling | Yes |

## Setup

The Memory driver is included with `@rivetkit/actor` - no additional packages needed:

```bash
npm install @rivetkit/actor
```

Create and use the Memory driver:

```typescript }
const driver = createMemoryDriver();
const  = registry.runServer();

// ...rest of your server...
```

The Memory driver requires no configuration options.
## Redis

# Redis

The Redis driver enables deploying scalable Rivet Actors using Redis as the backend for state management and inter-actor communication.

The Redis driver is currently in preview. We do not recommend shipping production applications with the Redis driver yet.

If you want to take Redis to production, [contact us](/support) so we can help validate your setup is production ready and help resolve issues promptly.

## Feature Support

| Feature | Supported |
| --- | --- |
| Horizontal scaling | Yes |
| WebSockets | Yes |
| SSE | Yes |
| Edge | No |
| Scheduling | [Not yet](https://github.com/rivet-gg/rivetkit/issues/1095) |

## Setup

Install the required packages:

```bash
npm install @rivetkit/redis ioredis@5
```

Configure your application using environment variables:

```bash
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=your-password
REDIS_KEY_PREFIX=myproject
```

**Available Environment Variables:**

- `REDIS_HOST` - Redis server hostname (default: `localhost`)
- `REDIS_PORT` - Redis server port (default: `6379`)
- `REDIS_PASSWORD` - Redis password (optional)
- `REDIS_KEY_PREFIX` - Key prefix for isolation when running multiple projects (optional)

Then start your server:

```typescript }
const driver = createRedisDriver();
const  = registry.runServer();

// ...rest of your server...
```

For advanced configuration, pass your own Redis instance:

```typescript }
const redis = new Redis();

const driver = createRedisDriver();
const  = registry.runServer();

// ...rest of your server...
```

**Configuration Options:**

When passing a custom Redis instance, you have full control over the connection options. Common options include:

- `host` - Redis server hostname
- `port` - Redis server port
- `password` - Redis password

See the [ioredis documentation](https://github.com/luin/ioredis) for all available options.

To prevent data loss, ensure AOF (Append Only File) persistence is enabled on your Redis server. See the [Redis Persistence Documentation](https://redis.io/docs/latest/operate/oss_and_stack/management/persistence/#append-only-file) for setup instructions.

## Deploy

Deploy your Redis-powered actors on these hosting providers:

Deploy on Railway with automatic scaling and managed infrastructure.

## Examples

Example using Redis driver with Hono web framework.

Basic Redis driver setup and configuration example.

## Advanced

### Driver Context

The Redis driver provides access to the underlying Redis connection through the driver context in `createVars`.

```typescript
const myActor = actor(,
  
  // Save the Redis driver context
  createVars: (ctx: ActorInitContext, driver: DriverContext) => (),
  
  actions: ,
  }
});
```

The Redis driver context type is exported as `DriverContext` from `@rivetkit/redis`:

```typescript
interface DriverContext 
```

While you have access to the Redis client, be cautious when directly modifying keys under the `keyPrefix`, as this may interfere with RivetKit's internal operations and potentially break actor functionality.
## Architecture

# Architecture

Rivet supports three topologies that define how actors are distributed and scale.

	Each platform configures a default topology appropriate for that environment. In most cases, you can rely on these defaults unless you have specific distribution needs.

## Configuration

```typescript
const config = ;
```

## Types of Topologies

### Standalone

- **How it works**: Runs all actors in a single process
- **When to use**: Development, testing, simple apps with low traffic
- **Limitations**: No horizontal scaling, single point of failure
- **Default on**: Node.js, Bun

### Partition

- **How it works**: Each actor has its own isolated process. Clients connect directly to the actor for optimal performance.
- **When to use**: Production environments needing horizontal scaling
- **Limitations**: Minimal - balanced performance and availability for most use cases
- **Default on**: Rivet, Cloudflare Workers

### Coordinate

- **How it works**: Creates a peer-to-peer network between multiple servers with leader election with multiple actors running on each server. Clients connect to any server and data is transmitted to the leader over a pubsub server.
- **When to use**: High-availability scenarios needing redundancy and failover
- **Limitations**: Added complexity, performance overhead, requires external data source
- **Default on**: _None_

## Choosing a Topology

In most cases, use your platform's default:

1. **Standalone**: Simple, great for development
2. **Partition**: Best scaling & cost for production
3. **Coordinate**: Good for specialized deployment scenarios
## Cross-Origin Resource Sharing

# Cross-Origin Resource Sharing

Cross-Origin Resource Sharing (CORS) is a security mechanism that allows a web application running at one origin to access resources from a different origin. Without CORS, browsers block cross-origin HTTP requests by default as a security measure.

You'll need to configure CORS when:

- **Local Development**: You're developing locally and your client runs on a different port than your actor service
- **Different Domain**: Your frontend application is hosted on a different domain than your actor service

## Registry-Level CORS

Configure CORS directly in your registry setup for applications that do not require configuring CORS on their own endpoints.

```typescript }
const  = registry.createServer(
});

serve();
```

### Configuration Options

#### `origin`

`string | string[] | (origin: string) => boolean | string`

Specifies which domains can access your resources:

```typescript }
// Single domain
origin: "https://example.com"

// Multiple domains
origin: ["https://app.com", "https://admin.com"]

// Dynamic validation
origin: (origin) => 

// All domains (not recommended for production)
origin: "*"
```

#### `allowMethods`

`string[]`

HTTP methods clients are allowed to use:

```typescript
allowMethods: ["GET", "POST", "OPTIONS"]  // Common for Rivet
```

#### `allowHeaders`

`string[]`

Headers that clients can send in requests:

```typescript
allowHeaders: [
  "Authorization",           // Your auth headers
  "Content-Type",           // Standard content type
  "X-API-Key",              // Custom API key header
  ...ALLOWED_PUBLIC_HEADERS // Required Rivet headers
]
```

#### `credentials`

`boolean`

Whether to allow credentials (cookies, auth headers):

```typescript
credentials: true  // Required for authentication
```

When `credentials: true`, you cannot use `origin: "*"`. Specify exact origins instead.

#### `maxAge`

`number`

How long browsers cache CORS preflight responses (in seconds):

```typescript
maxAge: 600  // Cache for 10 minutes
```

#### `exposeHeaders`

`string[]`

Server headers that browsers can access:

```typescript
exposeHeaders: ["Content-Length", "X-Request-Id"]
```

## Router-Level CORS

For applications that need to expose their own routes, configure CORS at the router level:

```typescript }
const  = registry.createServer();
const app = new Hono();

app.use("*", cors());

serve(app);
```

```typescript }
const  = registry.createServer();
const app = express();

app.use(cors());

app.use("/registry", handler);
app.listen(8080);
```

### Required Headers for Rivet

Rivet requires specific headers for communication. Always include `ALLOWED_PUBLIC_HEADERS`:

```typescript }
const corsConfig = ;
```

These are automatically configured if using `registry.runServer()`.

Without `ALLOWED_PUBLIC_HEADERS`, Rivet clients won't be able to communicate with your actors from the browser.

## Development vs Production

### Development Setup

For local development, allow localhost origins:

```typescript
const isDev = process.env.NODE_ENV !== "production";

const corsConfig = ;
```

### Production Setup

For production, be restrictive with origins:

```typescript
const corsConfig = ;
```

## Troubleshooting

### Common CORS Errors

**"Access to fetch blocked by CORS policy"**
- Add your frontend's origin to the `origin` list
- Ensure `ALLOWED_PUBLIC_HEADERS` are included in `allowHeaders`

**"Request header not allowed"**
- Add the missing header to `allowHeaders` 
- Include `ALLOWED_PUBLIC_HEADERS` in your configuration

**"Credentials mode mismatch"**
- Set `credentials: true` in CORS config
- Cannot use `origin: "*"` with credentials
## Documentation for LLMs & AI

# Documentation for LLMs & AI

Rivet provides optimized documentation formats specifically designed for Large Language Models (LLMs) and AI integration tools.

## Available Formats

### `llms.txt` (Condensed)
A condensed version of the documentation perfect for quick reference and context-aware AI assistance.

**Access:** /llms.txt

This format includes:
- Key concepts and features
- Essential getting started information
- Summaries of main functionality
- Optimized for token efficiency

### `llms-full.txt` (Complete)
The complete documentation in a single file, ideal for comprehensive AI assistance and in-depth analysis.

**Access:** /llms-full.txt

This format includes:
- Complete documentation content
- All examples and detailed explanations
- Full API references and guides
- Suitable for complex queries and comprehensive understanding

## Access Pages As Markdown

Each documentation page is also available as clean markdown by appending `.md` to any documentation URL path.

For example:

- Original URL: `https://rivet.gg/docs/actors`
- Markdown URL: `https://rivet.gg/docs/actors.md`
## Edge Networking

# Edge Networking

Actors automatically run near your users on your provider's global network.

	At the moment, edge networking is only supported on Rivet Cloud & Cloudflare Workers. More self-hosted platforms are on the roadmap.

## Region selection

### Automatic region selection

By default, actors will choose the nearest region based on the client's location.

Under the hood, Rivet and Cloudflare use [Anycast routing](https://en.wikipedia.org/wiki/Anycast) to automatically find the best location for the client to connect to without relying on a slow manual pinging process.

### Manual region selection

The region an actor is created in can be overridden using region options:

```typescript client.ts
const client = createClient(/* endpoint */);

// Create actor in a specific region
const actor = await client.example.get(
});
```

See [Create  Manage Actors](/actors/communicating-with-actors) for more information.
## Logging

# Logging

Actors provide a built-in way to log complex data to the console.

When dealing with lots of data, `console.log` often doesn't cut it. Using the context's log object (`c.log`) allows you to log complex data using structured logging.

Using the actor logging API is completely optional.

## Log levels

There are 5 log levels:

| Level    | Call                            | Description                                                      |
| -------- | ------------------------------- | ---------------------------------------------------------------- |
| Critical | `c.log.critical(message, ...args);` | Severe errors that prevent core functionality                    |
| Error    | `c.log.error(message, ...args);`    | Errors that affect functionality but allow continued operation   |
| Warning  | `c.log.warn(message, ...args);`     | Potentially harmful situations that should be addressed          |
| Info     | `c.log.info(message, ...args);`     | General information about significant events & state changes     |
| Debug    | `c.log.debug(message, ...args);`    | Detailed debugging information, usually used only in development |

## Structured logging

The built-in logging API (using `c.log`) provides structured logging to let you log key-value
pairs instead of raw strings. Structures logs are readable by both machines &
humans to make them easier to parse & search.

Passing an object to a log will print as structured data. For example:

```typescript
c.log.info('increment', );
// Prints: level=INFO msg=increment connection=123 count=456
```

The first parameter in each log method is the message. The rest of the arguments are used for structured logging.

## `c.log` vs `console.log` logging

`c.log` makes it easier to manage complex logs, while `console.log` can
become unmaintainable at scale.

Consider this example:

```typescript structured_logging.ts
const counter = actor(,
  
  actions: );

      c.state.count += count;
      return c.state.count;
    }
  }
});
```

```typescript unstructured_logging.ts
const counter = actor(,
  
  actions:  with count $`);

      c.state.count += count;
      return c.state.count;
    }
  }
});
```

If you need to search through a lot of logs, it's easier to read the structured logs. To find increments for a single connection, you can search `connection=123`.

Additionally, structured logs can be parsed and queried at scale using tools like Elasticsearch, Loki, or Datadog. For example, you can parse the log `level=INFO msg=increment connection=123 count=456` in to the JSON object `` and then query it as you would any other structured data.

## Usage in lifecycle hooks

The logger is available in all lifecycle hooks:

```typescript
const loggingExample = actor(,
  
  onStart: (c) => );
  },
  
  onBeforeConnect: (c, ) => );
    
    return ;
  },
  
  onConnect: (c) => );
    
    c.state.events.push();
  },
  
  onDisconnect: (c) => );
    
    c.state.events.push();
  },
  
  actions: 
});
```
## Registry

# Registry

Configure and manage your actor registry

The registry is the central configuration hub for your Rivet application. It defines which actors are available and how your application runs.

## Basic Setup

Create a registry by importing your actors and using the `setup` function:

```typescript
const registry = setup(,
});
```

## Creating Servers

### Development Server

For development, create and run a server directly:

```typescript
// Start a development server
registry.runServer(,
    manager: ,
  },
});
```

### Production Setup

For production, get the handler and integrate with your framework:

```typescript
// Create server components
const  = registry.createServer(,
    manager: ,
  },
});

// Use with Hono
const app = new Hono();
app.route("/registry", hono);

// Or use the handler directly
app.all("/registry/*", handler);

// Start the server
serve(app);
```

## Configuration Options

### Driver Configuration

The driver configuration determines how actors are stored and managed:

```typescript
const  = registry.createServer(,
    
    // Manager coordination
    manager: ,
  },
});
```

### Topology Options

- **`standalone`**: Single process, good for development
- **`partition`**: Distributed actors, good for production scaling
- **`coordinate`**: Peer-to-peer coordination, good for high availability

### Storage Drivers

- **`memory`**: In-memory storage, data lost on restart
- **`file-system`**: Persistent file-based storage
- **`redis`**: Redis-backed persistence and coordination
- **`rivet`**: Rivet platform integration

### CORS Configuration

Configure CORS for browser clients:

```typescript
registry.runServer(,
});
```

### Request Limits

Configure request size limits:

```typescript
registry.runServer();
```

## Worker Mode

For distributed topologies, you can create worker instances:

```typescript
// Manager instance (handles routing)
const  = registry.createServer(,
});

// Worker instance (runs actors)
const  = registry.createWorker(,
});
```

## Type Safety

The registry provides full type safety for your client:

```typescript
// TypeScript knows about your actors
const counter = client.counter.getOrCreate(["my-counter"]);
const chatRoom = client.chatRoom.getOrCreate(["general"]);

// Action calls are type-checked
const count: number = await counter.increment(5);
```

## Testing Configuration

Use memory drivers for testing:

```typescript
// test-registry.ts
const testRegistry = setup(,
});

// In your tests
const  = testRegistry.createServer(,
    manager: ,
  },
});
```

## Environment-Specific Configuration

Use environment variables to configure different environments:

```typescript
const isProd = process.env.NODE_ENV === "production";
const redisUrl = process.env.REDIS_URL || "redis://localhost:6379";

const registry = setup(,
});

// Environment-specific server creation
function createAppServer() ,
          manager: ,
        }
      : ,
          manager: ,
        },
    cors: ,
  });
}
```

## Best Practices

### Registry Organization

Keep your registry clean and organized:

```typescript
// actors/index.ts - Export all actors
 from "./counter";
 from "./chat-room";
 from "./game";

// registry.ts - Import and configure
const registry = setup();
```

### Actor Naming

Use consistent naming conventions:

```typescript
const registry = setup(,
});
```

### Configuration Management

Separate configuration from registry definition:

```typescript
// config.ts
const appConfig = ,
  cors: ,
};

// server.ts
const  = registry.createServer(,
    manager: ,
  },
  cors: appConfig.cors,
});

serve();
```
## Self-Hosting

# Self-Hosting

Take full control of your Rivet deployment with flexible hosting options and storage drivers.

## Hosting Providers

  Deploy Rivet applications with Railway's simple platform-as-a-service

  Run Rivet actors on Cloudflare's edge computing platform

  Managed Rivet hosting with enterprise features and support

## Drivers

  High-performance in-memory data store for production workloads

  Simple file-based storage for development and small deployments

  In-memory storage for testing and ephemeral use cases

  Create custom storage drivers for your specific requirements
## Rivet Studio

# Rivet Studio

Rivet Studio is a web-based development tool for debugging and monitoring your Rivet Actors in real-time.

## Features

- **View running actors**: See all active Rivet Actors in your application
- **Edit actor state**: Modify actor state in real-time for debugging
- **REPL for actions**: Interactive console to call actor actions directly
- **Event monitoring**: Track actor events including actions, broadcasts, events, and subscriptions
- **Connection viewer**: Monitor all connected connections & their associated state

## How it works

RivetKit automatically mounts a route at `/registry` on your server for Studio access. When your application starts:

1. RivetKit generates a secure token for authentication on startup
2. Open to [studio.rivet.gg](https://studio.rivet.gg) in your browser or click the `studio.rivet.gg` URL that's printed to your console on startup
3. Rivet Studio connects to your application

Rivet Studio is automatically disabled in production when `NODE_ENV=production`.

## Configuration

### Token configuration

By default, Rivet Studio generates and stores a token automatically. You can configure it:

- **Environment variable**: Set `RIVETKIT_STUDIO_TOKEN`
- **Code configuration**:
  ```typescript }
  registry.runServer(
  })
  ```

### Disabling the Studio

Disable Studio using any of these methods:

- Set `RIVETKIT_STUDIO_DISABLE` environment variable
- Set `NODE_ENV=production`
- Configure in code:
  ```typescript }
  registry.runServer(
  })
  ```

### CORS configuration

Configure CORS for custom Studio deployments:

```typescript }
registry.runServer(
  }
})
```

See the [CORS documentation](/docs/general/cors/) for more details.

### Default endpoint

On startup, RivetKit prints a URL for connecting to Studio. By default, Studio connects to `localhost:8080` if no endpoint is provided. Override with:

```typescript }
registry.runServer(
})
```
## System Architecture

# System Architecture

	This document is for advanced users seeking to understand the internal architecture of RivetKit. Most users do not need to read this document.

## Request Lifecycle

### Base Architecture

### Coordinated Architecture
## Webhooks

# Webhooks

TODO
## Cloudflare Workers

# Cloudflare Workers

Deploy Rivet Actors to Cloudflare Workers with Durable Objects for global edge computing with persistent state.

## Feature Support

| Feature | Supported |
| --- | --- |
| Horizontal scaling | Yes |
| WebSockets | Yes |
| SSE | Yes |
| Edge | Yes |
| Scheduling | Yes |

## Setup

Install the Cloudflare Workers driver:

```bash
npm install @rivetkit/cloudflare-workers
```

Update your server code to support Cloudflare Workers:

```typescript }
const  = createServer(registry);

// Setup router
const app = new Hono();

// Example API endpoint
app.post("/increment/:name", async (c) => );
});

const  = createHandler(app);

;
```

```typescript }
const  = createServerHandler(registry);
;
```

Update your `wrangler.json` configuration to support `ACTOR_DO` and `ACTOR_KV` bindings:

```json }

  ],
  "durable_objects": 
    ]
  },
  "kv_namespaces": [
    
  ]
}
```

**Configuration Requirements:**

- `ACTOR_DO` - Durable Object binding for actor persistence
- `ACTOR_KV` - KV namespace binding for metadata storage
- `nodejs_compat` - Required compatibility flag
- Migration with `ActorHandler` class definition

Deploy your application to Cloudflare Workers:

```bash
wrangler deploy
```

Your actors will now run on Cloudflare's global edge network with persistent state backed by Durable Objects.

## Examples

Example using Cloudflare Workers with Hono web framework.

Basic Cloudflare Workers setup and configuration example.

## Advanced

### Accessing Environment Bindings

You can access Cloudflare Workers environment bindings directly using the importable `env`:

```typescript
// Access environment variables and secrets in top-level scope
const API_KEY = env.API_KEY;
const LOG_LEVEL = env.LOG_LEVEL || "info";

// Use bindings in your actor
const myActor = actor(,
  
  actions: 
    }
  }
});
```

### Driver Context

The Cloudflare Workers driver provides access to the Durable Object state and environment through the driver context in `createVars`.

```typescript
const myActor = actor(,
  
  // Save the Cloudflare driver context
  createVars: (ctx: ActorInitContext, driver: DriverContext) => (),
  
  actions: ,
  }
});
```

The Cloudflare Workers driver context type is exported as `DriverContext` from `@rivetkit/cloudflare-workers`:

```typescript
interface DriverContext 
```

While you have access to the Durable Object state, be cautious when directly modifying KV storage or alarms, as this may interfere with RivetKit's internal operations and potentially break actor functionality.
## Railway

# Railway

_Coming Soon_
## Rivet Cloud (Enterprise)

# Rivet Cloud (Enterprise)

Rivet Cloud enables you to run Rivet applications at scale with the high performance, edge support, and monitoring. Rivet projects can be deployed to the Rivet Cloud or be self-hosted on-premise.

To try Rivet Cloud, get in touch:

- [Talk to an engineer](https://www.rivet.gg/talk-to-an-engineer)
- [Talk to sales](https://www.rivet.gg/sales)

Rivet Engine â€” the core of Rivet Cloud â€” is [open-source on GitHub](https://github.com/rivet-gg/rivet).

## Feature Support

| Feature | Supported |
| --- | --- |
| Horizontal scaling | Yes |
| WebSockets | Yes |
| SSE | Yes |
| Edge | Yes |
| Scheduling | Yes |
## Better Auth

# Better Auth

Integrate Rivet with Better Auth for authentication

Better Auth provides a comprehensive authentication solution that integrates seamlessly with Rivet Actors using the `onAuth` hook.

	Check out the complete example

## Installation

Install Better Auth alongside Rivet:

```bash
npm install better-auth better-sqlite3
npm install -D @types/better-sqlite3

# For React integration
npm install @rivetkit/react
```

	This example uses SQLite to keep the example. In production, replace this with a database like Postgres. Read more about [configuring your database in Better Auth](https://www.better-auth.com/docs/installation#configure-database).

## Backend Setup

Create your authentication configuration:

```typescript auth.ts
const auth = betterAuth(,
});
```

Create and apply the database schema:

```bash
# Generate migration files
pnpm dlx @better-auth/cli@latest generate --config auth.ts

# Apply migrations to create the database tables
pnpm dlx @better-auth/cli@latest migrate --config auth.ts -y
```

Use the `onAuth` hook to validate sessions:

```typescript registry.ts
const chatRoom = actor( = opts;
    
    // Use Better Auth to validate the session
    const authResult = await auth.api.getSession();
    if (!authResult) throw new Unauthorized();
    
    // Return user data to be available in actor
    return ;
  },
  
  state: ,
  
  actions:  = c.conn.auth;
      
      const newMessage = ;
      
      c.state.messages.push(newMessage);
      c.broadcast("newMessage", newMessage);
      
      return newMessage;
    },
    
    getMessages: (c) => c.state.messages,
  },
});

const registry = setup(,
});
```

Configure your server to handle Better Auth routes and Rivet:

```typescript
// server.ts
const  = registry.createServer();
const app = new Hono();

// Configure CORS for Better Auth + Rivet
app.use("*", cors());

// Mount Better Auth routes
app.on(["GET", "POST"], "/api/auth/**", (c) => 
  auth.handler(c.req.raw)
);

// Start Rivet server
serve(app);
```

## Frontend Integration

Create a Better Auth client for your frontend:

```typescript
// auth-client.ts
const authClient = createAuthClient();
```

Create login/signup forms:

```tsx
// AuthForm.tsx
function AuthForm() );
      } else );
      }
    } catch (error) 
  };

  return (

          required
        />
      )}
      
       setEmail(e.target.value)}
        required
      />
      
       setPassword(e.target.value)}
        required
      />

       setIsLogin(!isLogin)}
      >

  );
}
```

Use authenticated sessions with Rivet:

```tsx
// ChatRoom.tsx
const client = createClient("http://localhost:8080");
const  = createRivetKit(client);

interface ChatRoomProps  };
  roomId: string;
}

function ChatRoom(: ChatRoomProps) );

  const sendMessage = async () => ;

  return (

        Welcome, !
         authClient.signOut()}>Sign Out

        : 
          
        ))}

         setNewMessage(e.target.value)}
          onKeyPress=
          placeholder="Type a message..."
        />
        Send

  );
}
```

## Advanced Features

### Role-Based Access

Add role checking to your actors:

```typescript
const adminActor = actor();
    if (!authResult) throw new Unauthorized();
    
    return ;
  },
  
  actions:  = c.conn.auth;
      if (user.role !== "admin") 

      // Admin-only action
      // ... implementation
    },
  },
});
```

### Session Management

Handle session expiration gracefully:

```tsx
// hooks/useAuth.ts
function useAuthWithRefresh()  = authClient.useSession();
  
  useEffect(() => 
  }, [error]);
  
  return session;
}
```

## Production Deployment

For production, you'll need a database from a provider like [Neon](https://neon.tech/), [PlanetScale](https://planetscale.com/), [AWS RDS](https://aws.amazon.com/rds/), or [Google Cloud SQL](https://cloud.google.com/sql).

Configure your production database connection:

```typescript
// auth.ts
const auth = betterAuth(),
  trustedOrigins: [process.env.FRONTEND_URL],
  emailAndPassword: ,
});
```

Set the following environment variables for production:

```bash
DATABASE_URL=postgresql://username:password@localhost:5432/myapp
FRONTEND_URL=https://myapp.com
BETTER_AUTH_SECRET=your-secure-secret-key
BETTER_AUTH_URL=https://api.myapp.com
```

Read more about [configuring Postgres with Better Auth](https://www.better-auth.com/docs/adapters/postgresql).

	Don't forget to re-generate & re-apply your database migrations if you change the database in your Better Auth config.
## Elysia

# Elysia

Integrate Rivet with Elysia for fast TypeScript web applications

Elysia is a fast and type-safe web framework for Bun. Rivet integrates seamlessly with Elysia using the `.mount()` method.

	Check out the complete example

## Installation

Install Elysia alongside Rivet:

```bash
npm install elysia
# or with bun
bun add elysia
```

## Basic Setup

Set up your Rivet Actors:

```typescript
// registry.ts
const counter = actor(,
  actions: ,
    getCount: (c) => c.state.count,
  },
});

const registry = setup(,
});
```

Mount Rivet into your Elysia application:

```typescript
// server.ts
const  = registry.createServer();

// Setup Elysia app
const app = new Elysia()
  // Mount Rivet handler
  .mount("/registry", handler)
  // Add your API routes
  .post("/increment/:name", async () => `;
  })
  .get("/count/:name", async () => ;
  })
  .listen(8080);

console.log("Server running at http://localhost:8080");
```
## Express

# Express

Integrate Rivet with Express.js for Node.js web applications

Express.js is a popular Node.js web framework. Rivet integrates seamlessly with Express using middleware mounting.

	Check out the complete example

## Installation

Install Express alongside Rivet:

```bash
npm install express
npm install -D @types/express
```

## Basic Setup

Set up your Rivet Actor:

```typescript
// registry.ts
const counter = actor(,
  actions: ,
    getCount: (c) => c.state.count,
  },
});

const registry = setup(,
});
```

Mount Rivet into your Express application:

```typescript
// server.ts
// Start Rivet
const  = registry.createServer();

// Setup Express app
const app = express();

// Enable JSON parsing
app.use(express.json());

// Mount Rivet handler
app.use("/registry", handler);

// Add your API routes
app.post("/increment/:name", async (req, res) =>  = req.body;
  
  try );
  } catch (error) );
  }
});

app.get("/count/:name", async (req, res) => );
  } catch (error) );
  }
});

app.listen(8080, () => );
```
## Hono

# Hono

Integrate Rivet with Hono for ultra-fast web applications

Hono is an ultra-fast web framework that works on any runtime. Rivet integrates seamlessly with Hono through the `serve()` method.

	Check out the complete example

## Installation

Install Hono alongside Rivet:

```bash
npm install hono
```

## Basic Setup

Set up your Rivet Actor:

```typescript
// registry.ts
const counter = actor(,
  actions: ,
    getCount: (c) => c.state.count,
  },
});

const registry = setup(,
});
```

Use Rivet's `serve()` method with your Hono app:

```typescript
// server.ts
// Start Rivet
const  = registry.createServer();

// Setup Hono app
const app = new Hono();

// Add your API routes
app.post("/increment/:name", async (c) => ));
  const amount = body.amount || 1;
  
  try );
  } catch (error) , 500);
  }
});

app.get("/count/:name", async (c) => );
  } catch (error) , 500);
  }
});

// Start server with Rivet integration
serve(app);
```
## Integrations

# Integrations

Rivet provides seamless integrations with popular frameworks and tools to help you build modern applications.

## Frontend & Clients

  Full-featured JavaScript client for web and Node.js applications

  React hooks and components for building interactive UIs

  Type-safe Rust client for high-performance applications

## Backend

  Lightweight and fast web framework for modern JavaScript

  Popular Node.js web framework with extensive middleware support

  Fast and type-safe TypeScript web framework

  End-to-end type-safe API development

## Auth

  Modern authentication library with TypeScript support

## Misc

  Fast unit testing framework for JavaScript and TypeScript
## Next.js

# Next.js

Next.js is a powerful React framework that allows you to build server-rendered applications with ease. The Rivet Next.js client enables you to connect to and interact with actors in your Next.js applications.

	Check out the complete example

	Use the RivetKit React client to connect to actors

## Basic Usage

Install the RivetKit Next.js package:

Create a simple counter actor:

```ts }
const counter = actor(,
	actions: ,
		getCount: (c) => c.state.count,
	},
});

const registry = setup(,
});
```

```ts }
const server = registry.createServer(,
});

// Export the Next.js handler for the API routes
const  = toNextHandler(server);
```

## API Reference

### `toNextHandler`
Converts a RivetKit server to a Next.js handler for API routes.

```ts
const counter = actor(,
	actions: ,
});

const registry = setup(,
});

const server = registry.createServer();

const  = toNextHandler(server);
```

#### Parameters
- `server`: The RivetKit server instance created from your registry.

#### Returns
- An object containing Next.js-compatible handlers for the HTTP methods.
## tRPC

# tRPC

Integrate Rivet with tRPC for end-to-end type-safe APIs

tRPC provides end-to-end type safety for your APIs. Rivet integrates seamlessly with tRPC, allowing you to create type-safe procedures that call Rivet Actors.

	Check out the complete example

## Installation

Install tRPC alongside Rivet:

```bash
npm install @trpc/server @trpc/client zod
npm install -D @trpc/next # if using Next.js
```

## Basic Setup

Set up your Rivet Actors:

```typescript
// registry.ts
const counter = actor(,
  actions: ,
    getCount: (c) => c.state.count,
    reset: (c) => ,
  },
});

const registry = setup(,
});
```

Create your tRPC router that uses Rivet:

```typescript
// server.ts
// Start Rivet
const  = registry.createServer();

// Initialize tRPC
const t = initTRPC.create();

// Create tRPC router with Rivet integration
const appRouter = t.router())
      .mutation(async () => ;
      }),
    
    get: t.procedure
      .input(z.object())
      .query(async () => ;
      }),
    
    reset: t.procedure
      .input(z.object())
      .mutation(async () => ;
      }),
  }),
});

// Export type for client
type AppRouter = typeof appRouter;

// Create HTTP server
const server = createHTTPServer();

server.listen(3001);
console.log("tRPC server listening at http://localhost:3001");
```

Create a type-safe tRPC client:

```typescript
// client.ts
const trpc = createTRPCProxyClient(),
  ],
});

// Usage examples
async function examples() );
  console.log(result); // 
  
  // Get counter value
  const value = await trpc.counter.get.query();
  console.log(value); // 
  
  // Reset counter
  const reset = await trpc.counter.reset.mutate();
  console.log(reset); // 
}
```
## Vitest

# Vitest

See [Testing](/docs/general/testing) documentation.
## Binary

# Binary Installation

  Binary releases are coming soon. For now, please use the [Docker image](/docs/self-hosting/installing/docker-image) or [build from source](/docs/self-hosting/installing/build-from-source).

## Coming Soon

We're working on providing pre-built binaries for:

- Linux (x86_64, ARM64)
- macOS (Intel, Apple Silicon)
- Windows (x86_64)

Binary releases will be available through:
- Direct download from GitHub releases
- Package managers (Homebrew, apt, yum)
- Installation scripts

## Alternative Installation Methods

While we prepare binary releases, you can use:

- [Docker Image](/docs/self-hosting/installing/docker-image) - Recommended for most users
- [Build from Source](/docs/self-hosting/installing/build-from-source) - For advanced users who need custom builds
## Build From Source

# Build From Source

Build Rivet Engine from source for custom configurations or to contribute to development.

## Prerequisites

- Rust 1.75+ (install via [rustup](https://rustup.rs/))
- Git
- C compiler (for native dependencies)

## Clone the Repository

```bash
git clone https://github.com/rivet-gg/rivet.git
cd rivet
```

## Build the Engine

### Development Build

```bash
cargo build -p rivet-engine
```

The binary will be available at `target/debug/rivet-engine`.

### Release Build

For production use, build with optimizations:

```bash
cargo build --release -p rivet-engine
```

The optimized binary will be at `target/release/rivet-engine`.

## Run the Engine

After building, run the engine:

```bash
# Development build
./target/debug/rivet-engine

# Release build
./target/release/rivet-engine
```

## Configuration

Configure the engine using environment variables or a configuration file:

```bash
RIVET_PORT=5032 \
RIVET_STORAGE_TYPE=filesystem \
RIVET_DATA_DIR=/path/to/data \
./target/release/rivet-engine
```

## Building with Features

Enable specific features during build:

```bash
# Build with FoundationDB support (enterprise)
cargo build --release -p rivet-engine --features foundationdb

# Build with all features
cargo build --release -p rivet-engine --all-features
```

## Docker Build

Build your own Docker image:

```bash
docker build -t my-rivet-engine .
```

## Next Steps

- [Configure the engine](/docs/self-hosting/reference/configuration)
- [Connect runners](/docs/self-hosting/reference/connecting)
- Set up your [database backend](/docs/self-hosting/reference/databases)
## Docker Image

# Docker Image

The official Rivet Engine Docker image is available on Docker Hub at `rivetkit/engine`.

## Quick Start

Run the Rivet Engine with the following command:

```bash
docker run -p 5032:5032 -v rivet-data:/data rivetkit/engine
```

This will:
- Expose the engine on port 5032
- Mount a volume for persistent data storage
- Use the default file system storage backend

## Configuration

### Environment Variables

You can configure the engine using environment variables:

```bash
docker run -p 5032:5032 \
  -v rivet-data:/data \
  -e RIVET_STORAGE_TYPE=postgres \
  -e RIVET_POSTGRES_URL="postgresql://user:pass@host:5432/db" \
  rivetkit/engine
```

### Volume Mounts

For file system storage, mount a volume to persist data:

```bash
docker run -p 5032:5032 \
  -v /path/to/local/data:/data \
  rivetkit/engine
```

## Available Tags

- `latest` - Latest stable release
- `vX.Y.Z` - Specific version tags
- `edge` - Development builds (not recommended for production)

## Next Steps

- [Connect your runners](/docs/self-hosting/reference/connecting) to the engine
- Configure your [database backend](/docs/self-hosting/reference/databases)
- Learn about [networking options](/docs/self-hosting/reference/networking)
## AWS

# AWS Deployment

  Coming Soon
  
    AWS deployment documentation is currently being prepared. This will include:

    â€¢ ECS (Elastic Container Service) deployment
    â€¢ EKS (Elastic Kubernetes Service) setup
    â€¢ EC2 instance configuration
    â€¢ RDS PostgreSQL integration
    â€¢ Application Load Balancer setup
    â€¢ Auto Scaling Groups
    â€¢ CloudFormation templates
    â€¢ CDK (Cloud Development Kit) examples
    â€¢ Cost optimization strategies

## Deployment Options

We'll cover multiple AWS deployment strategies:

### ECS Fargate
- Serverless container hosting
- Automatic scaling
- No infrastructure management

### ECS on EC2
- More control over instances
- Cost-effective for steady workloads
- Custom AMI support

### EKS
- Managed Kubernetes
- Integration with existing K8s workflows
- Advanced orchestration features

### EC2
- Full control over deployment
- Custom configurations
- Traditional VM approach

## In the Meantime

- Deploy using [Docker](/docs/self-hosting/platforms/docker-container) on EC2 instances
- Use [Docker Compose](/docs/self-hosting/platforms/docker-compose) for quick setups
- Check [Railway](/docs/self-hosting/platforms/railway) for managed deployments
## Docker Compose

# Docker Compose Deployment

Docker Compose simplifies multi-container Rivet deployments with declarative configuration.

## Quick Start

Create a `docker-compose.yml` file:

```yaml
version: '3.8'

services:
  rivet-engine:
    image: rivetkit/engine:latest
    ports:
      - "5032:5032"
    volumes:
      - rivet-data:/data
    environment:
      - RIVET_STORAGE_TYPE=filesystem
    restart: unless-stopped

volumes:
  rivet-data:
```

Start the deployment:

```bash
docker-compose up -d
```

## Full Stack Example

Complete deployment with PostgreSQL and NATS:

```yaml
version: '3.8'

services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: rivet
      POSTGRES_USER: rivet
      POSTGRES_PASSWORD: rivet_password
    volumes:
      - postgres-data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U rivet"]
      interval: 10s
      timeout: 5s
      retries: 5

  nats:
    image: nats:latest
    command: "-js -sd /data"
    volumes:
      - nats-data:/data
    healthcheck:
      test: ["CMD", "nats", "account", "info"]
      interval: 10s
      timeout: 5s
      retries: 5

  rivet-engine:
    image: rivetkit/engine:latest
    ports:
      - "5032:5032"  # API
      - "5033:5033"  # Proxy
      - "9090:9090"  # Metrics
    environment:
      RIVET_STORAGE_TYPE: postgres
      RIVET_POSTGRES_URL: postgresql://rivet:rivet_password@postgres:5432/rivet
      RIVET_PUBSUB_TYPE: nats
      RIVET_NATS_URL: nats://nats:4222
      RIVET_LOG_LEVEL: info
    depends_on:
      postgres:
        condition: service_healthy
      nats:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  postgres-data:
  nats-data:
  rivet-data:
```

## Environment Configuration

### Using .env File

Create a `.env` file:

```env
# Database
POSTGRES_PASSWORD=secure_password_here
RIVET_POSTGRES_URL=postgresql://rivet:secure_password_here@postgres:5432/rivet

# PubSub
RIVET_NATS_URL=nats://nats:4222

# Engine Config
RIVET_LOG_LEVEL=info
RIVET_AUTH_TOKEN=your_secret_token
```

Reference in `docker-compose.yml`:

```yaml
services:
  rivet-engine:
    image: rivetkit/engine:latest
    env_file:
      - .env
    environment:
      RIVET_STORAGE_TYPE: postgres
```

### Multiple Environment Files

```yaml
services:
  rivet-engine:
    env_file:
      - common.env
      - secrets.env
      - $.env  # dev.env, prod.env, etc.
```

## Networking

### Custom Network

```yaml
version: '3.8'

networks:
  rivet-net:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16

services:
  rivet-engine:
    networks:
      rivet-net:
        ipv4_address: 172.20.0.10
```

### External Network

```yaml
networks:
  external-net:
    external: true

services:
  rivet-engine:
    networks:
      - external-net
      - default
```

## Scaling

### Multiple Runners

```yaml
services:
  rivet-runner:
    image: your-app:latest
    environment:
      RIVET_ENGINE: http://rivet-engine:5032
      RIVET_RUNNER_KEY: $
    deploy:
      replicas: 3
    depends_on:
      - rivet-engine
```

Scale dynamically:

```bash
docker-compose up -d --scale rivet-runner=5
```

## Resource Limits

```yaml
services:
  rivet-engine:
    image: rivetkit/engine:latest
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 4G
        reservations:
          cpus: '1'
          memory: 2G
```

## Health Monitoring

### Health Checks

```yaml
services:
  rivet-engine:
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
```

### Monitoring Stack

Add Prometheus and Grafana:

```yaml
services:
  prometheus:
    image: prom/prometheus
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus-data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
    ports:
      - "9091:9090"

  grafana:
    image: grafana/grafana
    environment:
      GF_SECURITY_ADMIN_PASSWORD: admin
    volumes:
      - grafana-data:/var/lib/grafana
    ports:
      - "3000:3000"
    depends_on:
      - prometheus

volumes:
  prometheus-data:
  grafana-data:
```

Prometheus configuration (`prometheus.yml`):

```yaml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'rivet-engine'
    static_configs:
      - targets: ['rivet-engine:9090']
```

## Backup and Restore

### Backup Script

```yaml
services:
  backup:
    image: alpine:latest
    volumes:
      - postgres-data:/postgres-data:ro
      - ./backups:/backups
    command: >
      sh -c "tar czf /backups/backup-$$(date +%Y%m%d-%H%M%S).tar.gz
             -C / postgres-data"
    profiles:
      - tools
```

Run backup:

```bash
docker-compose run --rm backup
```

### Restore Script

```yaml
services:
  restore:
    image: alpine:latest
    volumes:
      - postgres-data:/postgres-data
      - ./backups:/backups
    command: >
      sh -c "tar xzf /backups/$$BACKUP_FILE -C /"
    profiles:
      - tools
```

Run restore:

```bash
BACKUP_FILE=backup-20240101-120000.tar.gz \
docker-compose run --rm restore
```

## Production Configuration

### docker-compose.prod.yml

```yaml
version: '3.8'

services:
  rivet-engine:
    image: rivetkit/engine:$
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"
    deploy:
      restart_policy:
        condition: any
        delay: 5s
        max_attempts: 3
        window: 120s
    secrets:
      - db_password
      - auth_token
    environment:
      RIVET_POSTGRES_PASSWORD_FILE: /run/secrets/db_password
      RIVET_AUTH_TOKEN_FILE: /run/secrets/auth_token

secrets:
  db_password:
    file: ./secrets/db_password.txt
  auth_token:
    file: ./secrets/auth_token.txt
```

Deploy production:

```bash
docker-compose -f docker-compose.yml \
               -f docker-compose.prod.yml \
               up -d
```

## SSL/TLS with Traefik

```yaml
services:
  traefik:
    image: traefik:v2.10
    command:
      - "--providers.docker=true"
      - "--providers.docker.exposedbydefault=false"
      - "--entrypoints.websecure.address=:443"
      - "--certificatesresolvers.letsencrypt.acme.tlschallenge=true"
      - "--certificatesresolvers.letsencrypt.acme.email=admin@example.com"
      - "--certificatesresolvers.letsencrypt.acme.storage=/letsencrypt/acme.json"
    ports:
      - "443:443"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - letsencrypt:/letsencrypt

  rivet-engine:
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.rivet.rule=Host(`engine.example.com`)"
      - "traefik.http.routers.rivet.entrypoints=websecure"
      - "traefik.http.routers.rivet.tls.certresolver=letsencrypt"
      - "traefik.http.services.rivet.loadbalancer.server.port=5032"

volumes:
  letsencrypt:
```

## Common Commands

```bash
# Start services
docker-compose up -d

# Stop services
docker-compose down

# View logs
docker-compose logs -f rivet-engine

# Restart service
docker-compose restart rivet-engine

# Execute command in container
docker-compose exec rivet-engine sh

# Update images
docker-compose pull
docker-compose up -d

# Clean up
docker-compose down -v  # Also removes volumes
```

## Override Files

Development override (`docker-compose.override.yml`):

```yaml
version: '3.8'

services:
  rivet-engine:
    environment:
      RIVET_LOG_LEVEL: debug
    ports:
      - "5032:5032"
      - "9090:9090"
    volumes:
      - ./config:/config
```

  Docker Compose automatically loads `docker-compose.override.yml` if it exists, perfect for local development settings.

## Troubleshooting

### Service Dependencies

Ensure proper startup order:

```yaml
services:
  rivet-engine:
    depends_on:
      postgres:
        condition: service_healthy
      nats:
        condition: service_started
```

### Network Issues

Debug networking:

```bash
# List networks
docker network ls

# Inspect network
docker network inspect rivet_default

# Test connectivity
docker-compose exec rivet-engine ping postgres
```

### Volume Permissions

Fix permission issues:

```bash
# Run as specific user
services:
  rivet-engine:
    user: "1000:1000"

# Or fix in entrypoint
    entrypoint: >
      sh -c "chown -R 1000:1000 /data && exec rivet-engine"
```

## Next Steps

- Deploy to [Railway](/docs/self-hosting/platforms/railway) for managed hosting
- Scale with [Kubernetes](/docs/self-hosting/platforms/kubernetes)
- Set up [monitoring](/docs/self-hosting/reference/monitoring)
## Docker Container

# Docker Container Deployment

Deploy Rivet Engine as a Docker container for simple, portable deployments.

## Quick Start

```bash
docker run -d \
  --name rivet-engine \
  -p 5032:5032 \
  -v rivet-data:/data \
  rivetkit/engine
```

This command:
- Runs the container in detached mode (`-d`)
- Names the container `rivet-engine`
- Exposes port 5032 for API access
- Creates a named volume `rivet-data` for persistence

## Full Configuration

```bash
docker run -d \
  --name rivet-engine \
  --restart unless-stopped \
  -p 5032:5032 \
  -p 5033:5033 \
  -p 9090:9090 \
  -v rivet-data:/data \
  -v /path/to/config:/config \
  -e RIVET_STORAGE_TYPE=postgres \
  -e RIVET_POSTGRES_URL="postgresql://user:pass@db:5432/rivet" \
  -e RIVET_PUBSUB_TYPE=nats \
  -e RIVET_NATS_URL="nats://nats:4222" \
  -e RIVET_LOG_LEVEL=info \
  rivetkit/engine
```

## Docker Run Options

### Container Management

```bash
# Auto-restart on failure
--restart unless-stopped

# Resource limits
--memory="2g"
--cpus="2"

# Health check
--health-cmd="curl -f http://localhost:8080/health || exit 1"
--health-interval=30s
--health-timeout=10s
--health-retries=3
```

### Networking

```bash
# Use host networking (Linux only)
--network host

# Custom network
--network rivet-net

# Expose additional ports
-p 5033:5033  # Proxy port
-p 9090:9090  # Metrics port
-p 8080:8080  # Health port
```

### Volumes

```bash
# Named volume (recommended)
-v rivet-data:/data

# Bind mount
-v /host/path/data:/data

# Configuration file
-v /host/path/config.yaml:/config/rivet.yaml
```

## Environment Variables

Common environment variables for configuration:

```bash
# Storage
-e RIVET_STORAGE_TYPE=postgres
-e RIVET_POSTGRES_URL="postgresql://..."

# PubSub
-e RIVET_PUBSUB_TYPE=nats
-e RIVET_NATS_URL="nats://..."

# Performance
-e RIVET_WORKERS=4
-e RIVET_MAX_CONNECTIONS=10000

# Security
-e RIVET_AUTH_TOKEN="secret-token"
-e RIVET_TLS_ENABLED=true

# Logging
-e RIVET_LOG_LEVEL=info
-e RIVET_LOG_FORMAT=json
```

## Data Persistence

### Using Named Volumes

```bash
# Create volume
docker volume create rivet-data

# Run with volume
docker run -v rivet-data:/data rivetkit/engine

# Backup volume
docker run --rm \
  -v rivet-data:/source \
  -v $(pwd):/backup \
  alpine tar czf /backup/rivet-backup.tar.gz -C /source .

# Restore volume
docker run --rm \
  -v rivet-data:/target \
  -v $(pwd):/backup \
  alpine tar xzf /backup/rivet-backup.tar.gz -C /target
```

### Using Bind Mounts

```bash
# Create data directory
mkdir -p /opt/rivet/data

# Set permissions
chown 1000:1000 /opt/rivet/data

# Run with bind mount
docker run -v /opt/rivet/data:/data rivetkit/engine
```

## Container Management

### Starting and Stopping

```bash
# Start container
docker start rivet-engine

# Stop gracefully
docker stop rivet-engine

# Restart
docker restart rivet-engine

# Remove container
docker rm rivet-engine
```

### Monitoring

```bash
# View logs
docker logs rivet-engine
docker logs -f rivet-engine  # Follow logs

# Check status
docker ps
docker inspect rivet-engine

# Resource usage
docker stats rivet-engine

# Enter container
docker exec -it rivet-engine sh
```

### Updates

```bash
# Pull latest image
docker pull rivetkit/engine:latest

# Stop old container
docker stop rivet-engine
docker rm rivet-engine

# Start with new image
docker run -d \
  --name rivet-engine \
  -v rivet-data:/data \
  rivetkit/engine:latest
```

## Production Deployment

### Security Hardening

```bash
docker run -d \
  --name rivet-engine \
  --restart unless-stopped \
  --read-only \
  --tmpfs /tmp \
  --security-opt no-new-privileges:true \
  --cap-drop ALL \
  --cap-add NET_BIND_SERVICE \
  -v rivet-data:/data \
  rivetkit/engine
```

### Resource Limits

```bash
docker run -d \
  --name rivet-engine \
  --memory="4g" \
  --memory-swap="4g" \
  --cpus="4" \
  --pids-limit 1000 \
  -v rivet-data:/data \
  rivetkit/engine
```

### Logging

```bash
docker run -d \
  --name rivet-engine \
  --log-driver json-file \
  --log-opt max-size=10m \
  --log-opt max-file=3 \
  -v rivet-data:/data \
  rivetkit/engine
```

## Networking Examples

### Bridge Network

```bash
# Create network
docker network create rivet-net

# Run containers on network
docker run -d --network rivet-net --name postgres postgres:15
docker run -d --network rivet-net --name nats nats:latest
docker run -d --network rivet-net \
  -e RIVET_POSTGRES_URL="postgresql://user:pass@postgres:5432/rivet" \
  -e RIVET_NATS_URL="nats://nats:4222" \
  rivetkit/engine
```

### Host Network (Linux)

```bash
docker run -d \
  --network host \
  -v rivet-data:/data \
  rivetkit/engine
```

## Health Checks

### Built-in Health Check

The container includes a health check endpoint:

```bash
# Check health from host
curl http://localhost:8080/health

# Check from another container
docker run --rm curlimages/curl \
  curl http://rivet-engine:8080/health
```

### Custom Health Check

```dockerfile
# In your Dockerfile
HEALTHCHECK --interval=30s --timeout=10s --retries=3 \
  CMD curl -f http://localhost:8080/health || exit 1
```

## Troubleshooting

### Container Won't Start

```bash
# Check logs
docker logs rivet-engine

# Check events
docker events --filter container=rivet-engine

# Debug mode
docker run -it --rm \
  -e RIVET_LOG_LEVEL=debug \
  rivetkit/engine
```

### Permission Issues

```bash
# Fix volume permissions
docker run --rm \
  -v rivet-data:/data \
  alpine chown -R 1000:1000 /data
```

### Network Issues

```bash
# Test network connectivity
docker run --rm --network rivet-net \
  nicolaka/netshoot \
  ping postgres

# Check port binding
netstat -tlpn | grep 5032
```

  Use Docker Compose for more complex deployments with multiple services. See the [Docker Compose guide](/docs/self-hosting/platforms/docker-compose).

## Next Steps

- Set up [Docker Compose](/docs/self-hosting/platforms/docker-compose) for multi-container deployments
- Deploy to [Kubernetes](/docs/self-hosting/platforms/kubernetes) for orchestration
- Configure [monitoring and metrics](/docs/self-hosting/reference/monitoring)
## Google Cloud

# Google Cloud Deployment

  Coming Soon
  
    Google Cloud deployment documentation is currently being prepared. This will include:

    â€¢ Cloud Run deployment (serverless)
    â€¢ GKE (Google Kubernetes Engine) setup
    â€¢ Compute Engine VM configuration
    â€¢ Cloud SQL PostgreSQL integration
    â€¢ Load Balancer configuration
    â€¢ Cloud Build CI/CD pipelines
    â€¢ Terraform configurations
    â€¢ Identity and Access Management (IAM)
    â€¢ Cost optimization with committed use discounts

## Deployment Options

We'll cover multiple GCP deployment strategies:

### Cloud Run
- Fully managed serverless platform
- Automatic scaling to zero
- Pay-per-use pricing

### GKE Autopilot
- Managed Kubernetes without node management
- Automatic scaling and updates
- Built-in security best practices

### GKE Standard
- Full Kubernetes control
- Custom node pools
- Advanced networking options

### Compute Engine
- Traditional VM deployment
- Full infrastructure control
- Custom machine types

## In the Meantime

- Deploy using [Docker](/docs/self-hosting/platforms/docker-container) on Compute Engine
- Use [Docker Compose](/docs/self-hosting/platforms/docker-compose) for quick deployments
- Try [Railway](/docs/self-hosting/platforms/railway) for simplified hosting
## Hetzner

# Hetzner Cloud Deployment

  Coming Soon
  
    Hetzner deployment documentation is currently being prepared. This will include:

    â€¢ Cloud server provisioning
    â€¢ Load balancer configuration
    â€¢ Floating IPs for high availability
    â€¢ Volume storage setup
    â€¢ Private networks configuration
    â€¢ Firewall rules
    â€¢ Snapshot backups
    â€¢ Terraform deployment scripts
    â€¢ Cost-effective scaling strategies

## Why Hetzner?

Hetzner Cloud offers:
- **Excellent price-performance ratio**
- **German data centers** with strong privacy laws
- **Simple, predictable pricing**
- **Fast NVMe SSD storage**
- **100% renewable energy**

## Deployment Preview

We'll provide:
- One-click deployment scripts
- Ansible playbooks for automation
- Docker Swarm cluster setup
- Kubernetes (k3s) lightweight deployment
- Monitoring with Hetzner Cloud metrics

## In the Meantime

- Deploy using [Docker](/docs/self-hosting/platforms/docker-container) on Hetzner Cloud servers
- Use [Docker Compose](/docs/self-hosting/platforms/docker-compose) for multi-container setups
- Check our [installation guide](/docs/self-hosting/installing/docker-image) for Docker deployment
## Kubernetes

# Kubernetes Deployment

  Coming Soon
  
    Kubernetes deployment documentation is currently being prepared. This will include:

    â€¢ Helm charts for easy deployment
    â€¢ Kubernetes manifests (Deployment, Service, ConfigMap)
    â€¢ Horizontal Pod Autoscaling configuration
    â€¢ Persistent volume setup
    â€¢ Ingress configuration
    â€¢ Multi-node clustering
    â€¢ Security best practices

## Quick Preview

While we prepare comprehensive documentation, here's a basic example:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rivet-engine
spec:
  replicas: 3
  selector:
    matchLabels:
      app: rivet-engine
  template:
    metadata:
      labels:
        app: rivet-engine
    spec:
      containers:
      - name: engine
        image: rivetkit/engine:latest
        ports:
        - containerPort: 5032
        env:
        - name: RIVET_STORAGE_TYPE
          value: postgres
        - name: RIVET_POSTGRES_URL
          valueFrom:
            secretKeyRef:
              name: rivet-secrets
              key: postgres-url
---
apiVersion: v1
kind: Service
metadata:
  name: rivet-engine
spec:
  selector:
    app: rivet-engine
  ports:
    - port: 5032
      targetPort: 5032
  type: LoadBalancer
```

## In the Meantime

- Use [Docker](/docs/self-hosting/platforms/docker-container) for container deployments
- Try [Docker Compose](/docs/self-hosting/platforms/docker-compose) for multi-container setups
- Deploy to [Railway](/docs/self-hosting/platforms/railway) for managed Kubernetes
## Railway

# Railway Deployment

Railway provides a simple platform for deploying Rivet Engine with automatic scaling and managed infrastructure.

## Quick Deploy

  Railway template coming soon. For now, follow the manual deployment steps below.

[![Deploy on Railway](https://railway.app/button.svg)](TODO)

## Manual Deployment

### Prerequisites

1. [Railway account](https://railway.app)
2. [Railway CLI](https://docs.railway.app/develop/cli) (optional)

### Step 1: Create New Project

```bash
# Using Railway CLI
railway init

# Or create via dashboard
# https://railway.app/new
```

### Step 2: Add Services

#### PostgreSQL Database

1. Click "New Service" â†’ "Database" â†’ "PostgreSQL"
2. Railway automatically provisions and configures PostgreSQL
3. Note the connection string from the service variables

#### Rivet Engine

1. Click "New Service" â†’ "Docker Image"
2. Set image: `rivetkit/engine:latest`
3. Configure environment variables

### Step 3: Environment Variables

In the Rivet Engine service settings:

```bash
# Database (use Railway's PostgreSQL reference)
RIVET_STORAGE_TYPE=postgres
RIVET_POSTGRES_URL=$}

# Engine Configuration
RIVET_PORT=5032
RIVET_LOG_LEVEL=info

# Optional: Authentication
RIVET_AUTH_TOKEN=your-secret-token-here
```

### Step 4: Configure Networking

1. Go to Settings â†’ Networking
2. Generate a domain or use custom domain
3. Set port to `5032`

## Railway Configuration File

Create `railway.toml` in your project:

```toml
[deploy]
dockerfilePath = "Dockerfile"

[build]
builder = "dockerfile"

[[services]]
name = "rivet-engine"
image = "rivetkit/engine:latest"

[[services.ports]]
port = 5032
targetPort = 5032

[[services.envs]]
RIVET_STORAGE_TYPE = "postgres"
RIVET_POSTGRES_URL = "$}"
RIVET_LOG_LEVEL = "info"
```

## Custom Dockerfile

For custom configurations, create a `Dockerfile`:

```dockerfile
FROM rivetkit/engine:latest

# Add custom configuration
COPY config.yaml /config/rivet.yaml

# Set environment
ENV RIVET_CONFIG_FILE=/config/rivet.yaml

EXPOSE 5032 5033 9090

CMD ["rivet-engine"]
```

Deploy with:

```bash
railway up
```

## Database Setup

### Using Railway PostgreSQL

Railway automatically provides:
- Managed PostgreSQL instance
- Automatic backups
- Connection pooling
- SSL connections

Access database URL:

```bash
railway variables
# Copy DATABASE_URL value
```

### External Database

Use any PostgreSQL-compatible database:

```bash
RIVET_POSTGRES_URL=postgresql://user:pass@external-db.com:5432/rivet
```

## Scaling

### Horizontal Scaling

Railway supports multiple instances:

```bash
# Via CLI
railway scale --count 3

# Or in dashboard
# Service â†’ Settings â†’ Scaling â†’ Instance Count
```

### Resource Limits

Configure in service settings:

- **Memory**: 512MB - 8GB
- **CPU**: 0.5 - 8 vCPUs
- **Disk**: 1GB - 100GB

Recommended production settings:
- Memory: 2GB minimum
- CPU: 1 vCPU minimum
- Disk: 10GB for file storage

## Monitoring

### Railway Metrics

Built-in metrics available in dashboard:
- CPU usage
- Memory usage
- Network I/O
- Request count
- Response times

### Custom Metrics

Enable Prometheus endpoint:

```bash
RIVET_METRICS_ENABLED=true
RIVET_METRICS_PORT=9090
```

Access metrics at: `https://your-app.railway.app:9090/metrics`

### Logging

View logs in Railway dashboard or CLI:

```bash
# Stream logs
railway logs

# Filter logs
railway logs --filter "error"

# Export logs
railway logs > logs.txt
```

## Custom Domains

### Add Custom Domain

1. Go to Settings â†’ Networking â†’ Custom Domain
2. Add your domain: `engine.yourdomain.com`
3. Configure DNS:

```
CNAME engine.yourdomain.com -> your-app.railway.app
```

### SSL Certificates

Railway automatically provides:
- Free SSL certificates via Let's Encrypt
- Automatic renewal
- HTTP â†’ HTTPS redirect

## Environment Management

### Development Environment

```bash
# Create dev environment
railway environment create dev

# Switch to dev
railway environment dev

# Deploy to dev
railway up
```

### Production Environment

```bash
# Switch to production
railway environment production

# Set production variables
railway variables set RIVET_LOG_LEVEL=warn
railway variables set RIVET_AUTH_ENABLED=true
```

## Connecting Runners

Connect external runners to Railway-hosted engine:

```bash
# Get public URL
railway domain

# Configure runner
RIVET_ENGINE=https://your-app.railway.app npm run start
```

## CI/CD Integration

### GitHub Integration

1. Connect GitHub repo in Railway dashboard
2. Configure automatic deployments
3. Set branch triggers

### GitHub Actions

```yaml
name: Deploy to Railway

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Deploy to Railway
        uses: bervProject/railway-deploy@main
        with:
          railway_token: $}
          service: rivet-engine
```

### GitLab CI

```yaml
deploy:
  stage: deploy
  script:
    - npm install -g @railway/cli
    - railway up
  environment:
    name: production
  only:
    - main
```

## Backup and Recovery

### Automatic Backups

Railway PostgreSQL includes:
- Daily automatic backups
- 7-day retention
- Point-in-time recovery

### Manual Backup

```bash
# Export database
railway run pg_dump $DATABASE_URL > backup.sql

# Import database
railway run psql $DATABASE_URL 
  Join Railway's Discord community for help and best practices: [discord.gg/railway](https://discord.gg/railway)

## Next Steps

- Configure [monitoring](/docs/self-hosting/reference/monitoring)
- Set up [high availability](/docs/self-hosting/reference/high-availability)
- Explore [Kubernetes deployment](/docs/self-hosting/platforms/kubernetes) for more control
## Architecture

# Architecture

  Coming Soon
  
    Detailed architecture documentation is currently being prepared. This will include:

    â€¢ System design and components
    â€¢ Data flow and communication patterns
    â€¢ Scaling strategies
    â€¢ Performance considerations
    â€¢ Security architecture

## In the Meantime

While we prepare comprehensive architecture documentation, you can:

- Review the [Overview](/docs/self-hosting/reference/overview) for a high-level understanding
- Explore the [source code](https://github.com/rivet-gg/rivet) on GitHub
- Check our [system architecture](/docs/general/system-architecture) documentation
- Join our [Discord community](https://discord.gg/rivet) for discussions
## Configuration

# Configuration

Rivet Engine can be configured through environment variables or configuration files. The configuration system is defined in `packages/common/config/`.

## Configuration Methods

### Environment Variables

The most common way to configure Rivet:

```bash
RIVET_PORT=5032 \
RIVET_STORAGE_TYPE=postgres \
RIVET_POSTGRES_URL="postgresql://..." \
rivet-engine
```

### Configuration File

For complex deployments, use a YAML or JSON configuration file:

```yaml
# rivet.yaml
port: 5032
storage:
  type: postgres
  postgres:
    url: postgresql://...
```

Load the configuration:

```bash
rivet-engine --config rivet.yaml
```

## Core Configuration

### Server Settings

| Variable | Description | Default |
|----------|-------------|---------|
| `RIVET_PORT` | HTTP server port | `5032` |
| `RIVET_HOST` | Bind address | `0.0.0.0` |
| `RIVET_WORKERS` | Number of worker threads | CPU cores |
| `RIVET_MAX_CONNECTIONS` | Maximum concurrent connections | `10000` |

### Storage Configuration

| Variable | Description | Options |
|----------|-------------|---------|
| `RIVET_STORAGE_TYPE` | Storage backend type | `filesystem`, `postgres`, `foundationdb` |
| `RIVET_DATA_DIR` | Directory for file storage | `/data` |

### Database Settings

For PostgreSQL:

| Variable | Description |
|----------|-------------|
| `RIVET_POSTGRES_URL` | PostgreSQL connection string |
| `RIVET_POSTGRES_POOL_SIZE` | Connection pool size |
| `RIVET_POSTGRES_MAX_CONNECTIONS` | Maximum connections |

### PubSub Configuration

| Variable | Description | Options |
|----------|-------------|---------|
| `RIVET_PUBSUB_TYPE` | PubSub backend | `memory`, `postgres`, `nats` |
| `RIVET_NATS_URL` | NATS server URL | |
| `RIVET_NATS_CLUSTER` | NATS cluster name | |

## Advanced Configuration

### Performance Tuning

```bash
# Increase connection limits
RIVET_MAX_CONNECTIONS=50000
RIVET_POSTGRES_POOL_SIZE=100

# Optimize for throughput
RIVET_BATCH_SIZE=1000
RIVET_FLUSH_INTERVAL=100

# Enable compression
RIVET_COMPRESSION=true
RIVET_COMPRESSION_LEVEL=6
```

### High Availability

```bash
# Enable clustering
RIVET_CLUSTER_ENABLED=true
RIVET_CLUSTER_NODE_ID=node-1
RIVET_CLUSTER_SEEDS=node-2:5032,node-3:5032

# Configure replication
RIVET_REPLICATION_FACTOR=3
RIVET_MIN_REPLICAS=2
```

### Security

```bash
# Authentication
RIVET_AUTH_ENABLED=true
RIVET_AUTH_TOKEN=secret-token
RIVET_AUTH_METHOD=bearer

# TLS/SSL
RIVET_TLS_ENABLED=true
RIVET_TLS_CERT=/path/to/cert.pem
RIVET_TLS_KEY=/path/to/key.pem

# Network restrictions
RIVET_ALLOWED_ORIGINS=https://app.example.com
RIVET_IP_WHITELIST=10.0.0.0/8,192.168.0.0/16
```

### Monitoring

```bash
# Metrics
RIVET_METRICS_ENABLED=true
RIVET_METRICS_PORT=9090
RIVET_METRICS_PATH=/metrics

# Logging
RIVET_LOG_LEVEL=info
RIVET_LOG_FORMAT=json
RIVET_LOG_OUTPUT=/var/log/rivet/engine.log

# Tracing
RIVET_TRACING_ENABLED=true
RIVET_TRACING_ENDPOINT=http://jaeger:14268
```

## Configuration Profiles

### Development

```bash
# Minimal configuration for local development
RIVET_STORAGE_TYPE=filesystem
RIVET_DATA_DIR=./data
RIVET_LOG_LEVEL=debug
```

### Production

```bash
# Robust configuration for production
RIVET_STORAGE_TYPE=postgres
RIVET_POSTGRES_URL="postgresql://user:pass@db:5432/rivet"
RIVET_POSTGRES_POOL_SIZE=50
RIVET_PUBSUB_TYPE=nats
RIVET_NATS_URL=nats://nats:4222
RIVET_AUTH_ENABLED=true
RIVET_AUTH_TOKEN="$"
RIVET_TLS_ENABLED=true
RIVET_LOG_LEVEL=warn
RIVET_METRICS_ENABLED=true
```

### High Performance

```bash
# Optimized for maximum throughput
RIVET_WORKERS=32
RIVET_MAX_CONNECTIONS=100000
RIVET_BATCH_SIZE=5000
RIVET_COMPRESSION=false
RIVET_STORAGE_TYPE=foundationdb
RIVET_FDB_CLUSTER_FILE=/etc/foundationdb/fdb.cluster
```

## Environment-Specific Overrides

Use environment prefixes for different deployments:

```bash
# Production
PROD_RIVET_STORAGE_TYPE=postgres
PROD_RIVET_AUTH_ENABLED=true

# Staging
STAGING_RIVET_STORAGE_TYPE=postgres
STAGING_RIVET_LOG_LEVEL=debug

# Development
DEV_RIVET_STORAGE_TYPE=filesystem
DEV_RIVET_LOG_LEVEL=trace
```

  For a complete list of configuration options, refer to the source code in `packages/common/config/`.

## Next Steps

- Choose a [database backend](/docs/self-hosting/reference/databases)
- Configure [networking options](/docs/self-hosting/reference/networking)
- Set up [monitoring and metrics](/docs/self-hosting/reference/monitoring)
## Connecting

# Connecting to Rivet Engine

## Default Configuration

With no environment variables set, Rivet defaults to:
- Storing data on the local filesystem
- Running on `localhost:5032`
- Using in-memory pubsub

This is perfect for local development and testing.

## Connecting Runners

To connect a runner to your Rivet Engine, set the `RIVET_ENGINE` environment variable:

```bash
RIVET_ENGINE=http://your-engine-host:5032 npm run dev
```

Once connected:
- The runner appears in the Runners tab of the dashboard
- Your actor names show up in the sidebar
- The engine begins routing traffic to your runner

## Environment Variables

### Core Variables

#### `RIVET_ENGINE`
The endpoint of your Rivet Engine instance.

```bash
# Local development
RIVET_ENGINE=http://localhost:5032

# Production
RIVET_ENGINE=https://engine.your-domain.com
```

#### `RIVET_NAMESPACE`
The namespace to run actors in. Useful for multi-tenant deployments.

```bash
RIVET_NAMESPACE=production
```

#### `RIVET_RUNNER`
A human-readable name for the runner.

```bash
RIVET_RUNNER=worker-01
```

#### `RIVET_RUNNER_KEY`
A unique key for the runner. If another runner connects with the same key, the previous one is disconnected. This is useful for handling zombie runners that weren't shut down gracefully.

```bash
RIVET_RUNNER_KEY=unique-runner-key-123
```

  Generate a unique runner key using: `uuidgen` or `openssl rand -hex 16`

## Connection Examples

### Development Setup

```bash
# Start the engine (defaults to local storage)
rivet-engine

# In another terminal, start your runner
RIVET_ENGINE=http://localhost:5032 npm run dev
```

### Production Setup

```bash
# On the engine server
RIVET_STORAGE_TYPE=postgres \
RIVET_POSTGRES_URL="postgresql://..." \
rivet-engine

# On runner nodes
RIVET_ENGINE=https://engine.example.com \
RIVET_NAMESPACE=production \
RIVET_RUNNER=worker-$(hostname) \
RIVET_RUNNER_KEY=$(cat /etc/machine-id) \
npm run start
```

## Client Connection

Clients connect to the engine using RivetKit:

```typescript
const rivet = new Rivet();
```

## Connection Security

### Authentication

For production deployments, secure your engine:

```bash
# Engine configuration
RIVET_AUTH_TOKEN=secret-token-here

# Runner configuration
RIVET_ENGINE=https://engine.example.com
RIVET_AUTH_TOKEN=secret-token-here
```

### TLS/SSL

Always use HTTPS in production:
- Use a reverse proxy (nginx, Caddy) with SSL certificates
- Or configure the engine with TLS certificates directly

## Troubleshooting

### Runner Not Appearing

If your runner doesn't appear in the dashboard:

1. Check the engine is accessible:
   ```bash
   curl http://your-engine:5032/health
   ```

2. Verify environment variables are set:
   ```bash
   echo $RIVET_ENGINE
   ```

3. Check runner logs for connection errors

### Connection Refused

- Ensure the engine is running on the correct port
- Check firewall rules allow traffic on port 5032
- Verify the engine host is reachable from runner nodes

### Duplicate Runners

If you see duplicate runners:
- Set unique `RIVET_RUNNER_KEY` values
- Or let the engine auto-generate keys (omit the variable)

## Next Steps

- Configure your [engine settings](/docs/self-hosting/reference/configuration)
- Set up a [database backend](/docs/self-hosting/reference/databases)
- Learn about [networking options](/docs/self-hosting/reference/networking)
## Supported Databases

# Supported Databases

Rivet supports multiple database backends for storing actor state and metadata. Choose based on your scale and operational requirements.

## PostgreSQL

**Recommended for most production deployments.**

PostgreSQL provides a robust, battle-tested foundation for Rivet with excellent performance and reliability.

### Features
- ACID compliance
- Strong consistency
- Built-in replication
- Extensive tooling ecosystem
- Supports up to thousands of actors

### Configuration

```bash
RIVET_STORAGE_TYPE=postgres
RIVET_POSTGRES_URL="postgresql://user:password@localhost:5432/rivet"
```

### Connection String Format

```
postgresql://[user[:password]@][host][:port][/dbname][?param1=value1&...]
```

### Required Schema

Rivet automatically creates required tables on startup:
- `actors` - Actor metadata and configuration
- `actor_state` - Persistent actor state
- `messages` - Message queue for actors
- `events` - Event log for debugging

### Performance Tuning

```sql
-- Optimize for Rivet workload
ALTER SYSTEM SET max_connections = 200;
ALTER SYSTEM SET shared_buffers = '256MB';
ALTER SYSTEM SET effective_cache_size = '1GB';
ALTER SYSTEM SET work_mem = '4MB';
```

### High Availability

Use PostgreSQL replication for HA:
- Streaming replication for read replicas
- Logical replication for multi-region
- Tools like Patroni for automatic failover

## FoundationDB (Enterprise)

**For massive scale deployments.**

FoundationDB is a distributed database designed for extreme scale and reliability.

  FoundationDB support is available in Rivet Enterprise. Contact us for access.

### Features
- Unbounded horizontal scaling
- ACID transactions across clusters
- Automatic sharding and rebalancing
- Multi-region support
- Supports millions of actors

### Configuration

```bash
RIVET_STORAGE_TYPE=foundationdb
RIVET_FDB_CLUSTER_FILE=/etc/foundationdb/fdb.cluster
```

### Cluster File

```
# /etc/foundationdb/fdb.cluster
cluster_name:id@host1:4500,host2:4500,host3:4500
```

### Benefits
- No manual sharding required
- Automatic failure recovery
- Consistent performance at any scale
- Multi-datacenter deployments

## File System

**For development and single-node deployments.**

The file system backend stores data directly on disk using efficient binary formats.

### Features
- Zero dependencies
- Simple backup/restore
- Good performance for small deployments
- Suitable for up to hundreds of actors

### Configuration

```bash
RIVET_STORAGE_TYPE=filesystem
RIVET_DATA_DIR=/var/lib/rivet/data
```

### Directory Structure

```
/var/lib/rivet/data/
â”œâ”€â”€ actors/
â”‚   â”œâ”€â”€ metadata/
â”‚   â””â”€â”€ state/
â”œâ”€â”€ messages/
â””â”€â”€ events/
```

### Limitations
- Single node only (no clustering)
- No concurrent access from multiple engines
- Limited query capabilities
- Manual backup required

### Backup

```bash
# Stop the engine
systemctl stop rivet-engine

# Backup data directory
tar -czf rivet-backup.tar.gz /var/lib/rivet/data

# Restore
tar -xzf rivet-backup.tar.gz -C /
```

## Choosing a Database

### Development

Use **File System** for:
- Local development
- Testing and CI/CD
- Prototyping

### Small to Medium Production

Use **PostgreSQL** for:
- Production deployments up to 10,000 actors
- When you need SQL compatibility
- Existing PostgreSQL infrastructure
- Strong consistency requirements

### Large Scale Production

Use **FoundationDB** for:
- More than 10,000 actors
- Multi-region deployments
- Automatic scaling requirements
- Mission-critical reliability

## Migration Between Backends

Rivet provides tools to migrate between storage backends:

```bash
# Export from filesystem to PostgreSQL
rivet-migrate \
  --from filesystem --from-path /data \
  --to postgres --to-url "postgresql://..."

# Export from PostgreSQL to FoundationDB
rivet-migrate \
  --from postgres --from-url "postgresql://..." \
  --to foundationdb --to-cluster /etc/fdb.cluster
```

  Always test migrations in a staging environment first. Migrations may require downtime.

## Performance Comparison

| Backend | Actors | Latency | Throughput | HA | Scaling |
|---------|--------|---------|------------|-------|---------|
| File System | < 1K | < 1ms | High | No | Manual |
| PostgreSQL | < 100K | < 5ms | High | Yes | Vertical |
| FoundationDB | Unlimited | < 10ms | Very High | Yes | Horizontal |

## Next Steps

- Configure [PubSub backends](/docs/self-hosting/reference/pubsub)
- Set up [networking](/docs/self-hosting/reference/networking)
- Learn about [monitoring options](/docs/self-hosting/reference/monitoring)
## Networking

# Networking

Rivet provides sophisticated networking capabilities that are automatically configured for you, including proxying and secure tunneling.

## Rivet Proxy

The Rivet Proxy enables seamless communication with actors through HTTP/WebSocket endpoints.

### How It Works

1. **Client Request**: Client sends request to Rivet Proxy
2. **Routing**: Proxy identifies target actor and runner
3. **Forwarding**: Request forwarded to appropriate runner
4. **Response**: Runner processes request and returns response

```
Client â†’ Rivet Proxy â†’ Runner â†’ Actor
         â†“
    [Routing Logic]
```

### Automatic Configuration

The proxy is automatically configured when you:
- Start the Rivet Engine
- Connect runners to the engine
- Deploy actors

No manual configuration required!

### Request Routing

Requests are routed based on:
- Actor ID in the URL path
- Custom routing rules
- Load balancing policies
- Geographic proximity (enterprise)

Example URLs:
```
https://engine.example.com/actors//action
wss://engine.example.com/actors//connect
```

## Tunneling

Rivet includes built-in tunneling (similar to ngrok) for exposing actors securely without opening public ports.

### How Tunneling Works

1. **Runner Registration**: Runner connects to engine via outbound connection
2. **Tunnel Creation**: Engine creates secure tunnel back to runner
3. **Request Proxying**: Incoming requests routed through tunnel
4. **No Inbound Ports**: Runner needs no open inbound ports

```
Internet â†’ Engine (Public) â†’ Tunnel â†’ Runner (Private) â†’ Actor
```

### Benefits

- **Security**: No exposed ports on runner machines
- **Simplicity**: Works behind NAT/firewalls
- **Automatic**: No configuration needed
- **Scalable**: Thousands of concurrent tunnels

### Use Cases

Perfect for:
- Development machines behind NAT
- Runners in private networks
- Edge deployments
- Kubernetes pods without ingress

## Network Architecture

### Single Node

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Rivet Node          â”‚
â”‚                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Engine  â”‚â”€â”€â”‚  Runner  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚       â”‚                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”                â”‚
â”‚  â”‚  Proxy  â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€ Clients
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Distributed

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Engine Node  â”‚     â”‚ Runner Node  â”‚
â”‚              â”‚     â”‚              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚     â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Engine â”‚â—„â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”‚ Runner â”‚  â”‚
â”‚  â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â”‚     â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚      â”‚       â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Proxy  â”‚â—„â”€â”¼â”€â”€â”€â”€â”€ Clients
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Port Configuration

### Default Ports

| Service | Port | Protocol | Purpose |
|---------|------|----------|---------|
| Engine API | 5032 | HTTP/WS | API and WebSocket connections |
| Proxy | 5033 | HTTP/WS | Actor proxy endpoint |
| Metrics | 9090 | HTTP | Prometheus metrics |
| Health | 8080 | HTTP | Health checks |

### Custom Port Configuration

```bash
# Change default ports
RIVET_PORT=8080
RIVET_PROXY_PORT=8081
RIVET_METRICS_PORT=9091
RIVET_HEALTH_PORT=8082
```

## Load Balancing

### Built-in Load Balancing

Rivet automatically load balances across:
- Multiple runners for the same actor type
- Geographic regions (enterprise)
- Available resources

### Load Balancing Strategies

```bash
# Round-robin (default)
RIVET_LB_STRATEGY=round-robin

# Least connections
RIVET_LB_STRATEGY=least-conn

# Resource-based
RIVET_LB_STRATEGY=resource

# Geographic (enterprise)
RIVET_LB_STRATEGY=geo
```

## TLS/SSL Configuration

### Enable TLS

```bash
RIVET_TLS_ENABLED=true
RIVET_TLS_CERT=/path/to/cert.pem
RIVET_TLS_KEY=/path/to/key.pem
RIVET_TLS_CA=/path/to/ca.pem
```

### Automatic TLS (Let's Encrypt)

```bash
RIVET_TLS_AUTO=true
RIVET_TLS_DOMAINS=engine.example.com,api.example.com
RIVET_TLS_EMAIL=admin@example.com
```

### TLS Between Components

```bash
# Secure runner connections
RIVET_INTERNAL_TLS=true
RIVET_INTERNAL_TLS_VERIFY=true
```

## Firewall Configuration

### Required Inbound Ports

For the **Engine**:
```bash
# Allow API access
ufw allow 5032/tcp

# Allow proxy access
ufw allow 5033/tcp

# Allow metrics (internal only)
ufw allow from 10.0.0.0/8 to any port 9090
```

For **Runners** (with tunneling):
```bash
# No inbound ports required!
# Only outbound to engine:5032
```

### Network Policies (Kubernetes)

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: rivet-engine
spec:
  podSelector:
    matchLabels:
      app: rivet-engine
  ingress:
  - ports:
    - port: 5032
    - port: 5033
  egress:
  -  # Allow all outbound
```

## DNS Configuration

### Basic Setup

```bash
# A records
engine.example.com â†’ Engine IP
*.actors.example.com â†’ Engine IP

# With CDN
engine.example.com â†’ CDN â†’ Engine IP
```

### Multi-Region (Enterprise)

```bash
# GeoDNS routing
us.engine.example.com â†’ US Engine
eu.engine.example.com â†’ EU Engine
ap.engine.example.com â†’ AP Engine

# Global endpoint with latency routing
engine.example.com â†’ Nearest Engine
```

## Network Optimization

### TCP Tuning

```bash
# Increase connection limits
sysctl -w net.core.somaxconn=65535
sysctl -w net.ipv4.tcp_max_syn_backlog=65535

# Enable TCP fast open
sysctl -w net.ipv4.tcp_fastopen=3

# Optimize for low latency
sysctl -w net.ipv4.tcp_low_latency=1
```

### HTTP/2 and WebSocket

```bash
# Enable HTTP/2
RIVET_HTTP2_ENABLED=true

# WebSocket configuration
RIVET_WS_MAX_FRAME_SIZE=1048576
RIVET_WS_COMPRESSION=true
```

## Monitoring Network Health

### Health Endpoints

```bash
# Engine health
curl http://engine:8080/health

# Proxy health
curl http://engine:5033/health

# Runner connectivity
curl http://engine:5032/api/runners
```

### Network Metrics

Monitor these key metrics:
- Connection count
- Request latency
- Tunnel stability
- Bandwidth usage
- Error rates

## Troubleshooting

### Connection Issues

1. **Check engine is reachable**:
   ```bash
   telnet engine.example.com 5032
   ```

2. **Verify DNS resolution**:
   ```bash
   nslookup engine.example.com
   ```

3. **Test with curl**:
   ```bash
   curl -v http://engine.example.com:5032/health
   ```

### Tunnel Problems

1. **Check runner logs** for tunnel errors
2. **Verify outbound connectivity** from runner
3. **Ensure no proxy** interfering with WebSocket
4. **Check firewall** allows outbound connections

### Performance Issues

1. **Monitor latency** between components
2. **Check network** bandwidth utilization
3. **Verify MTU** settings (especially for tunnels)
4. **Enable compression** for large payloads

  Rivet's networking is designed to work out-of-the-box in most environments. Manual configuration is only needed for advanced use cases.

## Next Steps

- Learn about [deployment platforms](/docs/self-hosting/platforms/docker-container)
- Configure [monitoring and metrics](/docs/self-hosting/reference/monitoring)
- Set up [high availability](/docs/self-hosting/reference/high-availability)
## Overview

# Self-Hosting Overview

Rivet consists of three main components that work together to provide a complete actor orchestration platform:

## Core Components

### Rivet Engine

The main service that orchestrates actors. The engine:
- Manages actor lifecycle (creation, destruction, scaling)
- Handles state persistence and replication
- Routes messages between actors and clients
- Provides the HTTP/WebSocket API for communication

### RivetKit

The JavaScript/TypeScript library that connects your application code to the Rivet Engine. RivetKit:
- Provides the actor programming model
- Handles serialization and communication with the engine
- Offers client libraries for connecting to actors
- Manages local development workflows

### Runners

Processes that execute your actor code. Runners:
- Connect to the Rivet Engine to receive work
- Execute actor instances in isolated environments
- Handle actor lifecycle events
- Report health and metrics back to the engine

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Client    â”‚â”€â”€â”€â”€â–¶â”‚    Engine   â”‚â—€â”€â”€â”€â”€â”‚   Runner    â”‚
â”‚  (RivetKit) â”‚     â”‚             â”‚     â”‚             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   Storage   â”‚
                    â”‚  (DB/File)  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Deployment Models

### Single Node

All components run on a single machine:
- Engine, runners, and storage co-located
- Suitable for development and small deployments
- Simple to manage and operate

### Distributed

Components spread across multiple machines:
- Engine runs on dedicated nodes
- Runners distributed across worker nodes
- Storage on separate database cluster
- Suitable for production and high-availability

## Storage Backends

Rivet supports multiple storage backends:
- **File System** - Default, suitable for single-node deployments
- **PostgreSQL** - Recommended for production
- **FoundationDB** - Enterprise option for massive scale

## Next Steps

- Learn how to [connect runners](/docs/self-hosting/reference/connecting)
- Understand [configuration options](/docs/self-hosting/reference/configuration)
- Choose a [database backend](/docs/self-hosting/reference/databases)
## Supported PubSub

# Supported PubSub Backends

Rivet uses PubSub for real-time messaging between components. Choose a backend based on your deployment architecture and scale requirements.

## PostgreSQL NOTIFY

**Best for PostgreSQL-based deployments.**

Uses PostgreSQL's built-in LISTEN/NOTIFY for pub/sub messaging.

### Features
- No additional infrastructure
- Guaranteed delivery to connected clients
- Simple and reliable
- Good for small to medium scale

### Configuration

```bash
RIVET_PUBSUB_TYPE=postgres
RIVET_POSTGRES_URL="postgresql://user:password@localhost:5432/rivet"
```

### How It Works

Rivet uses PostgreSQL channels for different message types:
- `rivet_actor_events` - Actor lifecycle events
- `rivet_state_updates` - State synchronization
- `rivet_messages` - Inter-actor messaging

### Limitations
- Limited to 8KB payload size
- Requires persistent connections
- Performance degrades with many listeners
- Single region only

### Performance Tuning

```sql
-- Increase notification queue size
ALTER SYSTEM SET max_notify_queue_pages = 8;
```

## NATS

**Recommended for distributed deployments.**

NATS is a high-performance messaging system designed for cloud-native applications.

### Features
- Extremely high throughput (millions of messages/sec)
- Low latency (
  Never use memory pubsub in production. It's only suitable for development and testing.

## Choosing a PubSub Backend

### Development

Use **Memory** for:
- Local development
- Unit testing
- Quick prototypes

### Small Production

Use **PostgreSQL NOTIFY** for:
- When already using PostgreSQL for storage
- Simple deployments
- < 100 messages per second
- Single datacenter

### Large Production

Use **NATS** for:
- Distributed deployments
- High message throughput
- Multi-region setups
- Microservices architecture

## Performance Comparison

| Backend | Throughput | Latency | HA | Persistence | Complexity |
|---------|------------|---------|-------|-------------|------------|
| Memory | Unlimited* | < 0.1ms | No | No | None |
| PostgreSQL | 1K msg/s | < 5ms | Yes | Yes | Low |
| NATS | 1M+ msg/s | < 1ms | Yes | Optional | Medium |

*Limited by single process capacity

## Message Patterns

Rivet uses these PubSub patterns:

### Topic-Based Routing

```
actors...events
actors...messages
system.health
system.metrics
```

### Request-Reply

For synchronous operations:
```
requests.
replies.
```

### Broadcast

For cluster-wide notifications:
```
cluster.nodes.join
cluster.nodes.leave
cluster.config.update
```

## Monitoring PubSub

### PostgreSQL NOTIFY

Monitor active listeners:
```sql
SELECT pid, state, query 
FROM pg_stat_activity 
WHERE query LIKE 'LISTEN%';
```

### NATS

Use NATS monitoring endpoints:
```bash
# Server stats
curl http://localhost:8222/varz

# Connection info
curl http://localhost:8222/connz

# Route info (cluster)
curl http://localhost:8222/routez
```

### Memory

Enable debug logging:
```bash
RIVET_LOG_LEVEL=debug
RIVET_LOG_PUBSUB=true
```

## Troubleshooting

### Messages Not Delivered

1. Check connectivity to PubSub backend
2. Verify authentication credentials
3. Ensure topics/channels exist
4. Check for network partitions

### High Latency

1. Monitor PubSub server load
2. Check network latency
3. Consider upgrading to NATS
4. Enable batching if supported

### Message Loss

1. Enable persistence (NATS JetStream)
2. Increase buffer sizes
3. Implement retry logic
4. Monitor for disconnections

## Next Steps

- Configure [networking options](/docs/self-hosting/reference/networking)
- Set up [monitoring](/docs/self-hosting/reference/monitoring)
- Deploy to [production platforms](/docs/self-hosting/platforms/docker-container)