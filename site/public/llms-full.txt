# Rivet Documentation - Complete

This file contains the complete documentation for Rivet, an open-source alternative to Durable Objects.

## Actions

# Actions

Actions are how your backend, frontend, or other actors can communicate with actors. Actions are defined as functions in the actor configuration and can be called from clients.

Actions are very lightweight. They can be called thousands of times per second safely.

Actions are executed via HTTP requests or via WebSockets if [using `.connect()`](/docs/actors/connections).

For advanced use cases that require direct access to HTTP requests or WebSocket connections, see [raw HTTP and WebSocket handling](/docs/actors/fetch-and-websocket-handler).

## Writing Actions

Actions are defined in the `actions` object when creating an actor:

```typescript
const mathUtils = actor(,
  actions: 
  }
});
```

Each action receives a context object (commonly named `c`) as its first parameter, which provides access to state, connections, and other utilities. Additional parameters follow after that.

## Calling Actions

Actions can be called in different ways depending on your use case:

```typescript }
const client = createClient("http://localhost:8080");
const counter = await client.counter.getOrCreate();
const result = await counter.increment(42);
console.log(result); // The value returned by the action
```

Learn more about [communicating with actors from the frontend](/docs/actors/communicating-with-actors).

```typescript }
const registry = setup(
});

const  = registry.runServer();

// Use the client to call actions
const counter = await client.counter.getOrCreate();
const result = await counter.increment(42);
console.log(result);
```

Learn more about [communicating with actors from the backend](/docs/actors/communicating-with-actors).

```typescript }
const actorA = actor(,
  actions: 
  }
});
```

Learn more about [communicating between actors](/docs/actors/communicating-between-actors).

Calling actions from the client are async and require an `await`, even if the action itself is not async.

### Type Safety

The actor client includes type safety out of the box. When you use `createClient()`, TypeScript automatically infers action parameter and return types:

```typescript }
// Create simple counter
const counter = actor(,
  actions: 
  }
});

// Create and the app
const registry = setup(
});
```

```typescript }
const client = createClient("http://localhost:8080");

// Type-safe client usage
const counter = await client.counter.get();
await counter.increment(123); // OK
await counter.increment("non-number type"); // TypeScript error
await counter.nonexistentMethod(123); // TypeScript error
```

## Error Handling

Actors provide robust error handling out of the box for actions.

### User Errors

`UserError` can be used to return rich error data to the client. You can provide:

-   A human-readable message
-   A machine-readable code that's useful for matching errors in a try-catch (optional)
-   A metadata object for providing richer error context (optional)

For example:

```typescript }
const user = actor(,
  actions: 
        });
      }
      
      // Rest of the user registration logic...
    }
  }
});
```

```typescript }
try  catch (error) 
}
```

### Internal Errors

All other errors will return an error with the code `internal_error` to the client. This helps keep your application secure, as errors can sometimes expose sensitive information.

## Schema Validation

If passing data to an actor from the frontend, use a library like [Zod](https://zod.dev/) to validate input data.

For example, to validate action parameters:

```typescript }
// Define schema for action parameters
const IncrementSchema = z.object();

const counter = actor(,
  actions:  = IncrementSchema.parse(params);
        c.state.count += count;
        return c.state.count;
      } catch (err) 
        });
      }
    }
  }
});
```

## Authentication

By default, actors' actions are only accessible from your server-side client.

In order to expose actions publicly to the external client, you'll need to define `onAuth`. More documentation on authentication is available [here](/docs/general/authentication). Read more about the [types of clients](/docs/actors/clients)

## Streaming Return Data

Actions have a single return value. To stream realtime data in response to an action, use [events](/docs/actors/events).

## Using `ActionContext` Externally

When writing complex logic for actions, you may want to extract parts of your implementation into separate helper functions. When doing this, you'll need a way to properly type the context parameter.

Rivet provides the `ActionContextOf` utility type for exactly this purpose:

```typescript
const counter = actor(,
  
  actions: 
  }
});

// Simple helper function with typed context
function incrementCount(c: ActionContextOf) 
```

See [helper types](/docs/actors/helper-types) for more details on using `ActionContextOf` and other utility types.
## Authentication

# Authentication

Secure your actors with authentication and authorization

Rivet provides multiple authentication methods to secure your actors. Use `onAuth` for server-side validation or `onBeforeConnect` for actor-level authentication.

## Authentication Methods

### onAuth Hook (Recommended)

The `onAuth` hook runs on the HTTP server before clients can access actors. This is the preferred method for most authentication scenarios.

```typescript
const chatRoom = actor( = opts;
    
    // Extract token from params or headers
    const token = params.authToken || req.headers.get("Authorization");
    
    if (!token) 
    
    // Validate token and return user data
    const user = await validateJWT(token);
    return ;
  },
  
  state: ,
  
  actions:  = c.conn.auth;
      
      if (role !== "member") 
      
      const message = ;
      
      c.state.messages.push(message);
      c.broadcast("newMessage", message);
      return message;
    }
  }
});
```

### `onBeforeConnect` Hook

Use `onBeforeConnect` when you need access to actor state for authentication:

```typescript
const userProfileActor = actor(),
  
  state: ,
  
  onBeforeConnect: async (c, opts) =>  = opts;
    const userId = await validateUser(params.token);
    
    // Check if user can access this profile
    if (c.state.isPrivate && c.state.ownerId !== userId) 
  },
  
  createConnState: (c, opts) => ;
  },
  
  actions: 
      
      // Update profile...
    }
  }
});
```

Prefer `onAuth` over `onBeforeConnect` when possible, as `onAuth` runs on the HTTP server and uses fewer actor resources.

## Connection Parameters

Pass authentication data when connecting:

```typescript
// Client side
const chat = client.chatRoom.getOrCreate(["general"]);
const connection = chat.connect();

// Or with action calls
const counter = client.counter.getOrCreate(["user-counter"], );
```

## Intent-Based Authentication (Experimental)

The `onAuth` hook receives an `intents` parameter indicating what the client wants to do:

```typescript
const secureActor = actor( = opts;
    
    // Different validation based on intent
    if (intents.has("action"))  else if (intents.has("connect")) 
    
    throw new UserError("Unknown intent");
  },
  
  actions: 
  }
});
```

## Error Handling

### Authentication Errors

Use specific error types for different authentication failures:

```typescript
const protectedActor = actor(
    
    try  catch (error) 
      throw new Unauthorized("Invalid authentication token");
    }
  },
  
  actions: 
      return "Admin content";
    }
  }
});
```

### Client Error Handling

Handle authentication errors on the client:

```typescript
try  catch (error)  else if (error.code === "FORBIDDEN") 
}
```

## Integration with Auth Providers

### Better Auth Integration

  Complete integration guide for Better Auth

### JWT Authentication

```typescript
const jwtActor = actor(
    
    try ;
    } catch (error) 
  },
  
  actions:  = c.conn.auth;
      
      if (!permissions.includes("write")) 
      
      // Perform action...
      return ;
    }
  }
});
```

### API Key Authentication

```typescript
const apiActor = actor(
    
    // Validate with your API service
    const response = await fetch(`$/validate`, 
    });
    
    if (!response.ok) 
    
    const user = await response.json();
    return ;
  },
  
  actions: 
      
      return "Premium content";
    }
  }
});
```

## Role-Based Access Control

Implement RBAC with helper functions:

```typescript
// auth-helpers.ts
function requireRole(requiredRole: string) ;
    
    if (roleHierarchy[userRole]  ' required`);
    }
  };
}

// usage in actor
const forumActor = actor(,
  
  actions: ,
    
    editPost: (c, postId: string, content: string) => 
  }
});
```

## Testing Authentication

Mock authentication for testing:

```typescript
// test helpers
function createMockAuth(userData: any) ;
}

// in tests
describe("Protected Actor", () => )
    };
    
    const result = await mockActor.adminOnly();
    expect(result).toBe("Admin content");
  });
  
  it("denies non-admin actions", async () => )
    };
    
    await expect(mockActor.adminOnly()).rejects.toThrow("Admin access required");
  });
});
```

## Best Practices

1. **Use onAuth**: Prefer `onAuth` over `onBeforeConnect` for most authentication
2. **Validate Early**: Authenticate at the HTTP server level when possible
3. **Specific Errors**: Use appropriate error types (Unauthorized, Forbidden)
4. **Rate Limiting**: Consider rate limiting in your authentication logic
5. **Token Refresh**: Handle token expiration gracefully on the client
6. **Audit Logging**: Log authentication events for security monitoring
7. **Least Privilege**: Only grant the minimum permissions needed
## Actor Clients

# Actor Clients

Learn how to call actions and connect to actors from client applications

This guide covers how to connect to and interact with actors from client applications using Rivet's TypeScript client library. Rivet also supports [React](/docs/clients/react) and [Rust](/docs/clients/rust) clients.

The client is completely optional. If you prefer to write your own networking logic, you can either:

- Make HTTP requests directly to the registry (see [OpenAPI spec](/docs/clients/openapi))
- Write your own HTTP endpoints and use the client returned from `registry.runServer` (see below)

## Client Setup

### Creating a Client

There are several ways to create a client for communicating with actors:

		From your backend server that hosts the registry:

		```typescript }
		const  = registry.createServer();

		const app = new Hono();

		app.post("/foo", () => );

		serve(app);
		```

		This client doesn't [require authentication](/docs/general/authentication).

		From within an actor to communicate with other actors:

		```typescript }
		const myActor = actor(
			}
		});
		```

		This client doesn't [require authentication](/docs/general/authentication).

		Read more about [communicating between actors](/docs/actors/communicating-between-actors).

		For frontend applications or external services connecting to your Rivet backend:

		```typescript }
		// IMPORTANT: Must use `type`

		const client = createClient("http://localhost:8080");

		const response = await client.otherActor.getOrCreate().foo();
		```

		Configure the client with additional options:

		```typescript }
		const client = createClient("http://localhost:8080", );
		```

		This client [requires authentication](/docs/general/authentication).

			Use `import type` when importing the registry type in order to
			avoid accidentally bundling your backend code.

			```typescript }
			// âœ… Do this
			// ðŸš« Not this
			```

## `ActorClient`

The `ActorClient` provides methods for finding and creating actors. All methods return an `ActorHandle` that you can use to call actions or establish connections.

### `get(key?, opts?)` - Find Existing Actor

Returns a handle to an existing actor or `null` if it doesn't exist:

```typescript
// Get existing actor by key
const handle = client.myActor.get(["actor-id"]);

if (handle)  else 
```

### `getOrCreate(key?, opts?)` - Find or Create Actor

Returns a handle to an existing actor or creates a new one if it doesn't exist:

```typescript
// Get or create actor (synchronous)
const counter = client.counter.getOrCreate(["my-counter"]);

// With initialization input
const game = client.game.getOrCreate(["game-123"], 
});

// Call actions immediately
const count = await counter.increment(5);
```

`get()` and `getOrCreate()` are synchronous and return immediately. The actor is created lazily when you first call an action.

### `create(key?, opts?)` - Create New Actor

Explicitly creates a new actor instance, failing if one already exists:

```typescript
// Create new actor (async)
const newGame = await client.game.create(["game-456"], 
});

// Actor is guaranteed to be newly created
await newGame.initialize();
```

### `getForId(id, opts?)` - Find by Internal ID

Connect to an actor using its internal system ID:

```typescript
// Connect by internal ID
const actorId = "55425f42-82f8-451f-82c1-6227c83c9372";
const actor = client.myActor.getForId(actorId);

await actor.performAction();
```

Prefer using keys over internal IDs for actor discovery. IDs are primarily for debugging and advanced use cases.

## `ActorHandle`

An `ActorHandle` represents a reference to an actor instance and provides methods for calling actions and establishing connections. You get an `ActorHandle` from the `ActorClient` methods like `get()`, `getOrCreate()`, and `create()`.

### Calling Actions

You can call actions directly on an `ActorHandle`:

```typescript
const counter = client.counter.getOrCreate(["my-counter"]);

// Call actions directly
const count = await counter.increment(5);
const currentValue = await counter.getCount();
await counter.reset();
```

Actions called on an `ActorHandle` are stateless - each call is independent and doesn't maintain a persistent connection to the actor.

### `fetch(input, init?)` - Raw HTTP Requests

Make direct HTTP requests to the actor's `onFetch` handler:

```typescript
const actor = client.myActor.getOrCreate(["key"]);

// GET request
const response = await actor.fetch("/api/hello", );
const data = await response.json();

// POST request with body
const postResponse = await actor.fetch("/api/echo", ,
  body: JSON.stringify()
});

// Can also pass a Request object
const request = new Request("/api/data", );
const requestResponse = await actor.fetch(request);
```

See [Fetch & WebSocket Handler](/docs/actors/fetch-and-websocket-handler) documentation for more information.

For most use cases, actions provide a higher-level API that's easier to work with than raw HTTP handlers.

### `websocket(path?, protocols?)` - Raw WebSocket Connections

Create direct WebSocket connections to the actor's `onWebSocket` handler:

```typescript
const actor = client.myActor.getOrCreate(["key"]);

// Basic WebSocket connection
const ws = await actor.websocket();
ws.addEventListener("message", (event) => );
ws.send("Hello WebSocket!");

// WebSocket with custom path
const streamWs = await actor.websocket("/stream");

// WebSocket with protocols
const protocolWs = await actor.websocket("/", ["chat", "v1"]);
```

See [Fetch & WebSocket Handler](/docs/actors/fetch-and-websocket-handler) documentation for more information.

For most use cases, actions & events provide a higher-level API that's easier to work with than raw HTTP handlers.

### `connect(params?)` - Establish Stateful Connection

To open a stateful connection using `ActorConn`, call `.connect()`:

```typescript
const counter = client.counter.getOrCreate(["live-counter"]);
const connection = counter.connect();

// Listen for events
connection.on("countChanged", (newCount: number) => );

// Call actions through the connection
const result = await connection.increment(1);

// Clean up when done
await connection.dispose();
```

## `ActorConn`

Real-time connections enable bidirectional communication between clients and actors through persistent connections. Rivet automatically negotiates between WebSocket (preferred for full duplex) and Server-Sent Events (SSE) as a fallback for restrictive environments.

For more information on connections, see the [connections documentation](/docs/actors/connections). For more information on handling events, see the [events documentation](/docs/actors/events).

### Calling Actions

You can also call actions through an `ActorConn`, just like with an `ActorHandle`:

```typescript
const connection = counter.connect();

// Call actions through the connection
const count = await connection.increment(5);
const currentValue = await connection.getCount();
```

### Reconnections

Connections automatically handle network failures with built-in reconnection logic:

- **Exponential backoff**: Retry delays increase progressively to avoid overwhelming the server
- **Action queuing**: Actions called while disconnected are queued and sent once reconnected
- **Event resubscription**: Event listeners are automatically restored on reconnection

### `on(eventName, callback)` - Listen for Events

Listen for events from the actor:

```typescript
// Listen for chat messages
connection.on("messageReceived", (message) => : $`);
});

// Listen for game state updates
connection.on("gameStateChanged", (gameState) => );

// Listen for player events
connection.on("playerJoined", (player) =>  joined the game`);
});
```

### `once(eventName, callback)` - Listen Once

Listen for an event only once:

```typescript
// Wait for game to start
connection.once("gameStarted", () => );
```

### `dispose()` - Clean Up Connection

Always dispose of connections when finished to free up resources:

```typescript
const connection = actor.connect();

try  finally 

// Or with automatic cleanup in React/frameworks
useEffect(() => ;
}, []);
```

**Important:** Disposing a connection:
- Closes the underlying WebSocket or SSE connection
- Removes all event listeners
- Cancels any pending reconnection attempts
- Prevents memory leaks in long-running applications

## Authentication

### Connection Parameters

Pass authentication data when connecting to actors:

```typescript
// With connection parameters
const chat = client.chatRoom.getOrCreate(["general"], 
});

const connection = chat.connect();

// Or for action calls
const result = await chat.sendMessage("Hello world!");
```

### onAuth Hook Validation

Actors can validate authentication using the `onAuth` hook:

```typescript
const protectedActor = actor( = opts;
    
    // Extract token from params or headers
    const token = params.authToken || req.headers.get("Authorization");
    
    if (!token) );
    }
    
    // Validate and return user data
    const user = await validateJWT(token);
    
    // Check permissions based on what the client is trying to do
    if (intents.has("create") && user.role !== "admin") );
    }
    
    return ;
  },
  
  actions:  = c.conn.auth;
      
      if (role !== "admin") );
      }
      
      return `Hello admin $`;
    }
  }
});
```

Learn more about [authentication patterns](/docs/general/authentication).

## Type Safety

Rivet provides end-to-end type safety between clients and actors:

### Action Type Safety

TypeScript validates action signatures and return types:

```typescript
// TypeScript knows the action signatures
const counter = client.counter.getOrCreate(["my-counter"]);

const count: number = await counter.increment(5);   // âœ“ Correct
const invalid = await counter.increment("5");       // âœ— Type error

// IDE autocomplete shows available actions
counter./*  */
```

### Client Type Safety

Import types from your registry for full type safety:

```typescript
// Client is fully typed
const client = createClient("http://localhost:8080");

// IDE provides autocomplete for all actors
client./*  */
```

## Best Practices

### `ActorHandle` (Stateless) vs `ActorConn` (Stateful) Clients

**Use `ActorHandle` (Stateless) For:**
- Simple request-response operations
- One-off operations  
- Server-side integration

```typescript
// Good for simple operations
const result = await counter.increment(1);
const status = await server.getStatus();
```

**Use `ActorConn` (Stateful) Connections For:**
- Real-time updates needed
- Event-driven interactions
- Long-lived client sessions

```typescript
// Good for real-time features
const connection = chatRoom.connect();
connection.on("messageReceived", updateUI);
await connection.sendMessage("Hello!");
```

### Resource Management

Always clean up connections when finished:

```typescript
// Manual cleanup
const connection = actor.connect();
try  finally 
```

### Error Handling

Handle connection errors using the `.onError()` method:

```typescript }
const connection = actor.connect();

connection.onError((error) =>  else if (error.code === 'ACTOR_NOT_FOUND') 
});
```

```tsx }
function ConnectionErrorHandler() );

  useEffect(() => , 5000);
    });

    // Clean up error handler when component unmounts
    return unsubscribe;
  }, [actor.connection]);

  // ...rest of component...
}
```

### Execute Actions in Parallel

You can execute batch requests in parallel:

```typescript
// Batch multiple operations through a connection
const connection = actor.connect();
await Promise.all([
  connection.operation1(),
  connection.operation2(),
  connection.operation3(),
]);

// Use getOrCreate for actors you expect to exist
const existing = client.counter.getOrCreate(["known-counter"]);

// Use create only when you need a fresh instance
const fresh = await client.counter.create(["new-counter"]);
```

However, it's recommended to move this logic to run within the actor instead of the client if executing multiple actions is a common pattern.
## Communicating Between Actors

# Communicating Between Actors

Learn how actors can call other actors and share data

Actors can communicate with each other using the server-side actor client, enabling complex workflows and data sharing between different actor instances.

We recommend reading the [clients documentation](/docs/actors/clients) first. This guide focuses specifically on communication between actors.

## Using the Server-Side Actor Client

The server-side actor client allows actors to call other actors within the same registry. Access it via `c.client()` in your actor context:

```typescript
const orderProcessor = actor(,
  
  actions: );
      
      return ;
    }
  }
});
```

## Use Cases and Patterns

### Actor Orchestration

Use a coordinator actor to manage complex workflows:

```typescript
const workflowActor = actor(,
  
  actions: );
      return result;
    }
  }
});
```

### Data Aggregation

Collect data from multiple actors:

```typescript
const analyticsActor = actor(,
  
  actions: ,
        generatedAt: Date.now()
      };
      
      c.state.reports.push(report);
      return report;
    }
  }
});
```

### Event-Driven Architecture

Use connections to listen for events from other actors:

```typescript
const auditLogActor = actor(,
  
  actions: );
      });
      
      // Listen for order events
      orderActor.on("orderCompleted", (order) => );
      });
      
      return ;
    }
  }
});
```

### Batch Operations

Process multiple items in parallel:

```typescript
// Process items in parallel
const results = await Promise.all(
  items.map(item => client.processor.getOrCreate([item.type]).process(item))
);
```
## Connections

# Connections

Connections represent client connections to your actor. They provide a way to handle client authentication, manage connection-specific data, and control the connection lifecycle.

## Parameters

When clients connect to an actor, they can pass connection parameters that are handled during the connection process.

For example:

```typescript }
const client = createClient("http://localhost:8080");
const gameRoom = await client.gameRoom.get(
});
```

```typescript }
const gameRoom = actor(,
  
  // Handle connection setup
  createConnState: (c, ) => 
    
    // Create connection state
    return ;
  },
  
  actions: 
});
```

## Connection State

There are two ways to define an actor's connection state:

		Define connection state as a constant value:

		```typescript
		const chatRoom = actor(,
		  
		  // Define default connection state as a constant
		  connState: ,
		  
		  onConnect: (c) => ,
		  
		  actions: 
		});
		```

		This value will be cloned for every new connection using `structuredClone`.

		Create connection state dynamically with a function called for each connection:

		```typescript
		const chatRoom = actor(,
		  
		  // Create connection state dynamically
		  createConnState: (c) => ;
		  },
		  
		  actions: );
		      c.broadcast("newMessage", );
		    }
		  }
		});
		```

## Connection Lifecycle Hooks

The connection lifecycle has several hooks:

- `onBeforeConnect`: Called before a client connects, returns the connection state
- `onConnect`: Called when a client successfully connects
- `onDisconnect`: Called when a client disconnects

See the documentation on [Actor Lifecycle](/docs/actors/lifecycle) for more details.

## Connection List

All active connections can be accessed through the context object's `conns` property. This is an array of all current connections.

This is frequently used with `conn.send(name, event)` to send messages directly to clients.

For example:

```typescript
const chatRoom = actor( },
  
  actions: );
      }
    }
  }
});
```

## Disconnecting clients

Connections can be disconnected from within an action:

```typescript
const secureRoom = actor(,
  
  actions: 
    }
  }
});
```

If you need to wait for the disconnection to complete, you can use `await`:

```typescript
await c.conn.disconnect('Too many requests');
```

This ensures the underlying network connections close cleanly before continuing.

## Connection Error Handling

Handle connection errors using the `.onError()` method:

```typescript }
const connection = actor.connect();

connection.onError((error) =>  else if (error.code === 'ACTOR_NOT_FOUND') 
});
```

```tsx }
function ConnectionErrorHandler() );

  useEffect(() => , 5000);
    });

    // Clean up error handler when component unmounts
    return unsubscribe;
  }, [actor.connection]);

  // ...rest of component...
}
```

## Offline & Auto-Reconnection

See [client documentation](/docs/actors/communicating-with-actors) for details on reconnection behavior.
## Ephemeral Variables

# Ephemeral Variables

In addition to persisted state, Rivet provides a way to store ephemeral data that is not saved to permanent storage using `vars`. This is useful for temporary data that only needs to exist while the actor is running or data that cannot be serialized.

`vars` is designed to complement `state`, not replace it. Most actors should use both: `state` for critical business data and `vars` for ephemeral or non-serializable data.

## Initializing Variables

There are two ways to define an actor's initial vars:

Define an actor vars as a constant value:

```typescript
// Define vars as a constant
const counter = actor(,
  
  // Define ephemeral variables
  vars: ,
  
  actions: 
});
```

This value will be cloned for every new actor using `structuredClone`.

Create actor state dynamically on each actors' start:

```typescript
// Define vars with initialization logic
const counter = actor(,
  
  // Define vars using a creation function
  createVars: () => ;
  },
  
  actions: 
});
```

## Using Variables

Vars can be accessed and modified through the context object with `c.vars`:

```typescript
const counter = actor(,
  
  // Create ephemeral objects that won't be serialized
  createVars: () => `);
    });
    
    return ;
  },
  
  actions: 
  }
});
```

## When to Use `vars` vs `state`

In practice, most actors will use both: `state` for critical business data and `vars` for ephemeral or non-serializable data.

Use `vars` when:

- You need to store temporary data that doesn't need to survive restarts
- You need to maintain runtime-only references that can't be serialized (database connections, event emitters, class instances, etc.)

Use `state` when:

- The data must be preserved across actor sleeps, restarts, updates, or crashes
- The information is essential to the actor's core functionality and business logic
## Events

# Events

Events enable real-time communication from actors to clients. While clients use actions to send data to actors, events allow actors to push updates to connected clients instantly.

Events work through persistent connections such as WebSocket or SSE.

## Publishing Events from Actors

### Broadcasting to All Clients

Use `c.broadcast(eventName, data)` to send events to all connected clients:

```typescript
const chatRoom = actor(,
  
  actions: ;
      
      c.state.messages.push(message);
      
      // Broadcast to all connected clients
      c.broadcast('messageReceived', message);
      
      return message;
    },
  }
});
```

### Sending to Specific Connections

Send events to individual connections using `conn.send(eventName, data)`:

```typescript
const gameRoom = actor( as Record
  },
  
  createConnState: (c, ) => (),
  
  actions: );
      } else 
    }
  }
});
```

Send events to all connections except the sender:

```typescript
const gameRoom = actor( as Record
  },
  
  createConnState: (c, ) => (),
  
  actions: ) => );
          }
        }
      }
    }
  }
});
```

## Subscribing to Events from Clients

Clients must establish a connection to receive events from actors. Use `.connect()` to create a persistent connection, then listen for events.

### Basic Event Subscription

Use `connection.on(eventName, callback)` to listen for events:

```typescript }
const client = createClient("http://localhost:8080");

// Get actor handle and establish connection
const chatRoom = client.chatRoom.getOrCreate(["general"]);
const connection = chatRoom.connect();

// Listen for events
connection.on('messageReceived', (message) => : $`);
  displayMessage(message);
});

// Call actions through the connection
await connection.sendMessage("user-123", "Hello everyone!");
```

```tsx }
function ChatRoom() );

  // Listen for events
  chatRoom.useEvent("messageReceived", (message) => );

  // ...rest of component...
}
```

### One-time Event Listeners

Use `connection.once(eventName, callback)` for events that should only trigger once:

```typescript }
const gameRoom = client.gameRoom.getOrCreate(["room-456"]);
const connection = gameRoom.connect();

// Listen for game start (only once)
connection.once('gameStarted', () => );
```

```tsx }
function GameLobby() 
  });

  // Listen for game start (only once)
  useEffect(() => ;

    gameRoom.connection.once('gameStarted', handleGameStart);
  }, [gameRoom.connection]);

  // ...rest of component...
}
```

### Removing Event Listeners

Use the callback returned from `.on()` to remove event listeners:

```typescript }
// Add listener
const unsubscribe = connection.on('messageReceived', (message) => );

// Remove listener
unsubscribe();
```

```tsx }
function ConditionalListener() );

  useEffect(() => : $`]);
    });

    // Cleanup - remove listener when component unmounts or listening stops
    return () => ;
  }, [chatRoom.connection, isListening]);

  // ...rest of component...
}
```

## More About Connections

For more details on actor connections, including connection lifecycle, authentication, and advanced connection patterns, see the [Connections documentation](/docs/actors/connections).
## External SQL Database

# External SQL Database

While actors can serve as a complete database solution, they can also complement your existing databases. For example, you might use actors to handle frequently-changing data that needs real-time access, while keeping less frequently accessed data in your traditional database.

Actors can be used with common SQL databases, such as PostgreSQL and MySQL.

## Libraries

To facilitate interaction with SQL databases, you can use either ORM libraries or raw SQL drivers. Each has its own use cases and benefits:

-   **ORM Libraries**: Type-safe and easy way to interact with your database

    -   [Drizzle](https://orm.drizzle.team/)
    -   [Prisma](https://www.prisma.io/)

-   **Raw SQL Drivers**: Direct access to the database for more flexibility

    -   [PostgreSQL](https://node-postgres.com/)
    -   [MySQL](https://github.com/mysqljs/mysql)

## Hosting Providers

There are several options for places to host your SQL database:

-   [Supabase](https://supabase.com/)
-   [Neon](https://neon.tech/)
-   [PlanetScale](https://planetscale.com/)
-   [AWS RDS](https://aws.amazon.com/rds/)
-   [Google Cloud SQL](https://cloud.google.com/sql)

## Examples

### Basic PostgreSQL Connection

Here's a basic example of a user actor that creates a database record on start and tracks request counts:

```typescript }
interface ActorInput 

// Create a database connection pool
const pool = new Pool();

// Create the user actor
const userActor = actor() => (),
  
  // Insert user into database when actor starts
  onStart: async (c, opts) => ,
  
  actions: ;
    },
    
    // Get user data
    getUser: async (c) => ;
    }
  }
});

const registry = setup(,
});
```

```typescript }
const client = createClient("http://localhost:8080");

// Create user
const alice = await client.userActor.create("alice", 
});

alice.updateUser("alice2@example.com");

const userData = await alice.getUser();
console.log("User data:", userData);

// Create another user
const bob = await client.userActor.create("bob", 
});
const bobData = await bob.getUser();
```

### Using Drizzle ORM

Here's the same user actor pattern using Drizzle ORM for more type-safe database operations:

```typescript }
interface ActorInput 

// Define your schema
const users = pgTable("users", );

// Create a database connection
const pool = new Pool();

// Initialize Drizzle with the pool
const db = drizzle(pool);

// Create the user actor
const userActor = actor() => (),
  
  // Insert user into database when actor starts
  onStart: async (c, opts) => );
  },
  
  actions: )
        .where(eq(users.username, c.state.username));
      
      return ;
    },
    
    // Get user data
    getUser: async (c) => ;
    }
  }
});

const registry = setup(,
});
```

```typescript }
const client = createClient("http://localhost:8080");

// Create user
const alice = await client.userActor.create("alice", 
});

alice.updateUser("alice2@example.com");

const userData = await alice.getUser();
console.log("User data:", userData);

// Create another user
const bob = await client.userActor.create("bob", 
});
const bobData = await bob.getUser();
```
## Fetch and WebSocket Handler

# Fetch and WebSocket Handler

Actors can handle HTTP requests and WebSocket connections through the `onFetch` and `onWebSocket` handlers.

For most use cases, [actions](/docs/actors/actions) and [events](/docs/actors/events) provide high-level connection handling that's easier to work with. However, raw handlers are required when implementing custom use cases or integrating external libraries that need direct access to the underlying HTTP `Request`/`Response` objects or WebSocket connections.

## Defining Handlers

### `onFetch(c, request, )`

The `onFetch` handler processes HTTP requests sent to your actor. It receives the actor context and a standard `Request` object.

Complete example showing how to implement raw HTTP request handling in actors

```typescript
const httpActor = actor(,
    actions: ,
    onFetch(ctx, request) ), ,
            });
        }

        if (url.pathname === "/api/echo" && request.method === "POST") );
        }

        // Return 404 for unhandled paths
        return new Response("Not Found", );
    },
});
```

```typescript
function buildRouter(ctx: ActorContext) );
    });

    app.post("/api/echo", async (c) => );

    app.get("/api/stats", (c) => );
    });

    return app;
}

const honoActor = actor(,
    createVars(ctx) ;
    },
    actions: ,
    async onFetch(ctx, request) ,
});
```

	WebSocket upgrades are not currently supported in `onFetch`. Use `onWebSocket` instead.

	`onFetch` can be used to expose Server-Sent Events from Rivet Actors.

### `onWebSocket(c, websocket, )`

The `onWebSocket` handler manages WebSocket connections. It receives the actor context, a `WebSocket` object, and the initial `Request`.

Complete example showing how to implement raw WebSocket connection handling in actors

```typescript
const websocketActor = actor(,
    actions: ,
    onWebSocket(ctx, websocket) ));

        websocket.addEventListener("message", (event) => );
    },
});
```

## Accessing Your Handlers

There are three ways to access your actor's fetch and WebSocket handlers:

### Option A: From Backend via RivetKit Client

You can use the RivetKit client's built-in methods for raw HTTP and WebSocket access:

```typescript
const client = createClient("http://localhost:8080");

// HTTP requests using .fetch() method
const actor = client.myActor.getOrCreate(["key"]);
const response = await actor.fetch("/api/hello", );
const data = await response.json();

// POST request with JSON body
const postResponse = await actor.fetch("/api/echo", ,
    body: JSON.stringify(),
});
```

```typescript
const client = createClient("http://localhost:8080");

// WebSocket connections using .websocket() method
const actor = client.myActor.getOrCreate(["key"]);
const ws = await actor.websocket("/custom/path");

// Listen for messages
ws.addEventListener("message", (event) =>  else if (message.type === "echo")  else if (message.type === "pong") 
});

// Send messages
ws.send(JSON.stringify());

// Send ping
ws.send(JSON.stringify());
```

For more advanced use cases, you can forward requests to actor handlers from your server:

```typescript
const  = registry.createServer();

const app = new Hono();

// Forward requests to actor's fetch handler
app.all("/forward/:name/*", async (c) => `, "");
    const url = new URL(truncatedPath, c.req.url);
    const newRequest = new Request(url, c.req.raw);
    
    // Forward to actor's fetch handler
    const actor = client.counter.getOrCreate(name);
    const response = await actor.fetch(truncatedPath, newRequest);
    
    return response;
});

serve(app);
```

```typescript
const  = registry.createServer();

const app = new Hono();

// Forward WebSocket connections to actor's WebSocket handler
app.get("/ws/:name", upgradeWebSocket(async (c) => );

            actorWs.addEventListener("close", () => );
        },
        onMessage: (evt, ws) => ,
        onClose: (evt, ws) => ,
    };
}));

serve(app);
```

### Option B: From Frontend with RivetKit Client

Use the RivetKit client to make direct HTTP requests or WebSocket connections:

```typescript
const client = createClient("http://localhost:8080");

// HTTP requests
const actor = client.myActor.getOrCreate(["key"]);
const response = await actor.fetch("/api/hello", );
const data = await response.json();
console.log(data); // 

// POST request with data
const postResponse = await actor.fetch("/api/echo", ,
    body: JSON.stringify(),
});

// Handle response
if (postResponse.ok)  else 
```

```typescript
const client = createClient("http://localhost:8080");

// WebSocket connections
const actor = client.myActor.getOrCreate(["key"]);
const ws = await actor.websocket("/");

// Listen for messages
ws.addEventListener("message", (event) => );
            break;
            
        case "echo":
            console.log("Echo received:", message.data);
            displayMessage(message.data);
            break;
            
        case "pong":
            console.log("Pong received, latency:", Date.now() - message.timestamp);
            break;
            
        case "error":
            console.error("Error:", message.message);
            break;
    }
});

// Send messages
function sendMessage(text) ));
}

// Ping for latency testing
function ping() ));
}

// Handle connection errors
ws.addEventListener("error", (event) => );

ws.addEventListener("close", () => );
```

	The `.websocket()` method returns a barebones WebSocket. Unlike [actor connections](/docs/actors/connections), it does not provide automatic reconnection logic. You must implement reconnection logic yourself if needed.

### Option C: From Frontend via Direct RivetKit Router Access

You can access your actor handlers directly through the mounted RivetKit router. The router automatically handles the required headers for authentication and routing.

For HTTP requests, the router expects these headers:
- `X-RivetKit-Actor-Query`: JSON-encoded actor query
- `X-RivetKit-Encoding`: Encoding type (usually "json")
- `X-RivetKit-Conn-Params`: JSON-encoded connection parameters (optional)

```typescript
// Direct HTTP request to actor
const response = await fetch("http://localhost:8080/registry/actors/myActor/raw/http/api/hello", 
        }),
        "X-RivetKit-Encoding": "json",
        "X-RivetKit-Conn-Params": JSON.stringify()
    }
});

const data = await response.json();
console.log(data); // 

// POST request with data
const postResponse = await fetch("http://localhost:8080/registry/actors/myActor/raw/http/api/echo", 
        }),
        "X-RivetKit-Encoding": "json",
        "X-RivetKit-Conn-Params": JSON.stringify(),
        "Content-Type": "application/json"
    },
    body: JSON.stringify()
});

// Handle response
if (postResponse.ok)  else 
```

For WebSocket connections, authentication data is passed via WebSocket subprotocols:

```typescript
// Direct WebSocket connection to actor
const protocols = [
    `query.$
    }))}`,
    `encoding.json`,
    `conn_params.$))}`
];

const ws = new WebSocket("ws://localhost:8080/registry/actors/myActor/ws/", protocols);

// Listen for messages
ws.addEventListener("message", (event) => );
            
            // Send initial message
            ws.send(JSON.stringify());
            break;
            
        case "echo":
            console.log("Echo received:", message.data);
            break;
            
        case "pong":
            console.log("Pong received, latency:", Date.now() - message.timestamp);
            break;
            
        case "error":
            console.error("WebSocket error:", message.message);
            break;
    }
});

// Send ping for latency testing
function sendPing() ));
}

// Handle connection events
ws.addEventListener("open", () => );

ws.addEventListener("error", (event) => );

ws.addEventListener("close", (event) => );
```

	For Cloudflare Workers, you must include `"rivetkit"` as a protocol when using raw WebSockets:
	
	```typescript
	const protocols = [
	    "rivetkit", // Required for Cloudflare Workers
	    `query.$
	    }))}`,
	    `encoding.json`
	];
	```

## Authentication

If you are using the external client, authentication is handled through the `onAuth` handler. The `onAuth` handler is executed on the server before the request is sent to the actor, reducing resource load on the actor by filtering out unauthorized requests early.

If you are using the server-side client, then authentication is skipped by default.

See the [authentication documentation](/docs/general/authentication) for detailed information on implementing authentication patterns.

## State Saves

State changes in `onFetch` and `onWebSocket` handlers are automatically saved after the handler finishes executing.

For `onWebSocket` handlers specifically, you'll need to manually save state using `c.saveState()` while the WebSocket connection is open if you want state changes to be persisted immediately. This is because WebSocket connections can remain open for extended periods, and state changes made during event handlers (like `message` events) won't be automatically saved until the connection closes.

```typescript
const websocketActor = actor(,
    actions: ,
    onWebSocket(ctx, websocket) ));
        });
    },
});
```

For more details on state management, see [State](/docs/actors/state).

## W3C Compliance

It's not possible to use the global `fetch` method or global WebSocket class to connect to an actor. This is because actors do not have traditional network interfaces to communicate with.

However, the `Request`, `Response`, and `WebSocket` types used with `.fetch()` and `.websocket()` comply with the W3C specification and will work wherever you pass them.
## Helper Types

# Helper Types

Rivet provides several TypeScript helper types to make it easier to work with actors in a type-safe way.

## `Context` Types

When working with actors, you often need to access the context object. Rivet provides helper types to extract the context types from actor definitions.

### `ActorContextOf`

Extracts the full actor context type from an actor definition. This is the type of the context object (`c`) available in [lifecycle hooks](/docs/actors/lifecycle) and in [actions](/docs/actors/actions).

```typescript
const chatRoom = actor(,
  actions: ,
  actions: 
  }
});

// Now you can use this type elsewhere
function logMessage(context: ActorContextOf, message: string) );
}
```

### `ActionContextOf`

Extracts the action context type from an actor definition. This is the type of the context object (`c`) available in [actions](/docs/actors/actions). This cannot be used in [lifecycle hooks](/docs/actors/lifecycle).

```typescript
const counterWithProcessing = actor(,
  actions: 
  }
});

function processCounterAction(context: ActionContextOf) 
```
## Overview

# Overview

Actors for long-lived processes with durable state, realtime, and hibernate when not in use.

## Quickstart

  Set up actors with Node.js, Bun, and web frameworks

  Build real-time React applications with actors

## Features

- **Long-Lived, Stateful Compute**: Each unit of compute is like a tiny server that remembers things between requests â€“ no need to re-fetch data from a database or worry about timeouts. Like AWS Lambda, but with memory and no timeouts.

- **Blazing-Fast Reads & Writes**: State is stored on the same machine as your compute, so reads and writes are ultra-fast. No database round trips, no latency spikes.

- **Realtime, Made Simple**: Update state and broadcast changes in realtime with WebSockets or SSE. No external pub/sub systems, no polling â€“ just built-in low-latency events.

- **Store Data Near Your Users**: Your state lives close to your users on the edge â€“ not in a faraway data center â€“ so every interaction feels instant. (Not all platforms supported.)

- **Infinitely Scalable**: Automatically scale from zero to millions of concurrent actors. Pay only for what you use with instant scaling and no cold starts.

- **Fault Tolerant**: Built-in error handling and recovery. Actors automatically restart on failure while preserving state integrity and continuing operations.

- **Type Safety**: End-to-end TypeScript safety between clients and actors with full type inference and compile-time checking.

## Use Cases

Actors are perfect for applications that need persistent state and real-time updates:

- **AI & Automation**
  - **AI agents**: Stateful AI assistants with conversation history
  - **AI sandbox orchestration**: Actors can orchestrate logic running inside of agents' sandboxes
  - **Durable workflows**: Long-running business processes with state persistence and recovery

- **Real-time Communication**
  - **Chat rooms**: Real-time messaging with message history and user presence
  - **Collaborative documents**: Multiple users editing documents simultaneously (Yjs integration)
  - **Multiplayer games**: Game state management with real-time updates
  - **Live events**: Broadcasting updates to many participants

- **Data & Synchronization**
  - **Local-first sync**: Offline-first applications with server synchronization
  - **Multi-tenant databases**: Isolated data stores for each user or tenant
  - **Scheduling**: Time-based task execution with persistent state

- **Infrastructure**
  - **Rate limiting**: Distributed rate limiting with persistent counters
  - **Stream processing**: Real-time data processing with persistent state

## Core Concepts

### State Management

Actors maintain persistent state that survives restarts, crashes, and deployments. State can be defined as a constant or created dynamically:

```typescript
const counter = actor(,
  
  actions: ,
    
    getCount: (c) => c.state.count,
  }
});
```

Learn more about [state management](/docs/actors/state).

### Actions

Actions are the primary way to interact with actors. They're type-safe functions that can modify state and communicate with clients:

```typescript
const chatRoom = actor(,
  
  actions: ;
      c.state.messages.push(message);
      c.broadcast("newMessage", message);
      return message;
    },
    
    getMessages: (c) => c.state.messages
  }
});
```

Actions can be called from your backend, your clients, or other actors:

```typescript
const room = client.chatRoom.getOrCreate(["general"]);
const message = await room.sendMessage("user-123", "Hello everyone!");
```

Learn more about [actions](/docs/actors/actions) and [communicating with actors](/docs/actors/communicating-with-actors).

### Real-time Communication & Events

Actors support real-time bidirectional communication through WebSocket and SSE connections. Clients can establish persistent connections to receive live updates.

For example, to send events to all connected clients:

```typescript
const liveAuction = actor(,
  
  actions: );
      return amount;
    }
  }
});
```

Clients connect and listen for real-time updates:

```typescript
const auction = client.liveAuction.getOrCreate(["auction-123"]);
const connection = auction.connect();

connection.on("newBid", (data) => `);
});

await auction.placeBid(150);
```

Learn more about [events](/docs/actors/events) and [client communication](/docs/actors/communicating-with-actors).

### Scheduling & Lifecycle

Actors support scheduled tasks and lifecycle management:

```typescript
const reminder = actor(,
  
  actions: ,
    
    sendReminder: (c) => );
    }
  }
});
```

Learn more about [actor lifecycle](/docs/actors/lifecycle).

### Type Safety

Rivet provides end-to-end TypeScript safety between clients and actors:

```typescript Actor
const userManager = actor( as Record },
  
  actions: ;
      return ;
    },
    
    getUser: (c, userId: string) => c.state.users[userId]
  }
});
```

```typescript Client
const manager = client.userManager.getOrCreate(["default"]);

const user = await manager.createUser("Alice");
// Type: 

const foundUser = await manager.getUser(user.userId);
// Type:  | undefined
```

## Frequently Asked Questions

        Some software makes sense to separate â€“ e.g., for data lakes or highly relational data. But at the end of the day, data has to be partitioned somewhere at some point.

        Usually "faster" databases like Cassandra, DynamoDB, or Vitess make consistency tradeoffs to get better performance. Stateful serverless forces you to think about how your data is sharded for better performance, better scalability, and less consistency footguns.

        See [Sharing and Joining State](/docs/actors/sharing-and-joining-state) for detailed strategies on combining data from multiple actors.

        OLAP, data lakes, graph databases, and highly relational data are currently not ideal use cases for the actor model.

        Yes, but only in the same way that storing data in a single database row creates a bottleneck.

		Just like a single database row can cause contention when multiple clients try to read and write the same data, a single actor can become a bottleneck if too many requests target it.

		The solution is the same: shard your data across multiple actors to distribute the load and scale seamlessly.

		However, actors handle much higher throughput than traditional database rows because they keep data in memory, making read and write operations significantly faster.
## Input Parameters

# Input Parameters

Pass initialization data to actors when creating instances

Actors can receive input parameters when created, allowing for flexible initialization and configuration. Input is passed during actor creation and is available in lifecycle hooks.

## Passing Input to Actors

Input is provided when creating actor instances using the `input` property:

```typescript
// Client side - create with input
const game = await client.game.create(["game-123"], 
});

// getOrCreate can also accept input (used only if creating)
const gameHandle = client.game.getOrCreate(["game-456"], 
});
```

## Accessing Input in Lifecycle Hooks

Input is available in lifecycle hooks via the `opts.input` parameter:

```typescript
const chatRoom = actor(,
    messages: [],
  }),
  
  onCreate: (c, opts) => `);
    
    // Setup external services based on input
    if (opts.input?.isPrivate) 
  },
  
  actions: ),
  },
});
```

## Input Validation

You can validate input parameters in the `createState` or `onCreate` hooks:

```typescript
const GameInputSchema = z.object();

const game = actor(,
      gameState: "waiting",
    };
  },
  
  actions: ),
  },
});
```

## Input vs Connection Parameters

Input parameters are different from connection parameters:

- **Input**:
  - Passed when creating the actor instance
  - Use for actor-wide configuration
  - Available in lifecycle hooks
- **Connection parameters**:
  - Passed when connecting to an existing actor
  - Used for connection-specific configuration
  - Available in connection hooks

```typescript
// Actor creation with input
const room = await client.chatRoom.create(["room-123"], ,
  params: 
});
```

## Input Best Practices

### Use Type Safety

Define input types to ensure type safety:

```typescript
interface GameInput 

const game = actor() => (),
  
  actions: ,
});
```

### Store Input in State

If you need to access input data in actions, store it in the actor's state:

```typescript
const game = actor(,
    // Runtime state
    players: ,
    gameState: "waiting",
  }),
  
  actions: ,
  },
});
```
## Actor Keys

# Actor Keys

Actor keys uniquely identify actor instances within each actor type. Keys are used for addressing which specific actor to communicate with.

## Key Format

Actor keys can be either a string or an array of strings:

```typescript
// String key
const counter = client.counter.getOrCreate("my-counter");

// Array key (compound key)
const chatRoom = client.chatRoom.getOrCreate(["room", "general"]);
```

### Compound Keys & User Data

Array keys are useful when you need compound keys with user-provided data. Using arrays makes adding user data safe by preventing key injection attacks:

```typescript
// User-specific chat rooms
const userRoom = client.chatRoom.getOrCreate(["user", userId, "private"]);

// Game rooms by region and difficulty
const gameRoom = client.gameRoom.getOrCreate(["us-west", "hard", gameId]);

// Multi-tenant resources
const workspace = client.workspace.getOrCreate(["tenant", tenantId, workspaceId]);
```

This allows you to create hierarchical addressing schemes and organize actors by multiple dimensions.

Don't build keys using string interpolation like `"foo:$:bar"` when `userId` contains user data. If a user provides a value containing the delimiter (`:` in this example), it can break your key structure and cause key injection attacks.

### Omitting Keys

You can create actors without specifying a key in situations where there is a singleton actor (i.e. only one actor of a given type). For example:

```typescript
// Get the singleton session
const globalActor = client.globalActor.getOrCreate();
```

This pattern should be avoided, since a singleton actor usually means you have a single actor serving all traffic & your application will not scale. See [scaling documentation](/docs/actors/scaling) for more information.

### Key Uniqueness

Keys are unique within each actor name. Different actor types can use the same key:

```typescript
// These are different actors, same key is fine
const userChat = client.chatRoom.getOrCreate(["user-123"]);
const userProfile = client.userProfile.getOrCreate(["user-123"]);
```

## Accessing Keys in Metadata

Access the actor's key within the actor using the [metadata](/docs/actors/metadata) API:

```typescript }
const chatRoom = actor(
  }
});

const registry = setup(
});
```

```typescript }
const client = createClient("http://localhost:8080");

async function connectToRoom(roomName: string) 

// Usage example
const generalRoom = await connectToRoom("general");
```

## Configuration Examples

### Simple Configuration with Keys

Use keys to provide basic actor configuration:

```typescript }
const userSession = actor(
  }),
  
  actions: 
});

const registry = setup(
});
```

```typescript }
const client = createClient("http://localhost:8080");

// Pass user ID in the key for user-specific actors
const userSession = client.userSession.getOrCreate([userId]);
```

### Complex Configuration with Input

For more complex configuration, use [input parameters](/docs/actors/input):

```typescript }
const client = createClient("http://localhost:8080");

// Create with both key and input
const chatRoom = await client.chatRoom.create(["room", roomName], 
  }
});
```
## Lifecycle

# Lifecycle

Understand actor lifecycle hooks and initialization patterns

Actors follow a well-defined lifecycle with hooks at each stage. Understanding these hooks is essential for proper initialization, state management, and cleanup.

## Lifecycle Hooks

Actor lifecycle hooks are defined as functions in the actor configuration.

### `createState` and `state`

The `createState` function or `state` constant defines the initial state of the actor (see [state documentation](/docs/actors/state)). The `createState` function is called only once when the actor is first created.

### `createVars` and `vars`

The `createVars` function or `vars` constant defines ephemeral variables for the actor (see [state documentation](/docs/actors/state)). These variables are not persisted and are useful for storing runtime-only objects or temporary data.

The `createVars` function can also receive driver-specific context as its second parameter, allowing access to driver capabilities like Rivet KV or Cloudflare Durable Object storage.

```typescript
// Using vars constant
const counter1 = actor(,
  vars: ,
  actions: 
});

// Using createVars function
const counter2 = actor(,
  createVars: () => ;
  },
  actions: 
});

// Access driver-specific context
const exampleActor = actor(,
  // Access driver context in createVars
  createVars: (c, driverCtx) => (),
  actions: 
  }
});
```

### `onCreate`

The `onCreate` hook is called at the same time as `createState`, but unlike `createState`, it doesn't return any value. Use this hook for initialization logic that doesn't affect the initial state.

```typescript
// Using state constant
const counter1 = actor(,
  actions: 
});

// Using createState function
const counter2 = actor(;
  },
  actions: 
});

// Using onCreate
const counter3 = actor(,
  
  // Run initialization logic (logging, external service setup, etc.)
  onCreate: (c, opts) => ,
  
  actions: 
});
```

### `onStart`

This hook is called any time the actor is started (e.g. after restarting, upgrading code, or crashing).

This is called after the actor has been initialized but before any connections are accepted.

Use this hook to set up any resources or start any background tasks, such as `setInterval`.

```typescript
const counter = actor(,
  vars: ,
  
  onStart: (c) => , 10000);
    
    // Store interval ID in vars to clean up later if needed
    c.vars.intervalId = intervalId;
  },
  
  actions: 
    }
  }
});
```

### `onStateChange`

Called whenever the actor's state changes. This is often used to broadcast state updates.

```typescript
const counter = actor(,
  
  onStateChange: (c, newState) => );
  },
  
  actions: 
  }
});
```

### `createConnState` and `connState`

There are two ways to define the initial state for connections:
1. `connState`: Define a constant object that will be used as the initial state for all connections
2. `createConnState`: A function that dynamically creates initial connection state based on connection parameters

### `onBeforeConnect`

The `onBeforeConnect` hook is called whenever a new client connects to the actor. Clients can pass parameters when connecting, accessible via `params`. This hook is used for connection validation and can throw errors to reject connections.

The `onBeforeConnect` hook does NOT return connection state - it's used solely for validation.

```typescript
const chatRoom = actor(,
  
  // Method 1: Use a static default connection state
  connState: ,
  
  // Method 2: Dynamically create connection state
  createConnState: (c, ) => ;
  },
  
  // Validate connections before accepting them
  onBeforeConnect: (c, ) => 
    
    // Authentication is valid, connection will proceed
    // The actual connection state will come from connState or createConnState
  },
  
  actions: 
});
```

Connections cannot interact with the actor until this method completes successfully. Throwing an error will abort the connection. This can be used for authentication - see [Authentication](/docs/general/authentication) for details.

### `onConnect`

Executed after the client has successfully connected.

```typescript
const chatRoom = actor(, messages: [] },
  
  onConnect: (c) => ;
    
    // Broadcast that a user joined
    c.broadcast("userJoined", );
    
    console.log(`User $ connected`);
  },
  
  actions: 
});
```

Messages will not be processed for this actor until this hook succeeds. Errors thrown from this hook will cause the client to disconnect.

### `onDisconnect`

Called when a client disconnects from the actor. Use this to clean up any connection-specific resources.

```typescript
const chatRoom = actor(, messages: [] },
  
  onDisconnect: (c) => 
    
    // Broadcast that a user left
    c.broadcast("userLeft", );
    
    console.log(`User $ disconnected`);
  },
  
  actions: 
});
```

### `onFetch`

The `onFetch` hook handles HTTP requests sent to your actor. It receives the actor context and a standard `Request` object, and should return a `Response` object or `void` to continue default routing.

```typescript
const apiActor = actor(,
  
  onFetch: (c, request) => ), 
      });
    }
    
    // Return void to continue to default routing
    return;
  },
  
  actions: 
});
```

### `onWebSocket`

The `onWebSocket` hook handles WebSocket connections to your actor. It receives the actor context, a `WebSocket` object, and the initial `Request`. Use this to set up WebSocket event listeners and handle real-time communication.

```typescript
const realtimeActor = actor(,
  
  onWebSocket: (c, websocket, request) => ));
    
    // Handle incoming messages
    websocket.addEventListener("message", (event) => ));
      }
    });
    
    // Handle connection close
    websocket.addEventListener("close", () => );
  },
  
  actions: 
});
```

### `onAuth`

The `onAuth` hook is called on the HTTP server before clients can interact with the actor. This hook is required for any public HTTP endpoint access and is used to validate client credentials and return authentication data that will be available on connections.

This hook runs on the HTTP server (not the actor) to reduce load and prevent denial of service attacks against individual actors. Only called for public endpoints - calls to actors from within the backend do not trigger this handler.

```typescript
const secureActor = actor(
    
    const token = authHeader.slice(7);
    
    // Validate token with your auth service
    const user = await validateAuthToken(token);
    if (!user) 
    
    // Return auth data (must be serializable)
    return ;
  },
  
  state:  },
  
  onConnect: (c) =>  with role $ connected`);
    
    c.state.activeUsers[userId] = ;
  },
  
  actions: 
      
      return ;
    }
  }
});
```

### `onBeforeActionResponse`

The `onBeforeActionResponse` hook is called before sending an action response to the client. Use this hook to modify or transform the output of an action before it's sent to the client. This is useful for formatting responses, adding metadata, or applying transformations to the output.

```typescript
const loggingActor = actor(,
  
  onBeforeActionResponse: (c, actionName, args, output) =>  called with args:`, args);
    console.log(`Action $ returned:`, output);
    
    // Add metadata to all responses
    return 
    };
  },
  
  actions: ,
        lastActive: Date.now()
      };
    },
    
    getStats: (c) => ;
    }
  }
});
```

## Destroying Actors

Actors can be shut down gracefully with `c.shutdown()`. Clients will be gracefully disconnected.

```typescript
const temporaryRoom = actor(,
  
  createState: () => (),
  
  onStart: (c) =>  else , timeUntilExpiry);
    }
  },
  
  actions: );
      
      // Shutdown the actor
      c.shutdown();
    }
  }
});
```

This action is permanent and cannot be reverted.

## Using `ActorContext` Type Externally

When extracting logic from lifecycle hooks or actions into external functions, you'll often need to define the type of the context parameter. Rivet provides helper types that make it easy to extract and pass these context types to external functions.

```typescript
const myActor = actor(,
  
  // Use external function in lifecycle hook
  onStart: (c) => logActorStarted(c)
});

// Simple external function with typed context
function logActorStarted(c: ActorContextOf) `);
}
```

See [Helper Types](/docs/actors/helper-types) for more details on using `ActorContextOf`.

## Full Example

```typescript
const counter = actor(
    
    const token = authHeader.slice(7);
    const user = await validateAuthToken(token);
    if (!user) 
    
    return ;
  },
  
  // Initialize state with input
  createState: (c, opts) => (),
  
  // Initialize actor (run setup that doesn't affect initial state)
  onCreate: (c, opts) => " initialized`);
    // Set up external resources, logging, etc.
  },
  
  // Define default connection state
  connState: ,
  
  // Dynamically create connection state based on params
  createConnState: (c, ) => ;
  },
  
  // Lifecycle hooks
  onStart: (c) => " started with count:`, c.state.count);
  },
  
  onStateChange: (c, newState) => );
  },
  
  onBeforeConnect: (c, ) =>  attempting to connect`);
  },
  
  onConnect: (c) =>  connected to "$"`);
  },
  
  onDisconnect: (c) =>  disconnected from "$"`);
  },
  
  // Transform all action responses
  onBeforeActionResponse: (c, actionName, args, output) => 
    };
  },
  
  // Define actions
  actions: ,
    
    reset: (c) => 
      
      c.state.count = 0;
      return c.state.count;
    },
    
    getInfo: (c) => (),
  }
});

default counter;
```
## Metadata

# Metadata

Metadata provides information about the currently running actor.

## Actor ID

Get the unique instance ID of the actor:

```typescript
const actorId = c.actorId;
```

## Actor Name

Get the actor type name:

```typescript
const actorName = c.name;
```

This is useful when you need to know which actor type is running, especially if you have generic utility functions that are shared between different actor implementations.

## Actor Key

Get the actor key used to identify this actor instance:

```typescript
const actorKey = c.key;
```

The key is used to route requests to the correct actor instance and can include parameters passed when creating the actor.

Learn more about using keys for actor addressing and configuration in the [keys documentation](/docs/actors/keys).

## Region

Region can be accessed from the context object via `c.region`.

```typescript
const region = c.region;
```

`c.region` is only supported on Rivet at the moment.

## Example Usage

```typescript }
const chatRoom = actor(,
  
  actions: ;
    }
  }
});

const registry = setup(
});
```

```typescript }
const client = createClient("http://localhost:8080");

// Connect to a chat room
const chatRoom = await client.chatRoom.get("general");

// Get actor metadata
const metadata = await chatRoom.getMetadata();
console.log("Actor metadata:", metadata);
```
## Node.js & Bun Quickstart

# Node.js & Bun Quickstart

Get started with Rivet Actors in Node.js and Bun

```sh
npm install @rivetkit/actor
```

Create a simple counter actor:

```ts }
const counter = actor(,
	actions: ,
		getCount: (c) => c.state.count,
	},
});

const registry = setup(,
});
```

Choose your preferred web framework:

```ts }
// Start Rivet with memory driver (for development)
const  = registry.createServer();

// Setup Hono app
const app = new Hono();

// Example API endpoint
app.post("/increment/:name", async (c) => );
});

// Start server with Rivet
serve(app);
```

```ts }
// Start Rivet
const  = registry.createServer();

// Setup Express app
const app = express();
app.use(express.json());

// Mount Rivet handler
app.use("/registry", handler);

// Example API endpoints
app.post("/increment/:name", async (req, res) =>  = req.params;

      const counter = client.counter.getOrCreate(name);
      const newCount = await counter.increment(1);
      
      res.json();
});

app.listen(8080, () => );
```

```ts }
// Start Rivet
const  = registry.createServer();

// Setup Elysia app
const app = new Elysia()
	.mount("/registry", handler)
	.post("/increment/:name", async () =>  = params;

		const counter = client.counter.getOrCreate(name);
		const newCount = await counter.increment(1);

		return ;
	})
	.listen(8080);

console.log("Server running at http://localhost:8080");
```

The `/registry` endpoint is automatically mounted by Rivet and is required for client communication. When using `serve()` with Hono, this is handled automatically.

```sh }
npx tsx --watch server.ts
```

```sh }
bun --watch server.ts
```

Your server is now running at `http://localhost:8080`

Test your counter actor using HTTP requests:

```ts }
// Increment counter
const response = await fetch("http://localhost:8080/increment/my-counter", );

const result = await response.json();
console.log("Count:", result.count); // 1
```

```sh curl
# Increment counter
curl -X POST http://localhost:8080/increment/my-counter
```

## Configuration Options

### Connect Frontend To The Rivet Actor

Create a type-safe client to connect from your frontend:

```ts }
// Create typed client
const client = createClient("http://localhost:8080");

// Use the counter actor directly
const counter = client.counter.getOrCreate(["my-counter"]);

// Call actions
const count = await counter.increment(3);
console.log("New count:", count);

// Get current state
const currentCount = await counter.getCount();
console.log("Current count:", currentCount);

// Listen to real-time events
const connection = counter.connect();
connection.on("countChanged", (newCount) => );

// Increment through connection
await connection.increment(1);
```

See the [JavaScript client documentation](/clients/javascript) for more information.

```tsx }
const client = createClient("http://localhost:8080");
const  = createRivetKit(client);

function Counter() );

	counter.useEvent("countChanged", (newCount: number) => );

	const increment = async () => ;

	return (
		
			Count: 
			Increment
		
	);
}
```

See the [React documentation](/clients/react) for more information.

```rust }
use rivetkit_client::;
use serde_json::json;

#[tokio::main]
async fn main() -> Result> ", count);
    }).await;
    
    // Call increment action
    let result = counter.action("increment", vec![json!(1)]).await?;
    println!("New count: ", result);
    
    Ok(())
}
```

See the [Rust client documentation](/clients/rust) for more information.
## Quickstart

# Quickstart

  Set up actors with Node.js, Bun, and web frameworks

  Build real-time React applications with actors
## React Quickstart

# React Quickstart

Build real-time React applications with Rivet Actors

```sh
npm install @rivetkit/actor @rivetkit/react
```

Create your actor registry on the backend:

```ts }
const counter = actor(,
	actions: ,
		getCount: (c) => c.state.count,
	},
});

const registry = setup(,
});
```

Start a server to run your actors:

```ts }
registry.runServer();
```

Set up your React application:

```tsx }
// Create typed client
const client = createClient("http://localhost:8080");
const  = createRivetKit(client);

function App() );

	// Listen for real-time count updates
	counter.useEvent("countChanged", (newCount: number) => );

	const increment = async () => ;

	const incrementBy = async (amount: number) => ;

	return (
		
			Rivet Counter
			Count: 

					Counter Name:
					 setCounterName(e.target.value)}
						style=}
					/>

					+1
				
				 incrementBy(5)}>
					+5
				
				 incrementBy(10)}>
					+10

				Connection Status: 
				Try opening multiple tabs to see real-time sync.

	);
}

default App;
```

Configure Vite for development:

```ts }
default defineConfig(,
})
```

Start both the backend and frontend:

**Terminal 1**: Start the backend

```sh Backend
npx tsx --watch backend/server.ts
```

**Terminal 2**: Start the frontend

```sh Frontend  
npx vite
```

Open `http://localhost:5173` in your browser. Try opening multiple tabs to see real-time sync in action.

## Configuration Options

### Add Your Own Backend Endpoints

Add custom HTTP endpoints alongside your actors to handle additional business logic, authentication, and integrations with external services.

See [backend quickstart](/docs/actors/quickstart/backend) for more information.
## Scaling & Concurrency

# Scaling & Concurrency

This document covers how actors are able to scale better than traditional applications & provides tips on architecting your actors.

## How actors scale

Actors scale by design through these key properties:

| Property                             | Description                                                                                                                                                                                                                                                                                     |
| ------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Independent State**                | Each actor manages its own private data separately from other actors, so they never conflict with each other when running at the same time (i.e. using locking mechanisms).                                                                                                                     |
| **Action- & Event-Based Communication** | Actors communicate through asynchronous [actions](/docs/actors/actions) or [events](/docs/actors/events), making it easy to distribute them across different machines.                                                                                                                                               |
| **Location Transparency**            | Unlike traditional servers, actors don't need to know which machine other actors are running on in order to communicate with each other. They can run on the same machine, across a network, and across the world. Actors handle the network routing for you under the hood.                    |
| **Horizontal Scaling**               | Actors distribute workload by splitting responsibilities into small, focused units. Since each actor handles a limited scope (like a single user, document, or chat room), the system automatically spreads load across many independent actors rather than concentrating it in a single place. |

## Tips for architecting actors for scale

Here are key principles for architecting your actor system:

**Single Responsibility**

- Each actor should represent one specific entity or concept from your application (e.g., `User`, `Document`, `ChatRoom`).
- This makes your system scale better, since actors have small scopes and do not conflict with each other.

**State Management**

- Each actor owns and manages only its own state
- Use [actions](/docs/actors/actions) to request data from other actors
- Keep state minimal and relevant to the actor's core responsibility

**Granularity Guidelines**

- Too coarse: Actors handling too many responsibilities become bottlenecks
- Too fine: Excessive actors create unnecessary communication overhead
- Aim for actors that can operate independently with minimal cross-actor communication

### Examples

**Good actor boundaries**

- `User`: Manages user profile, preferences, and authentication
- `Document`: Handles document content, metadata, and versioning
- `ChatRoom`: Manages participants and message history

**Poor actor boundaries**

- `Application`: Too broad, handles everything
- `DocumentWordCount`: Too granular, should be part of DocumentActor
## Schedule

# Schedule

Scheduling is used to trigger events in the future. The actor scheduler is like `setTimeout`, except the timeout will persist even if the actor restarts, upgrades, or crashes.

	Scheduling is supported on the Rivet Cloud, Cloudflare Workers, file system, and memory drivers.

	Follow [this issue](https://github.com/rivet-gg/rivetkit/issues/1095) for Redis support.

## Use Cases

Scheduling is helpful for long-running timeouts like month-long billing periods or account trials.

## Scheduling

### `c.schedule.after(duration, actionName, ...args)`

Schedules a function to be executed after a specified duration. This function persists across actor restarts, upgrades, or crashes.

Parameters:

- `duration` (number): The delay in milliseconds.
- `actionName` (string): The name of the action to be executed.
- `...args` (unknown[]): Additional arguments to pass to the function.

### `c.schedule.at(timestamp, actionName, ...args)`

Schedules a function to be executed at a specific timestamp. This function persists across actor restarts, upgrades, or crashes.

Parameters:

- `timestamp` (number): The exact time in milliseconds since the Unix epoch when the function should be executed.
- `actionName` (string): The name of the action to be executed.
- `...args` (unknown[]): Additional arguments to pass to the function.

## Full Example

```typescript
const reminderService = actor(
  },
  
  actions: ;
      
      // Schedule the sendReminder action to run after the delay
      c.schedule.after(delayMs, "sendReminder", reminderId);
      
      return ;
    },
    
    sendReminder: (c, reminderId) => );
        });
      } else 
      
      // Clean up the processed reminder
      delete c.state.reminders[reminderId];
    }
  }
});
```
## Sharing and Joining State

# Sharing and Joining State

Actors store data separately by design, so combining data from multiple actors works differently than traditional databases. This pattern is similar to patterns you'll see in distributed like Cassandra, DynamoDB, and ClickHouse.

Here are your options based on your needs:

## Few actors, need latest data

- Call actions on each actor to get their data
- Actions are fast, so this works well for small numbers of actors
- Trade-off: More work when reading data, but writing is simple

## Many actors, need latest data

- Have actors automatically send updates to other actors that need them
- This keeps everyone in sync without extra calls
- Trade-off: More work when data changes, but reading is fast

## Many actors, okay with slightly old data

- Write data to a separate OLAP database like ClickHouse when updating state
- Query the analytics database for fast joins
- Trade-off: Extra database to maintain, but great performance

## Many actors, need latest data (not recommended)

- Write data to a transactional OLTP database like Postgres or MySQL when updating state
- This works but adds complexity you usually don't need
- Trade-off: Heavy database overhead for minimal benefit
## State

# State

Actor state provides the best of both worlds: it's stored in-memory and persisted automatically. This lets you work with the data without added latency while still being able to survive crashes & upgrades.

Actors can also be used with external SQL databases. This can be useful to integrate actors with existing
applications or for storing relational data. Read more [here](/docs/actors/external-sql).

## Initializing State

There are two ways to define an actor's initial state:

Define an actor state as a constant value:

```typescript
// Simple state with a constant
const counter = actor(,
  
  actions: 
});
```

This value will be cloned for every new actor using `structuredClone`.

Create actor state dynamically on each actors' creation:

```typescript
// State with initialization logic
const counter = actor(;
  },
  
  actions: 
});
```

The `createState` function is called once when the actor is first created. See [Lifecycle](/docs/actors/lifecycle) for more details.

## Modifying State

To update state, modify the `state` property on the context object (`c.state`) in your actions:

```typescript
const counter = actor(,
  
  actions: ,
    
    add: (c, value) => 
  }
});
```

Only state stored in the `state` object will be persisted. Any other variables or properties outside of this are not persisted.

## State Saves

Actors automatically handle persisting state transparently. This happens at the end of every action if the state has changed. State is also automatically saved after `onFetch` and `onWebSocket` handlers finish executing.

For `onWebSocket` handlers specifically, you'll need to manually save state using `c.saveState()` while the WebSocket connection is open if you want state changes to be persisted immediately. This is because WebSocket connections can remain open for extended periods, and state changes made during event handlers (like `message` events) won't be automatically saved until the connection closes.

In other cases where you need to force a state change mid-action, you can use `c.saveState()`. This should only be used if your action makes an important state change that needs to be persisted before the action completes.

```typescript
const criticalProcess = actor(,
  
  actions: `);
      
      // Force save state before the async operation
      c.saveState();
      
      // Long-running operation that might fail
      await someRiskyOperation();
      
      // Update state again
      c.state.steps.push(`Completed step $`);
      
      return c.state.currentStep;
    }
  }
});
```

## State Isolation

Each actor's state is completely isolated, meaning it cannot be accessed directly by other actors or clients.

To interact with an actor's state, you must use [Actions](/docs/actors/actions). Actions provide a controlled way to read from and write to the state.

If you need a shared state between multiple actors, see [sharing and joining state](/docs/actors/sharing-and-joining-state).

## Ephemeral Variables

In addition to persisted state, actors can store ephemeral data that is not saved to permanent storage using `vars`. This is useful for temporary data or non-serializable objects like database connections or event emitters.

For complete documentation on ephemeral variables, see [Ephemeral Variables](/docs/actors/ephemeral-variables).

## Limitations

State is currently constrained to the available memory on the machine.

Only JSON-serializable types can be stored in state. In serverless runtimes that support it (Rivet, Cloudflare Workers), state is persisted under the hood in a compact, binary format. This is because JavaScript classes cannot be serialized & deserialized.

SQLite in Rivet Actors (coming soon) will provide a way of dynamically querying data with in-memory performance without being constrained to memory limits.
## Testing

# Testing

Rivet provides a straightforward testing framework to build reliable and maintainable applications. This guide covers how to write effective tests for your actor-based services.

## Setup

To set up testing with Rivet:

```bash
# Install Vitest
npm install -D vitest

# Run tests
npm test
```

## Basic Testing Setup

Rivet includes a test helper called `setupTest` that configures a test environment with in-memory drivers for your actors. This allows for fast, isolated tests without external dependencies.

```ts tests/my-actor.test.ts
test("my actor test", async (test) =>  = await setupTest(test, app);
  
  // Now you can interact with your actor through the client
  const myActor = await client.myActor.get();
  
  // Test your actor's functionality
  await myActor.someAction();
  
  // Make assertions
  const result = await myActor.getState();
  expect(result).toEqual("updated");
});
```

```ts src/index.ts
const myActor = actor(,
  actions: ,
    getState: (c) => 
  }
});

const registry = setup(
});
```

## Testing Actor State

The test framework uses in-memory drivers that persist state within each test, allowing you to verify that your actor correctly maintains state between operations.

```ts tests/counter.test.ts
test("actor should persist state", async (test) =>  = await setupTest(test, app);
  const counter = await client.counter.get();
  
  // Initial state
  expect(await counter.getCount()).toBe(0);
  
  // Modify state
  await counter.increment();
  
  // Verify state was updated
  expect(await counter.getCount()).toBe(1);
});
```

```ts src/index.ts
const counter = actor(,
  actions: ,
    getCount: (c) => 
  }
});

const registry = setup(
});
```

## Testing Events

For actors that emit events, you can verify events are correctly triggered by subscribing to them:

```ts tests/chat-room.test.ts
test("actor should emit events", async (test) =>  = await setupTest(test, app);
  const chatRoom = await client.chatRoom.get();
  
  // Set up event handler with a mock function
  const mockHandler = vi.fn();
  chatRoom.on("newMessage", mockHandler);
  
  // Trigger the event
  await chatRoom.sendMessage("testUser", "Hello world");
  
  // Wait for the event to be emitted
  await vi.waitFor(() => );
});
```

```ts src/index.ts
const chatRoom = actor(,
  actions: );
      c.broadcast("newMessage", username, message);
    },
    getHistory: (c) => ,
  },
});

// Create and the app
const registry = setup(
});
```

## Testing Schedules

Rivet's schedule functionality can be tested using Vitest's time manipulation utilities:

```ts tests/scheduler.test.ts
test("scheduled tasks should execute", async (test) =>  = await setupTest(test, app);
  const scheduler = await client.scheduler.get();
  
  // Set up a scheduled task
  await scheduler.scheduleTask("reminder", 60000); // 1 minute in the future
  
  // Fast-forward time by 1 minute
  await vi.advanceTimersByTimeAsync(60000);
  
  // Verify the scheduled task executed
  expect(await scheduler.getCompletedTasks()).toContain("reminder");
});
```

```ts src/index.ts
const scheduler = actor(,
  actions: ;
    },
    completeTask: (c, taskName: string) => ;
    },
    getCompletedTasks: (c) => 
  }
});

const registry = setup(
});
```

The `setupTest` function automatically calls `vi.useFakeTimers()`, allowing you to control time in your tests with functions like `vi.advanceTimersByTimeAsync()`. This makes it possible to test scheduled operations without waiting for real time to pass.

## Best Practices

1. **Isolate tests**: Each test should run independently, avoiding shared state.
2. **Test edge cases**: Verify how your actor handles invalid inputs, concurrent operations, and error conditions.
3. **Mock time**: Use Vitest's timer mocks for testing scheduled operations.
4. **Use realistic data**: Test with data that resembles production scenarios.

Rivet's testing framework automatically handles server setup and teardown, so you can focus on writing effective tests for your business logic.
## Node.js & Bun

# Node.js & Bun

The Rivet JavaScript client allows you to connect to and interact with actors from browser and Node.js applications.

## Quickstart

    Create a new Node.js project with TypeScript support:

      ```sh npm
      mkdir my-app
      cd my-app
      npm init -y
      npm pkg set type=module
      ```
      
      ```sh pnpm
      mkdir my-app
      cd my-app
      pnpm init
      pnpm pkg set type=module
      ```
      
      ```sh yarn
      mkdir my-app
      cd my-app
      yarn init -y
      yarn pkg set type=module
      ```
      
      ```sh bun
      mkdir my-app
      cd my-app
      bun init -y
      ```

    Install the Rivet client and Node.js platform packages:

      ```sh npm
      npm install @rivetkit/actor
      ```
      
      ```sh pnpm
      pnpm add @rivetkit/actor
      ```
      
      ```sh yarn
      yarn add @rivetkit/actor
      ```
      
      ```sh bun
      bun add @rivetkit/actor
      ```

    Create a file `src/client.ts` in your project to connect to your actor:

    ```typescript src/client.ts
    async function main() 

    main().catch(console.error);
    ```

    In a separate terminal, run your client code:

      ```sh npm
      npx tsx src/client.ts
      ```
      
      ```sh pnpm
      pnpm exec tsx src/client.ts
      ```
      
      ```sh yarn
      yarn tsx src/client.ts
      ```
      
      ```sh bun
      bun run src/client.ts
      ```

    You should see output like:
    ```
    Event: 5
    Action: 5
    ```

    Run it again to see the state update.

## Next Steps

For more information on communicating with actors, including event handling and RPC calls, see [Communicating with Actors](/docs/actors/communicating-with-actors).
## OpenAPI

# OpenAPI

The Rivet OpenAPI spec is available [here](https://github.com/rivet-gg/rivetkit/blob/main/clients/openapi/openapi.json)
## React

# React

Build real-time React applications with Rivet Actors

Learn how to create real-time, stateful React applications with Rivet's actor model. The React integration provides intuitive hooks for managing actor connections and real-time updates.

## Installation

Install the Rivet React package:

```bash
npm install @rivetkit/actor @rivetkit/react
```

## Basic Usage

First, set up your actor registry (typically in your backend):

```typescript
// backend/registry.ts
const counter = actor(,
  actions: ,
    getCount: (c) => c.state.count,
  },
});

const registry = setup(,
});
```

Create a typed client and Rivet hooks:

```tsx
// src/rivetkit.ts
const client = createClient("http://localhost:8080");
const  = createRivetKit(client);
```

Connect to actors and listen for real-time updates:

```tsx
// src/App.tsx
function App() );

  // Listen for real-time count updates
  counter.useEvent("countChanged", (newCount: number) => );

  const increment = async () => ;

  return (
    
      Rivet Counter
      Count: 

          Counter Name:
           setCounterName(e.target.value)}
            style=}
          />

        Increment

        Status: 

  );
}

default App;
```

## API Reference

### `createRivetKit(client, options?)`

Creates the Rivet hooks for React integration.

```tsx
const client = createClient("http://localhost:8080");
const  = createRivetKit(client);
```

#### Parameters

- `client`: The Rivet client created with `createClient`
- `options`: Optional configuration object

#### Returns

An object containing:
- `useActor`: Hook for connecting to actors

### `useActor(options)`

Hook that connects to an actor and manages the connection lifecycle.

```tsx
const actor = useActor(,
  enabled: true
});
```

#### Parameters

- `options`: Object containing:
  - `name`: The name of the actor type (string)
  - `key`: Array of strings identifying the specific actor instance
  - `params`: Optional parameters passed to the actor connection
  - `enabled`: Optional boolean to conditionally enable/disable the connection (default: true)

#### Returns

Actor object with the following properties:
- `connection`: The actor connection for calling actions, or `null` if not connected
- `isConnected`: Boolean indicating if the actor is connected
- `state`: Current actor state (if available)
- `useEvent(eventName, handler)`: Method to subscribe to actor events

### `actor.useEvent(eventName, handler)`

Subscribe to events emitted by the actor.

```tsx
const actor = useActor();

actor.useEvent("countChanged", (newCount: number) => );
```

#### Parameters

- `eventName`: The name of the event to listen for (string)
- `handler`: Function called when the event is emitted

#### Lifecycle

The event subscription is automatically managed:
- Subscribes when the actor connects
- Cleans up when the component unmounts or actor disconnects
- Re-subscribes on reconnection

## Advanced Patterns

### Multiple Actors

Connect to multiple actors in a single component:

```tsx
function Dashboard() );
  
  const notifications = useActor();

  userProfile.useEvent("profileUpdated", (profile) => );

  notifications.useEvent("newNotification", (notification) => );

  return (

  );
}
```

### Conditional Connections

Control when actors connect using the `enabled` option:

```tsx
function ConditionalActor() );

  return (
    
       setEnabled(!enabled)}>

      )}
    
  );
}
```

### Authentication

Pass authentication parameters to actors:

```tsx
function AuthenticatedChat() 
  });

  chatRoom.useEvent("messageReceived", (message) => );

  const sendMessage = async (text: string) => ;

  return (

  );
}
```

### Error Handling

Handle connection errors gracefully:

```tsx
function ResilientCounter() );

  counter.useEvent("error", (err) => );

  counter.useEvent("connected", () => );

  return (

      )}
      
        Status: 

  );
}
```

### Custom Hooks

Create reusable custom hooks for common patterns:

```tsx
// Custom hook for a counter with persistent state
function useCounter(counterId: string) );

  counter.useEvent("countChanged", setCount);

  const increment = useCallback(async (amount = 1) => , [counter.connection]);

  const reset = useCallback(async () => , [counter.connection]);

  return ;
}

// Usage
function App()  = useCounter("my-counter");

  return (
    
      Count: 
       increment()} disabled=>
        Increment
      
       reset()} disabled=>
        Reset

  );
}
```

### Real-time Collaboration

Build collaborative features with multiple event listeners:

```tsx
function CollaborativeEditor() );
  
  const document = useActor(
  });

  // Listen for content changes
  document.useEvent("contentChanged", (newContent) => );

  // Listen for cursor movements
  document.useEvent("cursorMoved", () => ));
  });

  // Listen for user join/leave
  document.useEvent("userJoined", () =>  joined the document`);
  });

  document.useEvent("userLeft", () =>  = prev;
      return rest;
    });
  });

  const updateContent = async (newContent: string) => ;

  return (

  );
}
```

## Client Connection Options

### Basic Client Setup

Create a type-safe client to connect to your backend:

```ts client.ts
// Create typed client
const client = createClient("http://localhost:8080");

// Use the counter actor directly
const counter = client.counter.getOrCreate(["my-counter"]);

// Call actions
const count = await counter.increment(3);
console.log("New count:", count);

// Get current state
const currentCount = await counter.getCount();
console.log("Current count:", currentCount);

// Listen to real-time events
const connection = counter.connect();
connection.on("countChanged", (newCount) => );

// Increment through connection
await connection.increment(1);
```

### React Integration

Use the React hooks for seamless integration:

```tsx
const client = createClient("http://localhost:8080");
const  = createRivetKit(client);

function App() );

	counter.useEvent("countChanged", (newCount: number) => setCount(newCount));

	const increment = async () => ;

	return (
		
			Counter: 
			 setCounterName(e.target.value)}
				placeholder="Counter name"
			/>
			Increment
		
	);
}
```

## Environment Configuration

### Development vs Production

Create environment-specific configurations:

```ts config.ts
const isDev = process.env.NODE_ENV !== "production";

const config = ,
					manager: ,
				}
			: ,
					manager: ,
				},
	},
};
```

### Backend Configuration

Update your server to use environment-based configuration:

```ts server.ts
const  = registry.createServer(config.rivetkit);

// ... rest of server setup
```

### Frontend Environment Variables

Configure your frontend for different environments:

```ts .env.local
VITE_API_URL=http://localhost:8080
VITE_WS_URL=ws://localhost:8080
```

```ts config/client.ts
const API_URL = import.meta.env.VITE_API_URL || "http://localhost:8080";

const client = createClient(API_URL);
```

## Authentication Integration

### Protected Actors

Add authentication to secure your actors:

```ts registry.ts
const protectedCounter = actor(
		
		// Validate token and return user data
		const user = await validateJWT(token);
		return ;
	},
	
	state: ,
	
	actions:  = c.conn.auth;
			
			c.state.count += amount;
			c.broadcast("countChanged", );
			return c.state.count;
		},
	},
});
```

### React Authentication

Connect authenticated actors in React:

```tsx
function AuthenticatedApp() ,
		enabled: !!authToken // Only connect when authenticated
	});

	const login = async () => ;

	if (!authToken) 

	return (
		
			Authenticated Counter

	);
}
```

Learn more about [authentication](/docs/general/authentication).

## Best Practices

1. **Use Custom Hooks**: Extract actor logic into reusable custom hooks
2. **Handle Loading States**: Always account for the initial loading state
3. **Error Boundaries**: Implement error boundaries around actor components
4. **Conditional Connections**: Use the `enabled` prop to control when actors connect
5. **Event Cleanup**: Event listeners are automatically cleaned up, but be mindful of heavy operations in handlers
6. **State Management**: Combine with React state for local UI state that doesn't need to be shared
## Rust

# Rust

The Rivet Rust client provides a way to connect to and interact with actors from Rust applications.

## Quickstart

    Create a new Rust project:
    
    ```sh
    cargo new my-app
    cd my-app
    ```

    Add Rivet client & related dependencies to your project:
    
    ```sh
    cargo add rivetkit-client
    cargo add serde_json
    cargo add tokio --features full
    ```

    Modify `src/main.rs` to connect to your actor:

    ```rust src/main.rs
    use rivetkit_client::;
    use serde_json::json;
    use std::time::Duration;

    #[tokio::main]
    async fn main() -> Result> ", count);
        }).await;
        
        // Call an action
        let result = counter.action("increment", vec![json!(5)]).await?;
        println!("Action: ", result);
        
        // Wait to receive events
        tokio::time::sleep(Duration::from_secs(1)).await;
        
        Ok(())
    }
    ```

    In a separate terminal, run your client code:
    
    ```sh
    cargo run
    ```
    
    You should see output like:
    ```
    Event: 5
    Action: 5
    ```

    Run it again to see the state update.
## Build Your Own

# Build Your Own

Each driver implements common interfaces defined by RivetKit, including:

- **ActorDriver**: Manages actor state, lifecycle, and persistence
- **ManagerDriver**: Handles actor discovery, routing, and scaling

## Source Code Locations

Get started by looking at source code for the driver interfaces and existing drivers:

- **Driver Interfaces**
  - **ActorDriver*** [Source Code](https://github.com/rivet-gg/rivetkit/blob/main/packages/core/src/actor/driver.ts)
  - **ManagerDriver*** [Source Code](https://github.com/rivet-gg/rivetkit/blob/main/packages/core/src/manager/driver.ts)
- **Driver Implementations**: [Source Code](https://github.com/rivet-gg/rivetkit/tree/main/packages/core/src/drivers)
## File System

# File System

The File System driver is the default driver for Rivet Actors, providing local file-based storage for state management and inter-actor communication. If no driver is specified in your configuration, the File System driver will be used automatically.

The File System driver is ideal for development and single-node deployments. For production applications that need to scale horizontally across multiple machines, use the [Redis driver](/docs/drivers/redis).

## Feature Support

| Feature | Supported |
| --- | --- |
| Horizontal scaling | No |
| WebSockets | Yes |
| SSE | Yes |
| Edge | No |
| Scheduling | Yes |

## Setup

The File System driver is included with `@rivetkit/actor` - no additional packages needed:

```bash
npm install @rivetkit/actor
```

Use the default configuration with automatic path based on your current working directory:

```typescript }
const driver = createFileSystemDriver();
const  = registry.runServer();

// ...rest of your server...
```

The default path is stored in your system's data path. The path is unique to the current working directory, so you can safely run multiple projects on the same machine.

Specify a custom path for actor storage:

```typescript }
const driver = createFileSystemDriver();
const  = registry.runServer();

// ...rest of your server...
```

**Configuration Options:**

- `path` - Custom directory path for storing actor data (optional)

## Data Management

The path where your actors are stored is printed when you start your project. To reset your actors, delete the folder that is printed.

If running on a single node, make sure to back up your actors folder regularly. `rsync` works nicely with this because each actor is stored as its own file.

## Examples

Basic File System driver setup and configuration example.
## Memory

# Memory

The Memory driver stores all actor state and communication in memory, making it ideal for testing, development, and prototyping scenarios where persistence is not required.

The Memory driver does not persist data between server restarts. For production applications that need to scale horizontally across multiple machines, use the [Redis driver](/docs/drivers/redis).

## Feature Support

| Feature | Supported |
| --- | --- |
| Horizontal scaling | No |
| WebSockets | Yes |
| SSE | Yes |
| Edge | No |
| Scheduling | Yes |

## Setup

The Memory driver is included with `@rivetkit/actor` - no additional packages needed:

```bash
npm install @rivetkit/actor
```

Create and use the Memory driver:

```typescript }
const driver = createMemoryDriver();
const  = registry.runServer();

// ...rest of your server...
```

The Memory driver requires no configuration options.
## Redis

# Redis

The Redis driver enables deploying scalable Rivet Actors using Redis as the backend for state management and inter-actor communication.

The Redis driver is currently in preview. We do not recommend shipping production applications with the Redis driver yet.

If you want to take Redis to production, [contact us](/support) so we can help validate your setup is production ready and help resolve issues promptly.

## Feature Support

| Feature | Supported |
| --- | --- |
| Horizontal scaling | Yes |
| WebSockets | Yes |
| SSE | Yes |
| Edge | No |
| Scheduling | [Not yet](https://github.com/rivet-gg/rivetkit/issues/1095) |

## Setup

Install the required packages:

```bash
npm install @rivetkit/redis ioredis@5
```

Configure your application using environment variables:

```bash
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=your-password
REDIS_KEY_PREFIX=myproject
```

**Available Environment Variables:**

- `REDIS_HOST` - Redis server hostname (default: `localhost`)
- `REDIS_PORT` - Redis server port (default: `6379`)
- `REDIS_PASSWORD` - Redis password (optional)
- `REDIS_KEY_PREFIX` - Key prefix for isolation when running multiple projects (optional)

Then start your server:

```typescript }
const driver = createRedisDriver();
const  = registry.runServer();

// ...rest of your server...
```

For advanced configuration, pass your own Redis instance:

```typescript }
const redis = new Redis();

const driver = createRedisDriver();
const  = registry.runServer();

// ...rest of your server...
```

**Configuration Options:**

When passing a custom Redis instance, you have full control over the connection options. Common options include:

- `host` - Redis server hostname
- `port` - Redis server port
- `password` - Redis password

See the [ioredis documentation](https://github.com/luin/ioredis) for all available options.

To prevent data loss, ensure AOF (Append Only File) persistence is enabled on your Redis server. See the [Redis Persistence Documentation](https://redis.io/docs/latest/operate/oss_and_stack/management/persistence/#append-only-file) for setup instructions.

## Deploy

Deploy your Redis-powered actors on these hosting providers:

Deploy on Railway with automatic scaling and managed infrastructure.

## Examples

Example using Redis driver with Hono web framework.

Basic Redis driver setup and configuration example.
## Architecture

# Architecture

Rivet supports three topologies that define how actors are distributed and scale.

	Each platform configures a default topology appropriate for that environment. In most cases, you can rely on these defaults unless you have specific distribution needs.

## Configuration

```typescript
const config = ;
```

## Types of Topologies

### Standalone

- **How it works**: Runs all actors in a single process
- **When to use**: Development, testing, simple apps with low traffic
- **Limitations**: No horizontal scaling, single point of failure
- **Default on**: Node.js, Bun

### Partition

- **How it works**: Each actor has its own isolated process. Clients connect directly to the actor for optimal performance.
- **When to use**: Production environments needing horizontal scaling
- **Limitations**: Minimal - balanced performance and availability for most use cases
- **Default on**: Rivet, Cloudflare Workers

### Coordinate

- **How it works**: Creates a peer-to-peer network between multiple servers with leader election with multiple actors running on each server. Clients connect to any server and data is transmitted to the leader over a pubsub server.
- **When to use**: High-availability scenarios needing redundancy and failover
- **Limitations**: Added complexity, performance overhead, requires external data source
- **Default on**: _None_

## Choosing a Topology

In most cases, use your platform's default:

1. **Standalone**: Simple, great for development
2. **Partition**: Best scaling & cost for production
3. **Coordinate**: Good for specialized deployment scenarios
## Cross-Origin Resource Sharing

# Cross-Origin Resource Sharing

Cross-Origin Resource Sharing (CORS) is a security mechanism that allows a web application running at one origin to access resources from a different origin. Without CORS, browsers block cross-origin HTTP requests by default as a security measure.

You'll need to configure CORS when:

- **Local Development**: You're developing locally and your client runs on a different port than your actor service
- **Different Domain**: Your frontend application is hosted on a different domain than your actor service

## Registry-Level CORS

Configure CORS directly in your registry setup for simple cases:

```typescript
const registry = setup(,
  cors: 
});
```

This approach works well for basic setups but has limitations for complex scenarios.

## Router-Level CORS (Recommended)

For production applications, configure CORS at the router level for maximum control:

```typescript
const  = registry.createServer();
const app = new Hono();

app.use("*", cors());

serve(app);
```

### Required Headers for Rivet

Rivet requires specific headers for communication. Always include `ALLOWED_PUBLIC_HEADERS`:

```typescript
// ALLOWED_PUBLIC_HEADERS includes:
// - "Content-Type"
// - "User-Agent" 
// - "X-RivetKit-Query"
// - "X-RivetKit-Encoding"
// - "X-RivetKit-Conn-Params"
// - "X-RivetKit-Actor"
// - "X-RivetKit-Conn"
// - "X-RivetKit-Conn-Token"

const corsConfig = ;
```

Without `ALLOWED_PUBLIC_HEADERS`, Rivet clients won't be able to communicate with your actors from the browser.

## Framework-Specific Examples

### Express.js

```typescript
const  = registry.createServer();
const app = express();

app.use(cors());

app.use("/registry", handler);
app.listen(8080);
```

### Elysia

```typescript
const  = registry.createServer();

const app = new Elysia()
  .use(cors())
  .mount("/registry", handler)
  .listen(8080);
```

## Configuration Options

### `origin`

`string | string[] | (origin: string) => boolean | string`

Specifies which domains can access your resources:

```typescript
// Single domain
origin: "https://example.com"

// Multiple domains
origin: ["https://app.com", "https://admin.com"]

// Dynamic validation
origin: (origin) => 

// All domains (not recommended for production)
origin: "*"
```

### `allowMethods`

`string[]`

HTTP methods clients are allowed to use:

```typescript
allowMethods: ["GET", "POST", "OPTIONS"]  // Common for Rivet
```

### `allowHeaders`

`string[]`

Headers that clients can send in requests:

```typescript
allowHeaders: [
  "Authorization",           // Your auth headers
  "Content-Type",           // Standard content type
  "X-API-Key",              // Custom API key header
  ...ALLOWED_PUBLIC_HEADERS // Required Rivet headers
]
```

### `credentials`

`boolean`

Whether to allow credentials (cookies, auth headers):

```typescript
credentials: true  // Required for authentication
```

When `credentials: true`, you cannot use `origin: "*"`. Specify exact origins instead.

### `maxAge`

`number`

How long browsers cache CORS preflight responses (in seconds):

```typescript
maxAge: 600  // Cache for 10 minutes
```

### `exposeHeaders`

`string[]`

Server headers that browsers can access:

```typescript
exposeHeaders: ["Content-Length", "X-Request-Id"]
```

## Development vs Production

### Development Setup

For local development, allow localhost origins:

```typescript
const isDev = process.env.NODE_ENV !== "production";

const corsConfig = ;
```

### Production Setup

For production, be restrictive with origins:

```typescript
const corsConfig = ;
```

## Troubleshooting

### Common CORS Errors

**"Access to fetch blocked by CORS policy"**
- Add your frontend's origin to the `origin` list
- Ensure `ALLOWED_PUBLIC_HEADERS` are included in `allowHeaders`

**"Request header not allowed"**
- Add the missing header to `allowHeaders` 
- Include `ALLOWED_PUBLIC_HEADERS` in your configuration

**"Credentials mode mismatch"**
- Set `credentials: true` in CORS config
- Cannot use `origin: "*"` with credentials

### Debug CORS Issues

Enable CORS logging to debug issues:

```typescript
// Log CORS requests in development
if (process.env.NODE_ENV === "development") );
    await next();
  });
}
```

## Best Practices

1. **Use Router-Level CORS**: More flexible than registry-level configuration
2. **Include ALLOWED_PUBLIC_HEADERS**: Required for Rivet communication
3. **Specify Exact Origins**: Avoid wildcards in production
4. **Enable Credentials**: Needed for authentication  
5. **Cache Preflight Requests**: Use appropriate `maxAge` values
6. **Environment-Specific Config**: Different settings for dev/prod
## Documentation for LLMs & AI

# Documentation for LLMs & AI

Rivet provides optimized documentation formats specifically designed for Large Language Models (LLMs) and AI integration tools.

## Available Formats

### LLMs.txt (Condensed)
A condensed version of the documentation perfect for quick reference and context-aware AI assistance.

**Access:** [/llms.txt](/llms.txt)

This format includes:
- Key concepts and features
- Essential getting started information
- Summaries of main functionality
- Optimized for token efficiency

### LLMs-full.txt (Complete)
The complete documentation in a single file, ideal for comprehensive AI assistance and in-depth analysis.

**Access:** [/llms-full.txt](/llms-full.txt)

This format includes:
- Complete documentation content
- All examples and detailed explanations
- Full API references and guides
- Suitable for complex queries and comprehensive understanding

## Individual Page Access

Each documentation page is also available as clean markdown by appending `.md` to any documentation URL path.

### Examples

- **This page as markdown:** [/docs/general/llms.md](/docs/general/llms.md)
- **Actors overview:** [/docs/actors.md](/docs/actors.md)
- **State management:** [/docs/actors/state.md](/docs/actors/state.md)
- **React quickstart:** [/docs/actors/quickstart/react.md](/docs/actors/quickstart/react.md)

### URL Pattern

```
Original URL: https://rivet.gg/docs/[path]
Markdown URL: https://rivet.gg/docs/[path].md
```

## Integration Examples

### ChatGPT/Claude Integration

Use the dropdown on any documentation page to:
- Copy page content directly to clipboard
- Open the page content in ChatGPT or Claude
- View the page as raw markdown

### Custom AI Tools

Fetch documentation programmatically:

```javascript
// Get condensed documentation
const condensed = await fetch('https://rivet.gg/llms.txt').then(r => r.text());

// Get complete documentation
const complete = await fetch('https://rivet.gg/llms-full.txt').then(r => r.text());

// Get specific page as markdown
const actorsDoc = await fetch('https://rivet.gg/docs/actors.md').then(r => r.text());
```
## Edge Networking

# Edge Networking

Actors automatically run near your users on your provider's global network.

	At the moment, edge networking is only supported on Rivet Cloud & Cloudflare Workers. More self-hosted platforms are on the roadmap.

## Region selection

### Automatic region selection

By default, actors will choose the nearest region based on the client's location.

Under the hood, Rivet and Cloudflare use [Anycast routing](https://en.wikipedia.org/wiki/Anycast) to automatically find the best location for the client to connect to without relying on a slow manual pinging process.

### Manual region selection

The region an actor is created in can be overridden using region options:

```typescript client.ts
const client = createClient(/* endpoint */);

// Create actor in a specific region
const actor = await client.example.get(
});
```

See [Create  Manage Actors](/actors/communicating-with-actors) for more information.
## Logging

# Logging

Actors provide a built-in way to log complex data to the console.

When dealing with lots of data, `console.log` often doesn't cut it. Using the context's log object (`c.log`) allows you to log complex data using structured logging.

Using the actor logging API is completely optional.

## Log levels

There are 5 log levels:

| Level    | Call                            | Description                                                      |
| -------- | ------------------------------- | ---------------------------------------------------------------- |
| Critical | `c.log.critical(message, ...args);` | Severe errors that prevent core functionality                    |
| Error    | `c.log.error(message, ...args);`    | Errors that affect functionality but allow continued operation   |
| Warning  | `c.log.warn(message, ...args);`     | Potentially harmful situations that should be addressed          |
| Info     | `c.log.info(message, ...args);`     | General information about significant events & state changes     |
| Debug    | `c.log.debug(message, ...args);`    | Detailed debugging information, usually used only in development |

## Structured logging

The built-in logging API (using `c.log`) provides structured logging to let you log key-value
pairs instead of raw strings. Structures logs are readable by both machines &
humans to make them easier to parse & search.

Passing an object to a log will print as structured data. For example:

```typescript
c.log.info('increment', );
// Prints: level=INFO msg=increment connection=123 count=456
```

The first parameter in each log method is the message. The rest of the arguments are used for structured logging.

## `c.log` vs `console.log` logging

`c.log` makes it easier to manage complex logs, while `console.log` can
become unmaintainable at scale.

Consider this example:

```typescript structured_logging.ts
const counter = actor(,
  
  actions: );

      c.state.count += count;
      return c.state.count;
    }
  }
});
```

```typescript unstructured_logging.ts
const counter = actor(,
  
  actions:  with count $`);

      c.state.count += count;
      return c.state.count;
    }
  }
});
```

If you need to search through a lot of logs, it's easier to read the structured logs. To find increments for a single connection, you can search `connection=123`.

Additionally, structured logs can be parsed and queried at scale using tools like Elasticsearch, Loki, or Datadog. For example, you can parse the log `level=INFO msg=increment connection=123 count=456` in to the JSON object `` and then query it as you would any other structured data.

## Usage in lifecycle hooks

The logger is available in all lifecycle hooks:

```typescript
const loggingExample = actor(,
  
  onStart: (c) => );
  },
  
  onBeforeConnect: (c, ) => );
    
    return ;
  },
  
  onConnect: (c) => );
    
    c.state.events.push();
  },
  
  onDisconnect: (c) => );
    
    c.state.events.push();
  },
  
  actions: 
});
```
## Registry

# Registry

Configure and manage your actor registry

The registry is the central configuration hub for your Rivet application. It defines which actors are available and how your application runs.

## Basic Setup

Create a registry by importing your actors and using the `setup` function:

```typescript
const registry = setup(,
});
```

## Creating Servers

### Development Server

For development, create and run a server directly:

```typescript
// Start a development server
registry.runServer(,
    manager: ,
  },
});
```

### Production Setup

For production, get the handler and integrate with your framework:

```typescript
// Create server components
const  = registry.createServer(,
    manager: ,
  },
});

// Use with Hono
const app = new Hono();
app.route("/registry", hono);

// Or use the handler directly
app.all("/registry/*", handler);

// Start the server
serve(app);
```

## Configuration Options

### Driver Configuration

The driver configuration determines how actors are stored and managed:

```typescript
const  = registry.createServer(,
    
    // Manager coordination
    manager: ,
  },
});
```

### Topology Options

- **`standalone`**: Single process, good for development
- **`partition`**: Distributed actors, good for production scaling
- **`coordinate`**: Peer-to-peer coordination, good for high availability

### Storage Drivers

- **`memory`**: In-memory storage, data lost on restart
- **`file-system`**: Persistent file-based storage
- **`redis`**: Redis-backed persistence and coordination
- **`rivet`**: Rivet platform integration

### CORS Configuration

Configure CORS for browser clients:

```typescript
registry.runServer(,
});
```

### Request Limits

Configure request size limits:

```typescript
registry.runServer();
```

## Worker Mode

For distributed topologies, you can create worker instances:

```typescript
// Manager instance (handles routing)
const  = registry.createServer(,
});

// Worker instance (runs actors)
const  = registry.createWorker(,
});
```

## Type Safety

The registry provides full type safety for your client:

```typescript
// TypeScript knows about your actors
const counter = client.counter.getOrCreate(["my-counter"]);
const chatRoom = client.chatRoom.getOrCreate(["general"]);

// Action calls are type-checked
const count: number = await counter.increment(5);
```

## Testing Configuration

Use memory drivers for testing:

```typescript
// test-registry.ts
const testRegistry = setup(,
});

// In your tests
const  = testRegistry.createServer(,
    manager: ,
  },
});
```

## Environment-Specific Configuration

Use environment variables to configure different environments:

```typescript
const isProd = process.env.NODE_ENV === "production";
const redisUrl = process.env.REDIS_URL || "redis://localhost:6379";

const registry = setup(,
});

// Environment-specific server creation
function createAppServer() ,
          manager: ,
        }
      : ,
          manager: ,
        },
    cors: ,
  });
}
```

## Best Practices

### Registry Organization

Keep your registry clean and organized:

```typescript
// actors/index.ts - Export all actors
 from "./counter";
 from "./chat-room";
 from "./game";

// registry.ts - Import and configure
const registry = setup();
```

### Actor Naming

Use consistent naming conventions:

```typescript
const registry = setup(,
});
```

### Configuration Management

Separate configuration from registry definition:

```typescript
// config.ts
const appConfig = ,
  cors: ,
};

// server.ts
const  = registry.createServer(,
    manager: ,
  },
  cors: appConfig.cors,
});

serve();
```
## Self-Hosting

# Self-Hosting

Take full control of your Rivet deployment with flexible hosting options and storage drivers.

## Hosting Providers

  Deploy Rivet applications with Railway's simple platform-as-a-service

  Run Rivet actors on Cloudflare's edge computing platform

  Managed Rivet hosting with enterprise features and support

## Drivers

  High-performance in-memory data store for production workloads

  Simple file-based storage for development and small deployments

  In-memory storage for testing and ephemeral use cases

  Create custom storage drivers for your specific requirements
## Webhooks

# Webhooks

TODO
## Cloudflare Workers

# Cloudflare Workers

Deploy Rivet Actors to Cloudflare Workers with Durable Objects for global edge computing with persistent state.

## Feature Support

| Feature | Supported |
| --- | --- |
| Horizontal scaling | Yes |
| WebSockets | Yes |
| SSE | Yes |
| Edge | Yes |
| Scheduling | Yes |

## Setup

Install the Cloudflare Workers driver:

```bash
npm install @rivetkit/cloudflare-workers
```

Update your server code to support Cloudflare Workers:

```typescript }
const  = createServer(registry);

// Setup router
const app = new Hono();

// Example API endpoint
app.post("/increment/:name", async (c) => );
});

const  = createHandler(app);

;
```

```typescript }
const  = createServerHandler(registry);
;
```

Update your `wrangler.json` configuration to support `ACTOR_DO` and `ACTOR_KV` bindings:

```json }

  ],
  "durable_objects": 
    ]
  },
  "kv_namespaces": [
    
  ]
}
```

**Configuration Requirements:**

- `ACTOR_DO` - Durable Object binding for actor persistence
- `ACTOR_KV` - KV namespace binding for metadata storage
- `nodejs_compat` - Required compatibility flag
- Migration with `ActorHandler` class definition

Deploy your application to Cloudflare Workers:

```bash
wrangler deploy
```

Your actors will now run on Cloudflare's global edge network with persistent state backed by Durable Objects.

## Examples

Example using Cloudflare Workers with Hono web framework.

Basic Cloudflare Workers setup and configuration example.
## Railway

# Railway

_Coming Soon_
## Rivet Cloud (Enterprise)

# Rivet Cloud (Enterprise)

Rivet Cloud enables you to run Rivet applications at scale with the high performance, edge support, and monitoring. Rivet projects can be deployed to the Rivet Cloud or be self-hosted on-premise.

To try Rivet Cloud, get in touch:

- [Talk to an engineer](https://www.rivet.gg/talk-to-an-engineer)
- [Talk to sales](https://www.rivet.gg/sales)

Rivet Engine â€” the core of Rivet Cloud â€” is [open-source on GitHub](https://github.com/rivet-gg/rivet).

## Feature Support

| Feature | Supported |
| --- | --- |
| Horizontal scaling | Yes |
| WebSockets | Yes |
| SSE | Yes |
| Edge | Yes |
| Scheduling | Yes |
## Better Auth

# Better Auth

Integrate Rivet with Better Auth for authentication

Better Auth provides a comprehensive authentication solution that integrates seamlessly with Rivet Actors using the `onAuth` hook.

	Check out the complete example

## Installation

Install Better Auth alongside Rivet:

```bash
npm install better-auth better-sqlite3
npm install -D @types/better-sqlite3

# For React integration
npm install @rivetkit/react
```

	This example uses SQLite to keep the example. In production, replace this with a database like Postgres. Read more about [configuring your database in Better Auth](https://www.better-auth.com/docs/installation#configure-database).

## Backend Setup

Create your authentication configuration:

```typescript auth.ts
const auth = betterAuth(,
});
```

Create and apply the database schema:

```bash
# Generate migration files
pnpm dlx @better-auth/cli@latest generate --config auth.ts

# Apply migrations to create the database tables
pnpm dlx @better-auth/cli@latest migrate --config auth.ts -y
```

Use the `onAuth` hook to validate sessions:

```typescript registry.ts
const chatRoom = actor( = opts;
    
    // Use Better Auth to validate the session
    const authResult = await auth.api.getSession();
    if (!authResult) throw new Unauthorized();
    
    // Return user data to be available in actor
    return ;
  },
  
  state: ,
  
  actions:  = c.conn.auth;
      
      const newMessage = ;
      
      c.state.messages.push(newMessage);
      c.broadcast("newMessage", newMessage);
      
      return newMessage;
    },
    
    getMessages: (c) => c.state.messages,
  },
});

const registry = setup(,
});
```

Configure your server to handle Better Auth routes and Rivet:

```typescript
// server.ts
const  = registry.createServer();
const app = new Hono();

// Configure CORS for Better Auth + Rivet
app.use("*", cors());

// Mount Better Auth routes
app.on(["GET", "POST"], "/api/auth/**", (c) => 
  auth.handler(c.req.raw)
);

// Start Rivet server
serve(app);
```

## Frontend Integration

Create a Better Auth client for your frontend:

```typescript
// auth-client.ts
const authClient = createAuthClient();
```

Create login/signup forms:

```tsx
// AuthForm.tsx
function AuthForm() );
      } else );
      }
    } catch (error) 
  };

  return (

          required
        />
      )}
      
       setEmail(e.target.value)}
        required
      />
      
       setPassword(e.target.value)}
        required
      />

       setIsLogin(!isLogin)}
      >

  );
}
```

Use authenticated sessions with Rivet:

```tsx
// ChatRoom.tsx
const client = createClient("http://localhost:8080");
const  = createRivetKit(client);

interface ChatRoomProps  };
  roomId: string;
}

function ChatRoom(: ChatRoomProps) );

  const sendMessage = async () => ;

  return (

        Welcome, !
         authClient.signOut()}>Sign Out

        : 
          
        ))}

         setNewMessage(e.target.value)}
          onKeyPress=
          placeholder="Type a message..."
        />
        Send

  );
}
```

## Advanced Features

### Role-Based Access

Add role checking to your actors:

```typescript
const adminActor = actor();
    if (!authResult) throw new Unauthorized();
    
    return ;
  },
  
  actions:  = c.conn.auth;
      if (user.role !== "admin") 

      // Admin-only action
      // ... implementation
    },
  },
});
```

### Session Management

Handle session expiration gracefully:

```tsx
// hooks/useAuth.ts
function useAuthWithRefresh()  = authClient.useSession();
  
  useEffect(() => 
  }, [error]);
  
  return session;
}
```

## Production Deployment

For production, you'll need a database from a provider like [Neon](https://neon.tech/), [PlanetScale](https://planetscale.com/), [AWS RDS](https://aws.amazon.com/rds/), or [Google Cloud SQL](https://cloud.google.com/sql).

Configure your production database connection:

```typescript
// auth.ts
const auth = betterAuth(),
  trustedOrigins: [process.env.FRONTEND_URL],
  emailAndPassword: ,
});
```

Set the following environment variables for production:

```bash
DATABASE_URL=postgresql://username:password@localhost:5432/myapp
FRONTEND_URL=https://myapp.com
BETTER_AUTH_SECRET=your-secure-secret-key
BETTER_AUTH_URL=https://api.myapp.com
```

Read more about [configuring Postgres with Better Auth](https://www.better-auth.com/docs/adapters/postgresql).

	Don't forget to re-generate & re-apply your database migrations if you change the database in your Better Auth config.
## Elysia

# Elysia

Integrate Rivet with Elysia for fast TypeScript web applications

Elysia is a fast and type-safe web framework for Bun. Rivet integrates seamlessly with Elysia using the `.mount()` method.

	Check out the complete example

## Installation

Install Elysia alongside Rivet:

```bash
npm install elysia
# or with bun
bun add elysia
```

## Basic Setup

Set up your Rivet Actors:

```typescript
// registry.ts
const counter = actor(,
  actions: ,
    getCount: (c) => c.state.count,
  },
});

const registry = setup(,
});
```

Mount Rivet into your Elysia application:

```typescript
// server.ts
const  = registry.createServer();

// Setup Elysia app
const app = new Elysia()
  // Mount Rivet handler
  .mount("/registry", handler)
  // Add your API routes
  .post("/increment/:name", async () => `;
  })
  .get("/count/:name", async () => ;
  })
  .listen(8080);

console.log("Server running at http://localhost:8080");
```
## Express

# Express

Integrate Rivet with Express.js for Node.js web applications

Express.js is a popular Node.js web framework. Rivet integrates seamlessly with Express using middleware mounting.

	Check out the complete example

## Installation

Install Express alongside Rivet:

```bash
npm install express
npm install -D @types/express
```

## Basic Setup

Set up your Rivet Actor:

```typescript
// registry.ts
const counter = actor(,
  actions: ,
    getCount: (c) => c.state.count,
  },
});

const registry = setup(,
});
```

Mount Rivet into your Express application:

```typescript
// server.ts
// Start Rivet
const  = registry.createServer();

// Setup Express app
const app = express();

// Enable JSON parsing
app.use(express.json());

// Mount Rivet handler
app.use("/registry", handler);

// Add your API routes
app.post("/increment/:name", async (req, res) =>  = req.body;
  
  try );
  } catch (error) );
  }
});

app.get("/count/:name", async (req, res) => );
  } catch (error) );
  }
});

app.listen(8080, () => );
```
## Hono

# Hono

Integrate Rivet with Hono for ultra-fast web applications

Hono is an ultra-fast web framework that works on any runtime. Rivet integrates seamlessly with Hono through the `serve()` method.

	Check out the complete example

## Installation

Install Hono alongside Rivet:

```bash
npm install hono
```

## Basic Setup

Set up your Rivet Actor:

```typescript
// registry.ts
const counter = actor(,
  actions: ,
    getCount: (c) => c.state.count,
  },
});

const registry = setup(,
});
```

Use Rivet's `serve()` method with your Hono app:

```typescript
// server.ts
// Start Rivet
const  = registry.createServer();

// Setup Hono app
const app = new Hono();

// Add your API routes
app.post("/increment/:name", async (c) => ));
  const amount = body.amount || 1;
  
  try );
  } catch (error) , 500);
  }
});

app.get("/count/:name", async (c) => );
  } catch (error) , 500);
  }
});

// Start server with Rivet integration
serve(app);
```
## Integrations

# Integrations

Rivet provides seamless integrations with popular frameworks and tools to help you build modern applications.

## Frontend & Clients

  Full-featured JavaScript client for web and Node.js applications

  React hooks and components for building interactive UIs

  Type-safe Rust client for high-performance applications

## Backend

  Lightweight and fast web framework for modern JavaScript

  Popular Node.js web framework with extensive middleware support

  Fast and type-safe TypeScript web framework

  End-to-end type-safe API development

## Auth

  Modern authentication library with TypeScript support

## Misc

  Fast unit testing framework for JavaScript and TypeScript
## tRPC

# tRPC

Integrate Rivet with tRPC for end-to-end type-safe APIs

tRPC provides end-to-end type safety for your APIs. Rivet integrates seamlessly with tRPC, allowing you to create type-safe procedures that call Rivet Actors.

	Check out the complete example

## Installation

Install tRPC alongside Rivet:

```bash
npm install @trpc/server @trpc/client zod
npm install -D @trpc/next # if using Next.js
```

## Basic Setup

Set up your Rivet Actors:

```typescript
// registry.ts
const counter = actor(,
  actions: ,
    getCount: (c) => c.state.count,
    reset: (c) => ,
  },
});

const registry = setup(,
});
```

Create your tRPC router that uses Rivet:

```typescript
// server.ts
// Start Rivet
const  = registry.createServer();

// Initialize tRPC
const t = initTRPC.create();

// Create tRPC router with Rivet integration
const appRouter = t.router())
      .mutation(async () => ;
      }),
    
    get: t.procedure
      .input(z.object())
      .query(async () => ;
      }),
    
    reset: t.procedure
      .input(z.object())
      .mutation(async () => ;
      }),
  }),
});

// Export type for client
type AppRouter = typeof appRouter;

// Create HTTP server
const server = createHTTPServer();

server.listen(3001);
console.log("tRPC server listening at http://localhost:3001");
```

Create a type-safe tRPC client:

```typescript
// client.ts
const trpc = createTRPCProxyClient(),
  ],
});

// Usage examples
async function examples() );
  console.log(result); // 
  
  // Get counter value
  const value = await trpc.counter.get.query();
  console.log(value); // 
  
  // Reset counter
  const reset = await trpc.counter.reset.mutate();
  console.log(reset); // 
}
```
## Vitest

# Vitest

See [Testing](/docs/general/testing) documentation.