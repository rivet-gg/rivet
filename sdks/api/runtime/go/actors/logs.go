// This file was auto-generated by Fern from our API Definition.

package actors

import (
	json "encoding/json"
	fmt "fmt"
	sdk "sdk"
	core "sdk/core"
)

type GetActorLogsRequestQuery struct {
	Project             *string        `json:"-"`
	Environment         *string        `json:"-"`
	Stream              QueryLogStream `json:"-"`
	ActorIdsJson        string         `json:"-"`
	SearchText          *string        `json:"-"`
	SearchCaseSensitive *bool          `json:"-"`
	SearchEnableRegex   *bool          `json:"-"`
	// A query parameter denoting the requests watch index.
	WatchIndex *string `json:"-"`
}

type GetActorLogsResponse struct {
	// List of actor IDs in these logs. The order of these correspond to the index in the log entry.
	ActorIds []string `json:"actor_ids,omitempty"`
	// Sorted old to new.
	Lines []string `json:"lines,omitempty"`
	// Sorted old to new.
	Timestamps []sdk.Timestamp `json:"timestamps,omitempty"`
	// Streams the logs came from.
	//
	// 0 = stdout
	// 1 = stderr
	Streams []int `json:"streams,omitempty"`
	// Index of the actor that this log was for. Use this index to look the full ID in `actor_ids`.
	ActorIndices []int              `json:"actor_indices,omitempty"`
	Watch        *sdk.WatchResponse `json:"watch,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetActorLogsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetActorLogsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetActorLogsResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetActorLogsResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type QueryLogStream string

const (
	QueryLogStreamStdOut QueryLogStream = "std_out"
	QueryLogStreamStdErr QueryLogStream = "std_err"
	QueryLogStreamAll    QueryLogStream = "all"
)

func NewQueryLogStreamFromString(s string) (QueryLogStream, error) {
	switch s {
	case "std_out":
		return QueryLogStreamStdOut, nil
	case "std_err":
		return QueryLogStreamStdErr, nil
	case "all":
		return QueryLogStreamAll, nil
	}
	var t QueryLogStream
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (q QueryLogStream) Ptr() *QueryLogStream {
	return &q
}
