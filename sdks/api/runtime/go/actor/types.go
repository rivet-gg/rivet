// This file was auto-generated by Fern from our API Definition.

package actor

import (
	json "encoding/json"
	fmt "fmt"
	uuid "github.com/google/uuid"
	sdk "sdk"
	core "sdk/core"
)

type CreateActorRequestQuery struct {
	Project      *string             `json:"-"`
	Environment  *string             `json:"-"`
	EndpointType *EndpointType       `json:"-"`
	Body         *CreateActorRequest `json:"-"`
}

func (c *CreateActorRequestQuery) UnmarshalJSON(data []byte) error {
	body := new(CreateActorRequest)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	c.Body = body
	return nil
}

func (c *CreateActorRequestQuery) MarshalJSON() ([]byte, error) {
	return json.Marshal(c.Body)
}

type DestroyActorRequestQuery struct {
	Project     *string `json:"-"`
	Environment *string `json:"-"`
	// The duration to wait for in milliseconds before killing the actor. This should be used to override the default kill timeout if a faster time is needed, say for ignoring a graceful shutdown.
	OverrideKillTimeout *int64 `json:"-"`
}

type ListActorsRequestQuery struct {
	Project      *string       `json:"-"`
	Environment  *string       `json:"-"`
	EndpointType *EndpointType `json:"-"`
}

type GetActorsRequestQuery struct {
	Project          *string       `json:"-"`
	Environment      *string       `json:"-"`
	EndpointType     *EndpointType `json:"-"`
	TagsJson         *string       `json:"-"`
	IncludeDestroyed *bool         `json:"-"`
	Cursor           *uuid.UUID    `json:"-"`
}

type BuildCompression string

const (
	// None compression.
	BuildCompressionNone BuildCompression = "none"
	// LZ4 compression. Use the minimum compression level.
	BuildCompressionLz4 BuildCompression = "lz4"
)

func NewBuildCompressionFromString(s string) (BuildCompression, error) {
	switch s {
	case "none":
		return BuildCompressionNone, nil
	case "lz4":
		return BuildCompressionLz4, nil
	}
	var t BuildCompression
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BuildCompression) Ptr() *BuildCompression {
	return &b
}

type BuildKind string

const (
	// Docker image archive generated by `docker save`.
	BuildKindDockerImage BuildKind = "docker_image"
	// OCI-compliant bundle.
	BuildKindOciBundle BuildKind = "oci_bundle"
	// A JavaScript file.
	BuildKindJavascript BuildKind = "javascript"
)

func NewBuildKindFromString(s string) (BuildKind, error) {
	switch s {
	case "docker_image":
		return BuildKindDockerImage, nil
	case "oci_bundle":
		return BuildKindOciBundle, nil
	case "javascript":
		return BuildKindJavascript, nil
	}
	var t BuildKind
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BuildKind) Ptr() *BuildKind {
	return &b
}

type Actor struct {
	Id          uuid.UUID      `json:"id"`
	Region      string         `json:"region"`
	Tags        interface{}    `json:"tags,omitempty"`
	Runtime     *Runtime       `json:"runtime,omitempty"`
	Network     *Network       `json:"network,omitempty"`
	Resources   *Resources     `json:"resources,omitempty"`
	Lifecycle   *Lifecycle     `json:"lifecycle,omitempty"`
	CreatedAt   sdk.Timestamp  `json:"created_at"`
	StartedAt   *sdk.Timestamp `json:"started_at,omitempty"`
	DestroyedAt *sdk.Timestamp `json:"destroyed_at,omitempty"`

	_rawJSON json.RawMessage
}

func (a *Actor) UnmarshalJSON(data []byte) error {
	type unmarshaler Actor
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Actor(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Actor) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type Build struct {
	Id        uuid.UUID     `json:"id"`
	Name      string        `json:"name"`
	CreatedAt sdk.Timestamp `json:"created_at"`
	// Unsigned 64 bit integer.
	ContentLength int64 `json:"content_length"`
	// Tags of this build
	Tags map[string]string `json:"tags,omitempty"`

	_rawJSON json.RawMessage
}

func (b *Build) UnmarshalJSON(data []byte) error {
	type unmarshaler Build
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = Build(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *Build) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type EndpointType string

const (
	EndpointTypeHostname EndpointType = "hostname"
	EndpointTypePath     EndpointType = "path"
)

func NewEndpointTypeFromString(s string) (EndpointType, error) {
	switch s {
	case "hostname":
		return EndpointTypeHostname, nil
	case "path":
		return EndpointTypePath, nil
	}
	var t EndpointType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EndpointType) Ptr() *EndpointType {
	return &e
}

type GuardRouting struct {
	_rawJSON json.RawMessage
}

func (g *GuardRouting) UnmarshalJSON(data []byte) error {
	type unmarshaler GuardRouting
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GuardRouting(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GuardRouting) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type HostRouting struct {
	_rawJSON json.RawMessage
}

func (h *HostRouting) UnmarshalJSON(data []byte) error {
	type unmarshaler HostRouting
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HostRouting(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HostRouting) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type Lifecycle struct {
	// The duration to wait for in milliseconds before killing the actor. This should be set to a safe default, and can be overridden during a DELETE request if needed.
	KillTimeout *int64 `json:"kill_timeout,omitempty"`
	// If true, the actor will try to reschedule itself automatically in the event of a crash or a datacenter failover. The actor will not reschedule if it exits successfully.
	Durable *bool `json:"durable,omitempty"`

	_rawJSON json.RawMessage
}

func (l *Lifecycle) UnmarshalJSON(data []byte) error {
	type unmarshaler Lifecycle
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = Lifecycle(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *Lifecycle) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type Network struct {
	Mode  NetworkMode      `json:"mode,omitempty"`
	Ports map[string]*Port `json:"ports,omitempty"`

	_rawJSON json.RawMessage
}

func (n *Network) UnmarshalJSON(data []byte) error {
	type unmarshaler Network
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = Network(value)
	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *Network) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NetworkMode string

const (
	NetworkModeBridge NetworkMode = "bridge"
	NetworkModeHost   NetworkMode = "host"
)

func NewNetworkModeFromString(s string) (NetworkMode, error) {
	switch s {
	case "bridge":
		return NetworkModeBridge, nil
	case "host":
		return NetworkModeHost, nil
	}
	var t NetworkMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NetworkMode) Ptr() *NetworkMode {
	return &n
}

type Port struct {
	Protocol     PortProtocol `json:"protocol,omitempty"`
	InternalPort *int         `json:"internal_port,omitempty"`
	Hostname     *string      `json:"hostname,omitempty"`
	Port         *int         `json:"port,omitempty"`
	Path         *string      `json:"path,omitempty"`
	// Fully formed connection URL including protocol, hostname, port, and path, if applicable.
	Url     *string      `json:"url,omitempty"`
	Routing *PortRouting `json:"routing,omitempty"`

	_rawJSON json.RawMessage
}

func (p *Port) UnmarshalJSON(data []byte) error {
	type unmarshaler Port
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Port(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Port) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PortProtocol string

const (
	PortProtocolHttp   PortProtocol = "http"
	PortProtocolHttps  PortProtocol = "https"
	PortProtocolTcp    PortProtocol = "tcp"
	PortProtocolTcpTls PortProtocol = "tcp_tls"
	PortProtocolUdp    PortProtocol = "udp"
)

func NewPortProtocolFromString(s string) (PortProtocol, error) {
	switch s {
	case "http":
		return PortProtocolHttp, nil
	case "https":
		return PortProtocolHttps, nil
	case "tcp":
		return PortProtocolTcp, nil
	case "tcp_tls":
		return PortProtocolTcpTls, nil
	case "udp":
		return PortProtocolUdp, nil
	}
	var t PortProtocol
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PortProtocol) Ptr() *PortProtocol {
	return &p
}

type PortRouting struct {
	Guard *GuardRouting `json:"guard,omitempty"`
	Host  *HostRouting  `json:"host,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PortRouting) UnmarshalJSON(data []byte) error {
	type unmarshaler PortRouting
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PortRouting(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PortRouting) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type Region struct {
	Id   string `json:"id"`
	Name string `json:"name"`

	_rawJSON json.RawMessage
}

func (r *Region) UnmarshalJSON(data []byte) error {
	type unmarshaler Region
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Region(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Region) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type Resources struct {
	// The number of CPU cores in millicores, or 1/1000 of a core. For example,
	// 1/8 of a core would be 125 millicores, and 1 core would be 1000
	// millicores.
	Cpu int `json:"cpu"`
	// The amount of memory in megabytes
	Memory int `json:"memory"`

	_rawJSON json.RawMessage
}

func (r *Resources) UnmarshalJSON(data []byte) error {
	type unmarshaler Resources
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Resources(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Resources) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type Runtime struct {
	Build       uuid.UUID         `json:"build"`
	Arguments   []string          `json:"arguments,omitempty"`
	Environment map[string]string `json:"environment,omitempty"`

	_rawJSON json.RawMessage
}

func (r *Runtime) UnmarshalJSON(data []byte) error {
	type unmarshaler Runtime
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Runtime(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Runtime) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type CreateActorNetworkRequest struct {
	Mode  *NetworkMode                       `json:"mode,omitempty"`
	Ports map[string]*CreateActorPortRequest `json:"ports,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreateActorNetworkRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateActorNetworkRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateActorNetworkRequest(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateActorNetworkRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateActorPortRequest struct {
	Protocol     PortProtocol `json:"protocol,omitempty"`
	InternalPort *int         `json:"internal_port,omitempty"`
	Routing      *PortRouting `json:"routing,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreateActorPortRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateActorPortRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateActorPortRequest(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateActorPortRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateActorRuntimeRequest struct {
	Environment map[string]string `json:"environment,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreateActorRuntimeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateActorRuntimeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateActorRuntimeRequest(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateActorRuntimeRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type UpgradeActorRequestQuery struct {
	Project     *string              `json:"-"`
	Environment *string              `json:"-"`
	Body        *UpgradeActorRequest `json:"-"`
}

func (u *UpgradeActorRequestQuery) UnmarshalJSON(data []byte) error {
	body := new(UpgradeActorRequest)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	u.Body = body
	return nil
}

func (u *UpgradeActorRequestQuery) MarshalJSON() ([]byte, error) {
	return json.Marshal(u.Body)
}

type UpgradeAllActorsRequestQuery struct {
	Project     *string                  `json:"-"`
	Environment *string                  `json:"-"`
	Body        *UpgradeAllActorsRequest `json:"-"`
}

func (u *UpgradeAllActorsRequestQuery) UnmarshalJSON(data []byte) error {
	body := new(UpgradeAllActorsRequest)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	u.Body = body
	return nil
}

func (u *UpgradeAllActorsRequestQuery) MarshalJSON() ([]byte, error) {
	return json.Marshal(u.Body)
}
