// This file was auto-generated by Fern from our API Definition.

package client

import (
	context "context"
	fmt "fmt"
	http "net/http"
	url "net/url"
	sdk "sdk"
	core "sdk/core"
	datacenters "sdk/datacenters"
	namespaces "sdk/namespaces"
	runners "sdk/runners"
)

type Client struct {
	baseURL string
	caller  *core.Caller
	header  http.Header

	Datacenters *datacenters.Client
	Namespaces  *namespaces.Client
	Runners     *runners.Client
}

func NewClient(opts ...core.ClientOption) *Client {
	options := core.NewClientOptions()
	for _, opt := range opts {
		opt(options)
	}
	return &Client{
		baseURL:     options.BaseURL,
		caller:      core.NewCaller(options.HTTPClient),
		header:      options.ToHeader(),
		Datacenters: datacenters.NewClient(opts...),
		Namespaces:  namespaces.NewClient(opts...),
		Runners:     runners.NewClient(opts...),
	}
}

// **If key is some & `include_destroyed` is false**
//
// 2 round trips:
//
// - namespace::ops::resolve_for_name_global
// - GET /actors/{} (multiple DCs based on actor IDs)
//
//	This path is optimized because we can read the actor IDs fro the key directly from Epoxy with
//	stale consistency to determine which datacenter the actor lives in. Under most circumstances,
//	this means we don't need to fan out to all datacenters (like normal list does).
//
//	The reason `include_destroyed` has to be false is Epoxy only stores currently active actors. If
//	`include_destroyed` is true, we show all previous iterations of actors with the same key.
//
// **Otherwise**
//
// 2 round trips:
//
// - namespace::ops::resolve_for_name_global
// - GET /actors (fanout)
//
// ## Optimized Alternative Routes
//
// For minimal round trips to check if an actor exists for a key, use `GET /actors/by-id`. This
// does not require fetching the actor's state, so it returns immediately.
func (c *Client) ActorsList(ctx context.Context, request *sdk.ActorsListRequest) (*sdk.ActorsListResponse, error) {
	baseURL := ""
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := baseURL + "/" + "actors"

	queryParams := make(url.Values)
	queryParams.Add("namespace", fmt.Sprintf("%v", request.Namespace))
	if request.Name != nil {
		queryParams.Add("name", fmt.Sprintf("%v", *request.Name))
	}
	if request.Key != nil {
		queryParams.Add("key", fmt.Sprintf("%v", *request.Key))
	}
	if request.ActorIds != nil {
		queryParams.Add("actor_ids", fmt.Sprintf("%v", *request.ActorIds))
	}
	if request.IncludeDestroyed != nil {
		queryParams.Add("include_destroyed", fmt.Sprintf("%v", *request.IncludeDestroyed))
	}
	if request.Limit != nil {
		queryParams.Add("limit", fmt.Sprintf("%v", *request.Limit))
	}
	if request.Cursor != nil {
		queryParams.Add("cursor", fmt.Sprintf("%v", *request.Cursor))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *sdk.ActorsListResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodGet,
			Headers:  c.header,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// **If actor is created in the current datacenter:**
//
// 2 round trips:
//
// - namespace::ops::resolve_for_name_global
// - [pegboard::workflows::actor] Create actor workflow (includes Epoxy key allocation)
//
// **If actor is created in a different datacenter:**
//
// 3 round trips:
//
// - namespace::ops::resolve_for_name_global
// - POST /actors to remote datacenter
// - [pegboard::workflows::actor] Create actor workflow (includes Epoxy key allocation)
//
// actor::get will always be in the same datacenter.
func (c *Client) ActorsCreate(ctx context.Context, request *sdk.ActorsCreateRequest) (*sdk.ActorsCreateResponse, error) {
	baseURL := ""
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := baseURL + "/" + "actors"

	queryParams := make(url.Values)
	queryParams.Add("namespace", fmt.Sprintf("%v", request.Namespace))
	if request.Datacenter != nil {
		queryParams.Add("datacenter", fmt.Sprintf("%v", *request.Datacenter))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *sdk.ActorsCreateResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// **If actor exists**
//
// 2 round trips:
//
// - namespace::ops::resolve_for_name_global
// - GET /actors/{}
//
// **If actor does not exist and is created in the current datacenter:**
//
// 2 round trips:
//
// - namespace::ops::resolve_for_name_global
// - [pegboard::workflows::actor] Create actor workflow (includes Epoxy key allocation)
//
// **If actor does not exist and is created in a different datacenter:**
//
// 3 round trips:
//
// - namespace::ops::resolve_for_name_global
// - POST /actors to remote datacenter
// - [pegboard::workflows::actor] Create actor workflow (includes Epoxy key allocation)
//
// actor::get will always be in the same datacenter.
//
// ## Optimized Alternative Routes
//
// For minimal round trips to get or create an actor, use `PUT /actors/by-id`. This doesn't
// require fetching the actor's state from the other datacenter.
func (c *Client) ActorsGetOrCreate(ctx context.Context, request *sdk.ActorsGetOrCreateRequest) (*sdk.ActorsGetOrCreateResponse, error) {
	baseURL := ""
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := baseURL + "/" + "actors"

	queryParams := make(url.Values)
	queryParams.Add("namespace", fmt.Sprintf("%v", request.Namespace))
	if request.Datacenter != nil {
		queryParams.Add("datacenter", fmt.Sprintf("%v", *request.Datacenter))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *sdk.ActorsGetOrCreateResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPut,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// 1 round trip:
//
// - namespace::ops::resolve_for_name_global
//
// This does not require another round trip since we use stale consistency for the get_id_for_key.
func (c *Client) ActorsGetById(ctx context.Context, request *sdk.ActorsGetByIdRequest) (*sdk.ActorsGetByIdResponse, error) {
	baseURL := ""
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := baseURL + "/" + "actors/by-id"

	queryParams := make(url.Values)
	queryParams.Add("namespace", fmt.Sprintf("%v", request.Namespace))
	queryParams.Add("name", fmt.Sprintf("%v", request.Name))
	queryParams.Add("key", fmt.Sprintf("%v", request.Key))
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *sdk.ActorsGetByIdResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodGet,
			Headers:  c.header,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// **If actor exists**
//
// 1 round trip:
//
// - namespace::ops::resolve_for_name_global
//
// **If actor does not exist and is created in the current datacenter:**
//
// 2 round trips:
//
// - namespace::ops::resolve_for_name_global
// - [pegboard::workflows::actors::keys::allocate_key] Reserve Epoxy key
//
// **If actor does not exist and is created in a different datacenter:**
//
// 3 round trips:
//
// - namespace::ops::resolve_for_name_global
// - namespace::ops::get (to get namespace name for remote call)
// - POST /actors to remote datacenter
func (c *Client) ActorsGetOrCreateById(ctx context.Context, request *sdk.ActorsGetOrCreateByIdRequest) (*sdk.ActorsGetOrCreateByIdResponse, error) {
	baseURL := ""
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := baseURL + "/" + "actors/by-id"

	queryParams := make(url.Values)
	queryParams.Add("namespace", fmt.Sprintf("%v", request.Namespace))
	if request.Datacenter != nil {
		queryParams.Add("datacenter", fmt.Sprintf("%v", *request.Datacenter))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *sdk.ActorsGetOrCreateByIdResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPut,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// 2 round trips:
//
// - GET /actors/names (fanout)
// - [api-peer] namespace::ops::resolve_for_name_global
func (c *Client) ActorsListNames(ctx context.Context, request *sdk.ActorsListNamesRequest) (*sdk.ActorsListNamesResponse, error) {
	baseURL := ""
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := baseURL + "/" + "actors/names"

	queryParams := make(url.Values)
	queryParams.Add("namespace", fmt.Sprintf("%v", request.Namespace))
	if request.Limit != nil {
		queryParams.Add("limit", fmt.Sprintf("%v", *request.Limit))
	}
	if request.Cursor != nil {
		queryParams.Add("cursor", fmt.Sprintf("%v", *request.Cursor))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *sdk.ActorsListNamesResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodGet,
			Headers:  c.header,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// 2 round trip:
//
// - GET /actors/{}
// - [api-peer] namespace::ops::resolve_for_name_global
func (c *Client) ActorsGet(ctx context.Context, actorId sdk.RivetId, request *sdk.ActorsGetRequest) (*sdk.ActorsGetResponse, error) {
	baseURL := ""
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"actors/%v", actorId)

	queryParams := make(url.Values)
	if request.Namespace != nil {
		queryParams.Add("namespace", fmt.Sprintf("%v", *request.Namespace))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *sdk.ActorsGetResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodGet,
			Headers:  c.header,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// 2 round trip:
//
// - DELETE /actors/{}
// - [api-peer] namespace::ops::resolve_for_name_global
func (c *Client) ActorsDelete(ctx context.Context, actorId sdk.RivetId, request *sdk.ActorsDeleteRequest) (sdk.ActorsDeleteResponse, error) {
	baseURL := ""
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"actors/%v", actorId)

	queryParams := make(url.Values)
	if request.Namespace != nil {
		queryParams.Add("namespace", fmt.Sprintf("%v", *request.Namespace))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response sdk.ActorsDeleteResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodDelete,
			Headers:  c.header,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}
