// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Error type for the `CancelGameLink` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelGameLinkError {
	/// Kind of error that occurred.
	pub kind: CancelGameLinkErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CancelGameLink` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelGameLinkErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelGameLinkError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			CancelGameLinkErrorKind::InternalError(_inner) => _inner.fmt(f),
			CancelGameLinkErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			CancelGameLinkErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			CancelGameLinkErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			CancelGameLinkErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			CancelGameLinkErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			CancelGameLinkErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for CancelGameLinkError {
	fn code(&self) -> Option<&str> {
		CancelGameLinkError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			CancelGameLinkErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			CancelGameLinkErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl CancelGameLinkError {
	/// Creates a new `CancelGameLinkError`.
	pub fn new(kind: CancelGameLinkErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `CancelGameLinkError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: CancelGameLinkErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `CancelGameLinkError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: CancelGameLinkErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `CancelGameLinkErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, CancelGameLinkErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `CancelGameLinkErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, CancelGameLinkErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `CancelGameLinkErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, CancelGameLinkErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `CancelGameLinkErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, CancelGameLinkErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `CancelGameLinkErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, CancelGameLinkErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `CancelGameLinkErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, CancelGameLinkErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for CancelGameLinkError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			CancelGameLinkErrorKind::InternalError(_inner) => Some(_inner),
			CancelGameLinkErrorKind::RateLimitError(_inner) => Some(_inner),
			CancelGameLinkErrorKind::ForbiddenError(_inner) => Some(_inner),
			CancelGameLinkErrorKind::UnauthorizedError(_inner) => Some(_inner),
			CancelGameLinkErrorKind::NotFoundError(_inner) => Some(_inner),
			CancelGameLinkErrorKind::BadRequestError(_inner) => Some(_inner),
			CancelGameLinkErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `CompleteGameLink` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CompleteGameLinkError {
	/// Kind of error that occurred.
	pub kind: CompleteGameLinkErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CompleteGameLink` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CompleteGameLinkErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CompleteGameLinkError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			CompleteGameLinkErrorKind::InternalError(_inner) => _inner.fmt(f),
			CompleteGameLinkErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			CompleteGameLinkErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			CompleteGameLinkErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			CompleteGameLinkErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			CompleteGameLinkErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			CompleteGameLinkErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for CompleteGameLinkError {
	fn code(&self) -> Option<&str> {
		CompleteGameLinkError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			CompleteGameLinkErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			CompleteGameLinkErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl CompleteGameLinkError {
	/// Creates a new `CompleteGameLinkError`.
	pub fn new(kind: CompleteGameLinkErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `CompleteGameLinkError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: CompleteGameLinkErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `CompleteGameLinkError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: CompleteGameLinkErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `CompleteGameLinkErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, CompleteGameLinkErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `CompleteGameLinkErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, CompleteGameLinkErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `CompleteGameLinkErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, CompleteGameLinkErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `CompleteGameLinkErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, CompleteGameLinkErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `CompleteGameLinkErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, CompleteGameLinkErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `CompleteGameLinkErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, CompleteGameLinkErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for CompleteGameLinkError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			CompleteGameLinkErrorKind::InternalError(_inner) => Some(_inner),
			CompleteGameLinkErrorKind::RateLimitError(_inner) => Some(_inner),
			CompleteGameLinkErrorKind::ForbiddenError(_inner) => Some(_inner),
			CompleteGameLinkErrorKind::UnauthorizedError(_inner) => Some(_inner),
			CompleteGameLinkErrorKind::NotFoundError(_inner) => Some(_inner),
			CompleteGameLinkErrorKind::BadRequestError(_inner) => Some(_inner),
			CompleteGameLinkErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `CompleteIdentityAvatarUpload` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CompleteIdentityAvatarUploadError {
	/// Kind of error that occurred.
	pub kind: CompleteIdentityAvatarUploadErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CompleteIdentityAvatarUpload` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CompleteIdentityAvatarUploadErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CompleteIdentityAvatarUploadError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			CompleteIdentityAvatarUploadErrorKind::InternalError(_inner) => _inner.fmt(f),
			CompleteIdentityAvatarUploadErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			CompleteIdentityAvatarUploadErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			CompleteIdentityAvatarUploadErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			CompleteIdentityAvatarUploadErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			CompleteIdentityAvatarUploadErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			CompleteIdentityAvatarUploadErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for CompleteIdentityAvatarUploadError {
	fn code(&self) -> Option<&str> {
		CompleteIdentityAvatarUploadError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			CompleteIdentityAvatarUploadErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			CompleteIdentityAvatarUploadErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl CompleteIdentityAvatarUploadError {
	/// Creates a new `CompleteIdentityAvatarUploadError`.
	pub fn new(kind: CompleteIdentityAvatarUploadErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `CompleteIdentityAvatarUploadError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: CompleteIdentityAvatarUploadErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `CompleteIdentityAvatarUploadError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: CompleteIdentityAvatarUploadErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `CompleteIdentityAvatarUploadErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			CompleteIdentityAvatarUploadErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `CompleteIdentityAvatarUploadErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			CompleteIdentityAvatarUploadErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `CompleteIdentityAvatarUploadErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			CompleteIdentityAvatarUploadErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `CompleteIdentityAvatarUploadErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			CompleteIdentityAvatarUploadErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `CompleteIdentityAvatarUploadErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			CompleteIdentityAvatarUploadErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `CompleteIdentityAvatarUploadErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			CompleteIdentityAvatarUploadErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for CompleteIdentityAvatarUploadError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			CompleteIdentityAvatarUploadErrorKind::InternalError(_inner) => Some(_inner),
			CompleteIdentityAvatarUploadErrorKind::RateLimitError(_inner) => Some(_inner),
			CompleteIdentityAvatarUploadErrorKind::ForbiddenError(_inner) => Some(_inner),
			CompleteIdentityAvatarUploadErrorKind::UnauthorizedError(_inner) => Some(_inner),
			CompleteIdentityAvatarUploadErrorKind::NotFoundError(_inner) => Some(_inner),
			CompleteIdentityAvatarUploadErrorKind::BadRequestError(_inner) => Some(_inner),
			CompleteIdentityAvatarUploadErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `FollowIdentity` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct FollowIdentityError {
	/// Kind of error that occurred.
	pub kind: FollowIdentityErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `FollowIdentity` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum FollowIdentityErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for FollowIdentityError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			FollowIdentityErrorKind::InternalError(_inner) => _inner.fmt(f),
			FollowIdentityErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			FollowIdentityErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			FollowIdentityErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			FollowIdentityErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			FollowIdentityErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			FollowIdentityErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for FollowIdentityError {
	fn code(&self) -> Option<&str> {
		FollowIdentityError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			FollowIdentityErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			FollowIdentityErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl FollowIdentityError {
	/// Creates a new `FollowIdentityError`.
	pub fn new(kind: FollowIdentityErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `FollowIdentityError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: FollowIdentityErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `FollowIdentityError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: FollowIdentityErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `FollowIdentityErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, FollowIdentityErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `FollowIdentityErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, FollowIdentityErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `FollowIdentityErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, FollowIdentityErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `FollowIdentityErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, FollowIdentityErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `FollowIdentityErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, FollowIdentityErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `FollowIdentityErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, FollowIdentityErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for FollowIdentityError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			FollowIdentityErrorKind::InternalError(_inner) => Some(_inner),
			FollowIdentityErrorKind::RateLimitError(_inner) => Some(_inner),
			FollowIdentityErrorKind::ForbiddenError(_inner) => Some(_inner),
			FollowIdentityErrorKind::UnauthorizedError(_inner) => Some(_inner),
			FollowIdentityErrorKind::NotFoundError(_inner) => Some(_inner),
			FollowIdentityErrorKind::BadRequestError(_inner) => Some(_inner),
			FollowIdentityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetGameLink` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGameLinkError {
	/// Kind of error that occurred.
	pub kind: GetGameLinkErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetGameLink` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGameLinkErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGameLinkError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetGameLinkErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetGameLinkErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetGameLinkErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetGameLinkErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetGameLinkErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetGameLinkErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetGameLinkErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetGameLinkError {
	fn code(&self) -> Option<&str> {
		GetGameLinkError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetGameLinkErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			GetGameLinkErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl GetGameLinkError {
	/// Creates a new `GetGameLinkError`.
	pub fn new(kind: GetGameLinkErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetGameLinkError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetGameLinkErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetGameLinkError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetGameLinkErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetGameLinkErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetGameLinkErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetGameLinkErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetGameLinkErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetGameLinkErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetGameLinkErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetGameLinkErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, GetGameLinkErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `GetGameLinkErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetGameLinkErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetGameLinkErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, GetGameLinkErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for GetGameLinkError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetGameLinkErrorKind::InternalError(_inner) => Some(_inner),
			GetGameLinkErrorKind::RateLimitError(_inner) => Some(_inner),
			GetGameLinkErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetGameLinkErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetGameLinkErrorKind::NotFoundError(_inner) => Some(_inner),
			GetGameLinkErrorKind::BadRequestError(_inner) => Some(_inner),
			GetGameLinkErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetIdentityHandles` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetIdentityHandlesError {
	/// Kind of error that occurred.
	pub kind: GetIdentityHandlesErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetIdentityHandles` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetIdentityHandlesErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetIdentityHandlesError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetIdentityHandlesErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetIdentityHandlesErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetIdentityHandlesErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetIdentityHandlesErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetIdentityHandlesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetIdentityHandlesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetIdentityHandlesErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetIdentityHandlesError {
	fn code(&self) -> Option<&str> {
		GetIdentityHandlesError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetIdentityHandlesErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			GetIdentityHandlesErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl GetIdentityHandlesError {
	/// Creates a new `GetIdentityHandlesError`.
	pub fn new(kind: GetIdentityHandlesErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetIdentityHandlesError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetIdentityHandlesErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetIdentityHandlesError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetIdentityHandlesErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetIdentityHandlesErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetIdentityHandlesErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetIdentityHandlesErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetIdentityHandlesErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetIdentityHandlesErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetIdentityHandlesErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetIdentityHandlesErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			GetIdentityHandlesErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `GetIdentityHandlesErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetIdentityHandlesErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetIdentityHandlesErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, GetIdentityHandlesErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for GetIdentityHandlesError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetIdentityHandlesErrorKind::InternalError(_inner) => Some(_inner),
			GetIdentityHandlesErrorKind::RateLimitError(_inner) => Some(_inner),
			GetIdentityHandlesErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetIdentityHandlesErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetIdentityHandlesErrorKind::NotFoundError(_inner) => Some(_inner),
			GetIdentityHandlesErrorKind::BadRequestError(_inner) => Some(_inner),
			GetIdentityHandlesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetIdentityProfile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetIdentityProfileError {
	/// Kind of error that occurred.
	pub kind: GetIdentityProfileErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetIdentityProfile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetIdentityProfileErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetIdentityProfileError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetIdentityProfileErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetIdentityProfileErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetIdentityProfileErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetIdentityProfileErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetIdentityProfileErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetIdentityProfileErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetIdentityProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetIdentityProfileError {
	fn code(&self) -> Option<&str> {
		GetIdentityProfileError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetIdentityProfileErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			GetIdentityProfileErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl GetIdentityProfileError {
	/// Creates a new `GetIdentityProfileError`.
	pub fn new(kind: GetIdentityProfileErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetIdentityProfileError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetIdentityProfileErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetIdentityProfileError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetIdentityProfileErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetIdentityProfileErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetIdentityProfileErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetIdentityProfileErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetIdentityProfileErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetIdentityProfileErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetIdentityProfileErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetIdentityProfileErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			GetIdentityProfileErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `GetIdentityProfileErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetIdentityProfileErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetIdentityProfileErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, GetIdentityProfileErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for GetIdentityProfileError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetIdentityProfileErrorKind::InternalError(_inner) => Some(_inner),
			GetIdentityProfileErrorKind::RateLimitError(_inner) => Some(_inner),
			GetIdentityProfileErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetIdentityProfileErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetIdentityProfileErrorKind::NotFoundError(_inner) => Some(_inner),
			GetIdentityProfileErrorKind::BadRequestError(_inner) => Some(_inner),
			GetIdentityProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetIdentitySelfProfile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetIdentitySelfProfileError {
	/// Kind of error that occurred.
	pub kind: GetIdentitySelfProfileErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetIdentitySelfProfile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetIdentitySelfProfileErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetIdentitySelfProfileError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetIdentitySelfProfileErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetIdentitySelfProfileErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetIdentitySelfProfileErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetIdentitySelfProfileErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetIdentitySelfProfileErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetIdentitySelfProfileErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetIdentitySelfProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetIdentitySelfProfileError {
	fn code(&self) -> Option<&str> {
		GetIdentitySelfProfileError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetIdentitySelfProfileErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			GetIdentitySelfProfileErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl GetIdentitySelfProfileError {
	/// Creates a new `GetIdentitySelfProfileError`.
	pub fn new(kind: GetIdentitySelfProfileErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetIdentitySelfProfileError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetIdentitySelfProfileErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetIdentitySelfProfileError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetIdentitySelfProfileErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetIdentitySelfProfileErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			GetIdentitySelfProfileErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `GetIdentitySelfProfileErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			GetIdentitySelfProfileErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `GetIdentitySelfProfileErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			GetIdentitySelfProfileErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `GetIdentitySelfProfileErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			GetIdentitySelfProfileErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `GetIdentitySelfProfileErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			GetIdentitySelfProfileErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `GetIdentitySelfProfileErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			GetIdentitySelfProfileErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for GetIdentitySelfProfileError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetIdentitySelfProfileErrorKind::InternalError(_inner) => Some(_inner),
			GetIdentitySelfProfileErrorKind::RateLimitError(_inner) => Some(_inner),
			GetIdentitySelfProfileErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetIdentitySelfProfileErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetIdentitySelfProfileErrorKind::NotFoundError(_inner) => Some(_inner),
			GetIdentitySelfProfileErrorKind::BadRequestError(_inner) => Some(_inner),
			GetIdentitySelfProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetIdentitySummaries` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetIdentitySummariesError {
	/// Kind of error that occurred.
	pub kind: GetIdentitySummariesErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetIdentitySummaries` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetIdentitySummariesErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetIdentitySummariesError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetIdentitySummariesErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetIdentitySummariesErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetIdentitySummariesErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetIdentitySummariesErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetIdentitySummariesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetIdentitySummariesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetIdentitySummariesErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetIdentitySummariesError {
	fn code(&self) -> Option<&str> {
		GetIdentitySummariesError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetIdentitySummariesErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			GetIdentitySummariesErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl GetIdentitySummariesError {
	/// Creates a new `GetIdentitySummariesError`.
	pub fn new(kind: GetIdentitySummariesErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetIdentitySummariesError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetIdentitySummariesErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetIdentitySummariesError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetIdentitySummariesErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetIdentitySummariesErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetIdentitySummariesErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetIdentitySummariesErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetIdentitySummariesErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetIdentitySummariesErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetIdentitySummariesErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetIdentitySummariesErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			GetIdentitySummariesErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `GetIdentitySummariesErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetIdentitySummariesErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetIdentitySummariesErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			GetIdentitySummariesErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for GetIdentitySummariesError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetIdentitySummariesErrorKind::InternalError(_inner) => Some(_inner),
			GetIdentitySummariesErrorKind::RateLimitError(_inner) => Some(_inner),
			GetIdentitySummariesErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetIdentitySummariesErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetIdentitySummariesErrorKind::NotFoundError(_inner) => Some(_inner),
			GetIdentitySummariesErrorKind::BadRequestError(_inner) => Some(_inner),
			GetIdentitySummariesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ListActivities` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListActivitiesError {
	/// Kind of error that occurred.
	pub kind: ListActivitiesErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListActivities` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListActivitiesErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListActivitiesError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ListActivitiesErrorKind::InternalError(_inner) => _inner.fmt(f),
			ListActivitiesErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ListActivitiesErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ListActivitiesErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ListActivitiesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ListActivitiesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ListActivitiesErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ListActivitiesError {
	fn code(&self) -> Option<&str> {
		ListActivitiesError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ListActivitiesErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			ListActivitiesErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl ListActivitiesError {
	/// Creates a new `ListActivitiesError`.
	pub fn new(kind: ListActivitiesErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ListActivitiesError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ListActivitiesErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ListActivitiesError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ListActivitiesErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ListActivitiesErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ListActivitiesErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ListActivitiesErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, ListActivitiesErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `ListActivitiesErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, ListActivitiesErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `ListActivitiesErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, ListActivitiesErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `ListActivitiesErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ListActivitiesErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ListActivitiesErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, ListActivitiesErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for ListActivitiesError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ListActivitiesErrorKind::InternalError(_inner) => Some(_inner),
			ListActivitiesErrorKind::RateLimitError(_inner) => Some(_inner),
			ListActivitiesErrorKind::ForbiddenError(_inner) => Some(_inner),
			ListActivitiesErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ListActivitiesErrorKind::NotFoundError(_inner) => Some(_inner),
			ListActivitiesErrorKind::BadRequestError(_inner) => Some(_inner),
			ListActivitiesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ListFollowers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFollowersError {
	/// Kind of error that occurred.
	pub kind: ListFollowersErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListFollowers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFollowersErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFollowersError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ListFollowersErrorKind::InternalError(_inner) => _inner.fmt(f),
			ListFollowersErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ListFollowersErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ListFollowersErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ListFollowersErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ListFollowersErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ListFollowersErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ListFollowersError {
	fn code(&self) -> Option<&str> {
		ListFollowersError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ListFollowersErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			ListFollowersErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl ListFollowersError {
	/// Creates a new `ListFollowersError`.
	pub fn new(kind: ListFollowersErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ListFollowersError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ListFollowersErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ListFollowersError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ListFollowersErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ListFollowersErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ListFollowersErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ListFollowersErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, ListFollowersErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `ListFollowersErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, ListFollowersErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `ListFollowersErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, ListFollowersErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `ListFollowersErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ListFollowersErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ListFollowersErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, ListFollowersErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for ListFollowersError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ListFollowersErrorKind::InternalError(_inner) => Some(_inner),
			ListFollowersErrorKind::RateLimitError(_inner) => Some(_inner),
			ListFollowersErrorKind::ForbiddenError(_inner) => Some(_inner),
			ListFollowersErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ListFollowersErrorKind::NotFoundError(_inner) => Some(_inner),
			ListFollowersErrorKind::BadRequestError(_inner) => Some(_inner),
			ListFollowersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ListFollowing` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFollowingError {
	/// Kind of error that occurred.
	pub kind: ListFollowingErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListFollowing` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFollowingErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFollowingError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ListFollowingErrorKind::InternalError(_inner) => _inner.fmt(f),
			ListFollowingErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ListFollowingErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ListFollowingErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ListFollowingErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ListFollowingErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ListFollowingErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ListFollowingError {
	fn code(&self) -> Option<&str> {
		ListFollowingError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ListFollowingErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			ListFollowingErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl ListFollowingError {
	/// Creates a new `ListFollowingError`.
	pub fn new(kind: ListFollowingErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ListFollowingError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ListFollowingErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ListFollowingError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ListFollowingErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ListFollowingErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ListFollowingErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ListFollowingErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, ListFollowingErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `ListFollowingErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, ListFollowingErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `ListFollowingErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, ListFollowingErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `ListFollowingErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ListFollowingErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ListFollowingErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, ListFollowingErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for ListFollowingError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ListFollowingErrorKind::InternalError(_inner) => Some(_inner),
			ListFollowingErrorKind::RateLimitError(_inner) => Some(_inner),
			ListFollowingErrorKind::ForbiddenError(_inner) => Some(_inner),
			ListFollowingErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ListFollowingErrorKind::NotFoundError(_inner) => Some(_inner),
			ListFollowingErrorKind::BadRequestError(_inner) => Some(_inner),
			ListFollowingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ListFriends` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFriendsError {
	/// Kind of error that occurred.
	pub kind: ListFriendsErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListFriends` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFriendsErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFriendsError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ListFriendsErrorKind::InternalError(_inner) => _inner.fmt(f),
			ListFriendsErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ListFriendsErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ListFriendsErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ListFriendsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ListFriendsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ListFriendsErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ListFriendsError {
	fn code(&self) -> Option<&str> {
		ListFriendsError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ListFriendsErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			ListFriendsErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl ListFriendsError {
	/// Creates a new `ListFriendsError`.
	pub fn new(kind: ListFriendsErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ListFriendsError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ListFriendsErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ListFriendsError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ListFriendsErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ListFriendsErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ListFriendsErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ListFriendsErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, ListFriendsErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `ListFriendsErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, ListFriendsErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `ListFriendsErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, ListFriendsErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `ListFriendsErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ListFriendsErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ListFriendsErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, ListFriendsErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for ListFriendsError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ListFriendsErrorKind::InternalError(_inner) => Some(_inner),
			ListFriendsErrorKind::RateLimitError(_inner) => Some(_inner),
			ListFriendsErrorKind::ForbiddenError(_inner) => Some(_inner),
			ListFriendsErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ListFriendsErrorKind::NotFoundError(_inner) => Some(_inner),
			ListFriendsErrorKind::BadRequestError(_inner) => Some(_inner),
			ListFriendsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ListMutualFriends` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListMutualFriendsError {
	/// Kind of error that occurred.
	pub kind: ListMutualFriendsErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListMutualFriends` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListMutualFriendsErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListMutualFriendsError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ListMutualFriendsErrorKind::InternalError(_inner) => _inner.fmt(f),
			ListMutualFriendsErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ListMutualFriendsErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ListMutualFriendsErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ListMutualFriendsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ListMutualFriendsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ListMutualFriendsErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ListMutualFriendsError {
	fn code(&self) -> Option<&str> {
		ListMutualFriendsError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ListMutualFriendsErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			ListMutualFriendsErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl ListMutualFriendsError {
	/// Creates a new `ListMutualFriendsError`.
	pub fn new(kind: ListMutualFriendsErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ListMutualFriendsError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ListMutualFriendsErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ListMutualFriendsError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ListMutualFriendsErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ListMutualFriendsErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ListMutualFriendsErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ListMutualFriendsErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, ListMutualFriendsErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `ListMutualFriendsErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, ListMutualFriendsErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `ListMutualFriendsErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, ListMutualFriendsErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `ListMutualFriendsErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ListMutualFriendsErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ListMutualFriendsErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, ListMutualFriendsErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for ListMutualFriendsError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ListMutualFriendsErrorKind::InternalError(_inner) => Some(_inner),
			ListMutualFriendsErrorKind::RateLimitError(_inner) => Some(_inner),
			ListMutualFriendsErrorKind::ForbiddenError(_inner) => Some(_inner),
			ListMutualFriendsErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ListMutualFriendsErrorKind::NotFoundError(_inner) => Some(_inner),
			ListMutualFriendsErrorKind::BadRequestError(_inner) => Some(_inner),
			ListMutualFriendsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ListRecentFollowers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRecentFollowersError {
	/// Kind of error that occurred.
	pub kind: ListRecentFollowersErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListRecentFollowers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRecentFollowersErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRecentFollowersError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ListRecentFollowersErrorKind::InternalError(_inner) => _inner.fmt(f),
			ListRecentFollowersErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ListRecentFollowersErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ListRecentFollowersErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ListRecentFollowersErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ListRecentFollowersErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ListRecentFollowersErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ListRecentFollowersError {
	fn code(&self) -> Option<&str> {
		ListRecentFollowersError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ListRecentFollowersErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			ListRecentFollowersErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl ListRecentFollowersError {
	/// Creates a new `ListRecentFollowersError`.
	pub fn new(kind: ListRecentFollowersErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ListRecentFollowersError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ListRecentFollowersErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ListRecentFollowersError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ListRecentFollowersErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ListRecentFollowersErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ListRecentFollowersErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ListRecentFollowersErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, ListRecentFollowersErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `ListRecentFollowersErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, ListRecentFollowersErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `ListRecentFollowersErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			ListRecentFollowersErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `ListRecentFollowersErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ListRecentFollowersErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ListRecentFollowersErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, ListRecentFollowersErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for ListRecentFollowersError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ListRecentFollowersErrorKind::InternalError(_inner) => Some(_inner),
			ListRecentFollowersErrorKind::RateLimitError(_inner) => Some(_inner),
			ListRecentFollowersErrorKind::ForbiddenError(_inner) => Some(_inner),
			ListRecentFollowersErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ListRecentFollowersErrorKind::NotFoundError(_inner) => Some(_inner),
			ListRecentFollowersErrorKind::BadRequestError(_inner) => Some(_inner),
			ListRecentFollowersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `MarkDeletion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct MarkDeletionError {
	/// Kind of error that occurred.
	pub kind: MarkDeletionErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `MarkDeletion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum MarkDeletionErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for MarkDeletionError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			MarkDeletionErrorKind::InternalError(_inner) => _inner.fmt(f),
			MarkDeletionErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			MarkDeletionErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			MarkDeletionErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			MarkDeletionErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			MarkDeletionErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			MarkDeletionErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for MarkDeletionError {
	fn code(&self) -> Option<&str> {
		MarkDeletionError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			MarkDeletionErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			MarkDeletionErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl MarkDeletionError {
	/// Creates a new `MarkDeletionError`.
	pub fn new(kind: MarkDeletionErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `MarkDeletionError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: MarkDeletionErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `MarkDeletionError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: MarkDeletionErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `MarkDeletionErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, MarkDeletionErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `MarkDeletionErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, MarkDeletionErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `MarkDeletionErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, MarkDeletionErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `MarkDeletionErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, MarkDeletionErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `MarkDeletionErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, MarkDeletionErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `MarkDeletionErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, MarkDeletionErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for MarkDeletionError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			MarkDeletionErrorKind::InternalError(_inner) => Some(_inner),
			MarkDeletionErrorKind::RateLimitError(_inner) => Some(_inner),
			MarkDeletionErrorKind::ForbiddenError(_inner) => Some(_inner),
			MarkDeletionErrorKind::UnauthorizedError(_inner) => Some(_inner),
			MarkDeletionErrorKind::NotFoundError(_inner) => Some(_inner),
			MarkDeletionErrorKind::BadRequestError(_inner) => Some(_inner),
			MarkDeletionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `PrepareGameLink` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PrepareGameLinkError {
	/// Kind of error that occurred.
	pub kind: PrepareGameLinkErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `PrepareGameLink` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PrepareGameLinkErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PrepareGameLinkError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			PrepareGameLinkErrorKind::InternalError(_inner) => _inner.fmt(f),
			PrepareGameLinkErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			PrepareGameLinkErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			PrepareGameLinkErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			PrepareGameLinkErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			PrepareGameLinkErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			PrepareGameLinkErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for PrepareGameLinkError {
	fn code(&self) -> Option<&str> {
		PrepareGameLinkError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			PrepareGameLinkErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			PrepareGameLinkErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl PrepareGameLinkError {
	/// Creates a new `PrepareGameLinkError`.
	pub fn new(kind: PrepareGameLinkErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `PrepareGameLinkError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: PrepareGameLinkErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `PrepareGameLinkError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: PrepareGameLinkErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `PrepareGameLinkErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, PrepareGameLinkErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `PrepareGameLinkErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, PrepareGameLinkErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `PrepareGameLinkErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, PrepareGameLinkErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `PrepareGameLinkErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, PrepareGameLinkErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `PrepareGameLinkErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, PrepareGameLinkErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `PrepareGameLinkErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, PrepareGameLinkErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for PrepareGameLinkError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			PrepareGameLinkErrorKind::InternalError(_inner) => Some(_inner),
			PrepareGameLinkErrorKind::RateLimitError(_inner) => Some(_inner),
			PrepareGameLinkErrorKind::ForbiddenError(_inner) => Some(_inner),
			PrepareGameLinkErrorKind::UnauthorizedError(_inner) => Some(_inner),
			PrepareGameLinkErrorKind::NotFoundError(_inner) => Some(_inner),
			PrepareGameLinkErrorKind::BadRequestError(_inner) => Some(_inner),
			PrepareGameLinkErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `PrepareIdentityAvatarUpload` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PrepareIdentityAvatarUploadError {
	/// Kind of error that occurred.
	pub kind: PrepareIdentityAvatarUploadErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `PrepareIdentityAvatarUpload` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PrepareIdentityAvatarUploadErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PrepareIdentityAvatarUploadError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			PrepareIdentityAvatarUploadErrorKind::InternalError(_inner) => _inner.fmt(f),
			PrepareIdentityAvatarUploadErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			PrepareIdentityAvatarUploadErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			PrepareIdentityAvatarUploadErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			PrepareIdentityAvatarUploadErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			PrepareIdentityAvatarUploadErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			PrepareIdentityAvatarUploadErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for PrepareIdentityAvatarUploadError {
	fn code(&self) -> Option<&str> {
		PrepareIdentityAvatarUploadError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			PrepareIdentityAvatarUploadErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			PrepareIdentityAvatarUploadErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl PrepareIdentityAvatarUploadError {
	/// Creates a new `PrepareIdentityAvatarUploadError`.
	pub fn new(kind: PrepareIdentityAvatarUploadErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `PrepareIdentityAvatarUploadError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: PrepareIdentityAvatarUploadErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `PrepareIdentityAvatarUploadError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: PrepareIdentityAvatarUploadErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `PrepareIdentityAvatarUploadErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			PrepareIdentityAvatarUploadErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `PrepareIdentityAvatarUploadErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			PrepareIdentityAvatarUploadErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `PrepareIdentityAvatarUploadErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			PrepareIdentityAvatarUploadErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `PrepareIdentityAvatarUploadErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			PrepareIdentityAvatarUploadErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `PrepareIdentityAvatarUploadErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			PrepareIdentityAvatarUploadErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `PrepareIdentityAvatarUploadErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			PrepareIdentityAvatarUploadErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for PrepareIdentityAvatarUploadError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			PrepareIdentityAvatarUploadErrorKind::InternalError(_inner) => Some(_inner),
			PrepareIdentityAvatarUploadErrorKind::RateLimitError(_inner) => Some(_inner),
			PrepareIdentityAvatarUploadErrorKind::ForbiddenError(_inner) => Some(_inner),
			PrepareIdentityAvatarUploadErrorKind::UnauthorizedError(_inner) => Some(_inner),
			PrepareIdentityAvatarUploadErrorKind::NotFoundError(_inner) => Some(_inner),
			PrepareIdentityAvatarUploadErrorKind::BadRequestError(_inner) => Some(_inner),
			PrepareIdentityAvatarUploadErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `RecentFollowerIgnore` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RecentFollowerIgnoreError {
	/// Kind of error that occurred.
	pub kind: RecentFollowerIgnoreErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `RecentFollowerIgnore` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RecentFollowerIgnoreErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RecentFollowerIgnoreError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			RecentFollowerIgnoreErrorKind::InternalError(_inner) => _inner.fmt(f),
			RecentFollowerIgnoreErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			RecentFollowerIgnoreErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			RecentFollowerIgnoreErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			RecentFollowerIgnoreErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			RecentFollowerIgnoreErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			RecentFollowerIgnoreErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for RecentFollowerIgnoreError {
	fn code(&self) -> Option<&str> {
		RecentFollowerIgnoreError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			RecentFollowerIgnoreErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			RecentFollowerIgnoreErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl RecentFollowerIgnoreError {
	/// Creates a new `RecentFollowerIgnoreError`.
	pub fn new(kind: RecentFollowerIgnoreErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `RecentFollowerIgnoreError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: RecentFollowerIgnoreErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `RecentFollowerIgnoreError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: RecentFollowerIgnoreErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `RecentFollowerIgnoreErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, RecentFollowerIgnoreErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `RecentFollowerIgnoreErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, RecentFollowerIgnoreErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `RecentFollowerIgnoreErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, RecentFollowerIgnoreErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `RecentFollowerIgnoreErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			RecentFollowerIgnoreErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `RecentFollowerIgnoreErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, RecentFollowerIgnoreErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `RecentFollowerIgnoreErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			RecentFollowerIgnoreErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for RecentFollowerIgnoreError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			RecentFollowerIgnoreErrorKind::InternalError(_inner) => Some(_inner),
			RecentFollowerIgnoreErrorKind::RateLimitError(_inner) => Some(_inner),
			RecentFollowerIgnoreErrorKind::ForbiddenError(_inner) => Some(_inner),
			RecentFollowerIgnoreErrorKind::UnauthorizedError(_inner) => Some(_inner),
			RecentFollowerIgnoreErrorKind::NotFoundError(_inner) => Some(_inner),
			RecentFollowerIgnoreErrorKind::BadRequestError(_inner) => Some(_inner),
			RecentFollowerIgnoreErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `RemoveIdentityGameActivity` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveIdentityGameActivityError {
	/// Kind of error that occurred.
	pub kind: RemoveIdentityGameActivityErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `RemoveIdentityGameActivity` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveIdentityGameActivityErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveIdentityGameActivityError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			RemoveIdentityGameActivityErrorKind::InternalError(_inner) => _inner.fmt(f),
			RemoveIdentityGameActivityErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			RemoveIdentityGameActivityErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			RemoveIdentityGameActivityErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			RemoveIdentityGameActivityErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			RemoveIdentityGameActivityErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			RemoveIdentityGameActivityErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for RemoveIdentityGameActivityError {
	fn code(&self) -> Option<&str> {
		RemoveIdentityGameActivityError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			RemoveIdentityGameActivityErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			RemoveIdentityGameActivityErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl RemoveIdentityGameActivityError {
	/// Creates a new `RemoveIdentityGameActivityError`.
	pub fn new(kind: RemoveIdentityGameActivityErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `RemoveIdentityGameActivityError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: RemoveIdentityGameActivityErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `RemoveIdentityGameActivityError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: RemoveIdentityGameActivityErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `RemoveIdentityGameActivityErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			RemoveIdentityGameActivityErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `RemoveIdentityGameActivityErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			RemoveIdentityGameActivityErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `RemoveIdentityGameActivityErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			RemoveIdentityGameActivityErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `RemoveIdentityGameActivityErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			RemoveIdentityGameActivityErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `RemoveIdentityGameActivityErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			RemoveIdentityGameActivityErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `RemoveIdentityGameActivityErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			RemoveIdentityGameActivityErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for RemoveIdentityGameActivityError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			RemoveIdentityGameActivityErrorKind::InternalError(_inner) => Some(_inner),
			RemoveIdentityGameActivityErrorKind::RateLimitError(_inner) => Some(_inner),
			RemoveIdentityGameActivityErrorKind::ForbiddenError(_inner) => Some(_inner),
			RemoveIdentityGameActivityErrorKind::UnauthorizedError(_inner) => Some(_inner),
			RemoveIdentityGameActivityErrorKind::NotFoundError(_inner) => Some(_inner),
			RemoveIdentityGameActivityErrorKind::BadRequestError(_inner) => Some(_inner),
			RemoveIdentityGameActivityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ReportIdentity` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ReportIdentityError {
	/// Kind of error that occurred.
	pub kind: ReportIdentityErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ReportIdentity` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ReportIdentityErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ReportIdentityError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ReportIdentityErrorKind::InternalError(_inner) => _inner.fmt(f),
			ReportIdentityErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ReportIdentityErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ReportIdentityErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ReportIdentityErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ReportIdentityErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ReportIdentityErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ReportIdentityError {
	fn code(&self) -> Option<&str> {
		ReportIdentityError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ReportIdentityErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			ReportIdentityErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl ReportIdentityError {
	/// Creates a new `ReportIdentityError`.
	pub fn new(kind: ReportIdentityErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ReportIdentityError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ReportIdentityErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ReportIdentityError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ReportIdentityErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ReportIdentityErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ReportIdentityErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ReportIdentityErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, ReportIdentityErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `ReportIdentityErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, ReportIdentityErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `ReportIdentityErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, ReportIdentityErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `ReportIdentityErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ReportIdentityErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ReportIdentityErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, ReportIdentityErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for ReportIdentityError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ReportIdentityErrorKind::InternalError(_inner) => Some(_inner),
			ReportIdentityErrorKind::RateLimitError(_inner) => Some(_inner),
			ReportIdentityErrorKind::ForbiddenError(_inner) => Some(_inner),
			ReportIdentityErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ReportIdentityErrorKind::NotFoundError(_inner) => Some(_inner),
			ReportIdentityErrorKind::BadRequestError(_inner) => Some(_inner),
			ReportIdentityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `SearchIdentities` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SearchIdentitiesError {
	/// Kind of error that occurred.
	pub kind: SearchIdentitiesErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `SearchIdentities` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SearchIdentitiesErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SearchIdentitiesError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			SearchIdentitiesErrorKind::InternalError(_inner) => _inner.fmt(f),
			SearchIdentitiesErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			SearchIdentitiesErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			SearchIdentitiesErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			SearchIdentitiesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			SearchIdentitiesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			SearchIdentitiesErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for SearchIdentitiesError {
	fn code(&self) -> Option<&str> {
		SearchIdentitiesError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			SearchIdentitiesErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			SearchIdentitiesErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl SearchIdentitiesError {
	/// Creates a new `SearchIdentitiesError`.
	pub fn new(kind: SearchIdentitiesErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `SearchIdentitiesError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: SearchIdentitiesErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `SearchIdentitiesError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: SearchIdentitiesErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `SearchIdentitiesErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, SearchIdentitiesErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `SearchIdentitiesErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, SearchIdentitiesErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `SearchIdentitiesErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, SearchIdentitiesErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `SearchIdentitiesErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, SearchIdentitiesErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `SearchIdentitiesErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, SearchIdentitiesErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `SearchIdentitiesErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, SearchIdentitiesErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for SearchIdentitiesError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			SearchIdentitiesErrorKind::InternalError(_inner) => Some(_inner),
			SearchIdentitiesErrorKind::RateLimitError(_inner) => Some(_inner),
			SearchIdentitiesErrorKind::ForbiddenError(_inner) => Some(_inner),
			SearchIdentitiesErrorKind::UnauthorizedError(_inner) => Some(_inner),
			SearchIdentitiesErrorKind::NotFoundError(_inner) => Some(_inner),
			SearchIdentitiesErrorKind::BadRequestError(_inner) => Some(_inner),
			SearchIdentitiesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `SetIdentityGameActivity` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetIdentityGameActivityError {
	/// Kind of error that occurred.
	pub kind: SetIdentityGameActivityErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `SetIdentityGameActivity` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetIdentityGameActivityErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetIdentityGameActivityError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			SetIdentityGameActivityErrorKind::InternalError(_inner) => _inner.fmt(f),
			SetIdentityGameActivityErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			SetIdentityGameActivityErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			SetIdentityGameActivityErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			SetIdentityGameActivityErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			SetIdentityGameActivityErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			SetIdentityGameActivityErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for SetIdentityGameActivityError {
	fn code(&self) -> Option<&str> {
		SetIdentityGameActivityError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			SetIdentityGameActivityErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			SetIdentityGameActivityErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl SetIdentityGameActivityError {
	/// Creates a new `SetIdentityGameActivityError`.
	pub fn new(kind: SetIdentityGameActivityErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `SetIdentityGameActivityError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: SetIdentityGameActivityErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `SetIdentityGameActivityError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: SetIdentityGameActivityErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `SetIdentityGameActivityErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			SetIdentityGameActivityErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `SetIdentityGameActivityErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			SetIdentityGameActivityErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `SetIdentityGameActivityErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			SetIdentityGameActivityErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `SetIdentityGameActivityErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			SetIdentityGameActivityErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `SetIdentityGameActivityErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			SetIdentityGameActivityErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `SetIdentityGameActivityErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			SetIdentityGameActivityErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for SetIdentityGameActivityError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			SetIdentityGameActivityErrorKind::InternalError(_inner) => Some(_inner),
			SetIdentityGameActivityErrorKind::RateLimitError(_inner) => Some(_inner),
			SetIdentityGameActivityErrorKind::ForbiddenError(_inner) => Some(_inner),
			SetIdentityGameActivityErrorKind::UnauthorizedError(_inner) => Some(_inner),
			SetIdentityGameActivityErrorKind::NotFoundError(_inner) => Some(_inner),
			SetIdentityGameActivityErrorKind::BadRequestError(_inner) => Some(_inner),
			SetIdentityGameActivityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `SetupIdentity` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetupIdentityError {
	/// Kind of error that occurred.
	pub kind: SetupIdentityErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `SetupIdentity` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetupIdentityErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetupIdentityError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			SetupIdentityErrorKind::InternalError(_inner) => _inner.fmt(f),
			SetupIdentityErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			SetupIdentityErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			SetupIdentityErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			SetupIdentityErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			SetupIdentityErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			SetupIdentityErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for SetupIdentityError {
	fn code(&self) -> Option<&str> {
		SetupIdentityError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			SetupIdentityErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			SetupIdentityErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl SetupIdentityError {
	/// Creates a new `SetupIdentityError`.
	pub fn new(kind: SetupIdentityErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `SetupIdentityError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: SetupIdentityErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `SetupIdentityError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: SetupIdentityErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `SetupIdentityErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, SetupIdentityErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `SetupIdentityErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, SetupIdentityErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `SetupIdentityErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, SetupIdentityErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `SetupIdentityErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, SetupIdentityErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `SetupIdentityErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, SetupIdentityErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `SetupIdentityErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, SetupIdentityErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for SetupIdentityError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			SetupIdentityErrorKind::InternalError(_inner) => Some(_inner),
			SetupIdentityErrorKind::RateLimitError(_inner) => Some(_inner),
			SetupIdentityErrorKind::ForbiddenError(_inner) => Some(_inner),
			SetupIdentityErrorKind::UnauthorizedError(_inner) => Some(_inner),
			SetupIdentityErrorKind::NotFoundError(_inner) => Some(_inner),
			SetupIdentityErrorKind::BadRequestError(_inner) => Some(_inner),
			SetupIdentityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `SignupForBeta` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SignupForBetaError {
	/// Kind of error that occurred.
	pub kind: SignupForBetaErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `SignupForBeta` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SignupForBetaErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SignupForBetaError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			SignupForBetaErrorKind::InternalError(_inner) => _inner.fmt(f),
			SignupForBetaErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			SignupForBetaErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			SignupForBetaErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			SignupForBetaErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			SignupForBetaErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			SignupForBetaErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for SignupForBetaError {
	fn code(&self) -> Option<&str> {
		SignupForBetaError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			SignupForBetaErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			SignupForBetaErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl SignupForBetaError {
	/// Creates a new `SignupForBetaError`.
	pub fn new(kind: SignupForBetaErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `SignupForBetaError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: SignupForBetaErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `SignupForBetaError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: SignupForBetaErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `SignupForBetaErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, SignupForBetaErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `SignupForBetaErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, SignupForBetaErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `SignupForBetaErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, SignupForBetaErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `SignupForBetaErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, SignupForBetaErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `SignupForBetaErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, SignupForBetaErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `SignupForBetaErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, SignupForBetaErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for SignupForBetaError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			SignupForBetaErrorKind::InternalError(_inner) => Some(_inner),
			SignupForBetaErrorKind::RateLimitError(_inner) => Some(_inner),
			SignupForBetaErrorKind::ForbiddenError(_inner) => Some(_inner),
			SignupForBetaErrorKind::UnauthorizedError(_inner) => Some(_inner),
			SignupForBetaErrorKind::NotFoundError(_inner) => Some(_inner),
			SignupForBetaErrorKind::BadRequestError(_inner) => Some(_inner),
			SignupForBetaErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `UnfollowIdentity` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UnfollowIdentityError {
	/// Kind of error that occurred.
	pub kind: UnfollowIdentityErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UnfollowIdentity` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UnfollowIdentityErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UnfollowIdentityError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			UnfollowIdentityErrorKind::InternalError(_inner) => _inner.fmt(f),
			UnfollowIdentityErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			UnfollowIdentityErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			UnfollowIdentityErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			UnfollowIdentityErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			UnfollowIdentityErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			UnfollowIdentityErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for UnfollowIdentityError {
	fn code(&self) -> Option<&str> {
		UnfollowIdentityError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			UnfollowIdentityErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			UnfollowIdentityErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl UnfollowIdentityError {
	/// Creates a new `UnfollowIdentityError`.
	pub fn new(kind: UnfollowIdentityErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `UnfollowIdentityError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: UnfollowIdentityErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `UnfollowIdentityError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: UnfollowIdentityErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `UnfollowIdentityErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, UnfollowIdentityErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `UnfollowIdentityErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, UnfollowIdentityErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `UnfollowIdentityErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, UnfollowIdentityErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `UnfollowIdentityErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, UnfollowIdentityErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `UnfollowIdentityErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, UnfollowIdentityErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `UnfollowIdentityErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, UnfollowIdentityErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for UnfollowIdentityError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			UnfollowIdentityErrorKind::InternalError(_inner) => Some(_inner),
			UnfollowIdentityErrorKind::RateLimitError(_inner) => Some(_inner),
			UnfollowIdentityErrorKind::ForbiddenError(_inner) => Some(_inner),
			UnfollowIdentityErrorKind::UnauthorizedError(_inner) => Some(_inner),
			UnfollowIdentityErrorKind::NotFoundError(_inner) => Some(_inner),
			UnfollowIdentityErrorKind::BadRequestError(_inner) => Some(_inner),
			UnfollowIdentityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `UnmarkDeletion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UnmarkDeletionError {
	/// Kind of error that occurred.
	pub kind: UnmarkDeletionErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UnmarkDeletion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UnmarkDeletionErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UnmarkDeletionError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			UnmarkDeletionErrorKind::InternalError(_inner) => _inner.fmt(f),
			UnmarkDeletionErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			UnmarkDeletionErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			UnmarkDeletionErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			UnmarkDeletionErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			UnmarkDeletionErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			UnmarkDeletionErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for UnmarkDeletionError {
	fn code(&self) -> Option<&str> {
		UnmarkDeletionError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			UnmarkDeletionErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			UnmarkDeletionErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl UnmarkDeletionError {
	/// Creates a new `UnmarkDeletionError`.
	pub fn new(kind: UnmarkDeletionErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `UnmarkDeletionError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: UnmarkDeletionErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `UnmarkDeletionError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: UnmarkDeletionErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `UnmarkDeletionErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, UnmarkDeletionErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `UnmarkDeletionErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, UnmarkDeletionErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `UnmarkDeletionErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, UnmarkDeletionErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `UnmarkDeletionErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, UnmarkDeletionErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `UnmarkDeletionErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, UnmarkDeletionErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `UnmarkDeletionErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, UnmarkDeletionErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for UnmarkDeletionError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			UnmarkDeletionErrorKind::InternalError(_inner) => Some(_inner),
			UnmarkDeletionErrorKind::RateLimitError(_inner) => Some(_inner),
			UnmarkDeletionErrorKind::ForbiddenError(_inner) => Some(_inner),
			UnmarkDeletionErrorKind::UnauthorizedError(_inner) => Some(_inner),
			UnmarkDeletionErrorKind::NotFoundError(_inner) => Some(_inner),
			UnmarkDeletionErrorKind::BadRequestError(_inner) => Some(_inner),
			UnmarkDeletionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `UpdateIdentityProfile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateIdentityProfileError {
	/// Kind of error that occurred.
	pub kind: UpdateIdentityProfileErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateIdentityProfile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateIdentityProfileErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateIdentityProfileError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			UpdateIdentityProfileErrorKind::InternalError(_inner) => _inner.fmt(f),
			UpdateIdentityProfileErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			UpdateIdentityProfileErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			UpdateIdentityProfileErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			UpdateIdentityProfileErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			UpdateIdentityProfileErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			UpdateIdentityProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateIdentityProfileError {
	fn code(&self) -> Option<&str> {
		UpdateIdentityProfileError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			UpdateIdentityProfileErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			UpdateIdentityProfileErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl UpdateIdentityProfileError {
	/// Creates a new `UpdateIdentityProfileError`.
	pub fn new(kind: UpdateIdentityProfileErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `UpdateIdentityProfileError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: UpdateIdentityProfileErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `UpdateIdentityProfileError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: UpdateIdentityProfileErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `UpdateIdentityProfileErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, UpdateIdentityProfileErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `UpdateIdentityProfileErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateIdentityProfileErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateIdentityProfileErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateIdentityProfileErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateIdentityProfileErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateIdentityProfileErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateIdentityProfileErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, UpdateIdentityProfileErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `UpdateIdentityProfileErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateIdentityProfileErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for UpdateIdentityProfileError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			UpdateIdentityProfileErrorKind::InternalError(_inner) => Some(_inner),
			UpdateIdentityProfileErrorKind::RateLimitError(_inner) => Some(_inner),
			UpdateIdentityProfileErrorKind::ForbiddenError(_inner) => Some(_inner),
			UpdateIdentityProfileErrorKind::UnauthorizedError(_inner) => Some(_inner),
			UpdateIdentityProfileErrorKind::NotFoundError(_inner) => Some(_inner),
			UpdateIdentityProfileErrorKind::BadRequestError(_inner) => Some(_inner),
			UpdateIdentityProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `UpdateIdentityStatus` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateIdentityStatusError {
	/// Kind of error that occurred.
	pub kind: UpdateIdentityStatusErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateIdentityStatus` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateIdentityStatusErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateIdentityStatusError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			UpdateIdentityStatusErrorKind::InternalError(_inner) => _inner.fmt(f),
			UpdateIdentityStatusErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			UpdateIdentityStatusErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			UpdateIdentityStatusErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			UpdateIdentityStatusErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			UpdateIdentityStatusErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			UpdateIdentityStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateIdentityStatusError {
	fn code(&self) -> Option<&str> {
		UpdateIdentityStatusError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			UpdateIdentityStatusErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			UpdateIdentityStatusErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl UpdateIdentityStatusError {
	/// Creates a new `UpdateIdentityStatusError`.
	pub fn new(kind: UpdateIdentityStatusErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `UpdateIdentityStatusError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: UpdateIdentityStatusErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `UpdateIdentityStatusError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: UpdateIdentityStatusErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `UpdateIdentityStatusErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, UpdateIdentityStatusErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `UpdateIdentityStatusErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, UpdateIdentityStatusErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `UpdateIdentityStatusErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, UpdateIdentityStatusErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `UpdateIdentityStatusErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateIdentityStatusErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateIdentityStatusErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, UpdateIdentityStatusErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `UpdateIdentityStatusErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateIdentityStatusErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for UpdateIdentityStatusError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			UpdateIdentityStatusErrorKind::InternalError(_inner) => Some(_inner),
			UpdateIdentityStatusErrorKind::RateLimitError(_inner) => Some(_inner),
			UpdateIdentityStatusErrorKind::ForbiddenError(_inner) => Some(_inner),
			UpdateIdentityStatusErrorKind::UnauthorizedError(_inner) => Some(_inner),
			UpdateIdentityStatusErrorKind::NotFoundError(_inner) => Some(_inner),
			UpdateIdentityStatusErrorKind::BadRequestError(_inner) => Some(_inner),
			UpdateIdentityStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ValidateIdentityProfile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ValidateIdentityProfileError {
	/// Kind of error that occurred.
	pub kind: ValidateIdentityProfileErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ValidateIdentityProfile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ValidateIdentityProfileErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ValidateIdentityProfileError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ValidateIdentityProfileErrorKind::InternalError(_inner) => _inner.fmt(f),
			ValidateIdentityProfileErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ValidateIdentityProfileErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ValidateIdentityProfileErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ValidateIdentityProfileErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ValidateIdentityProfileErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ValidateIdentityProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ValidateIdentityProfileError {
	fn code(&self) -> Option<&str> {
		ValidateIdentityProfileError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ValidateIdentityProfileErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			ValidateIdentityProfileErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl ValidateIdentityProfileError {
	/// Creates a new `ValidateIdentityProfileError`.
	pub fn new(kind: ValidateIdentityProfileErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ValidateIdentityProfileError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ValidateIdentityProfileErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ValidateIdentityProfileError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ValidateIdentityProfileErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ValidateIdentityProfileErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateIdentityProfileErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateIdentityProfileErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateIdentityProfileErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateIdentityProfileErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateIdentityProfileErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateIdentityProfileErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateIdentityProfileErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateIdentityProfileErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateIdentityProfileErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateIdentityProfileErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateIdentityProfileErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for ValidateIdentityProfileError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ValidateIdentityProfileErrorKind::InternalError(_inner) => Some(_inner),
			ValidateIdentityProfileErrorKind::RateLimitError(_inner) => Some(_inner),
			ValidateIdentityProfileErrorKind::ForbiddenError(_inner) => Some(_inner),
			ValidateIdentityProfileErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ValidateIdentityProfileErrorKind::NotFoundError(_inner) => Some(_inner),
			ValidateIdentityProfileErrorKind::BadRequestError(_inner) => Some(_inner),
			ValidateIdentityProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `WatchEvents` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct WatchEventsError {
	/// Kind of error that occurred.
	pub kind: WatchEventsErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `WatchEvents` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum WatchEventsErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for WatchEventsError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			WatchEventsErrorKind::InternalError(_inner) => _inner.fmt(f),
			WatchEventsErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			WatchEventsErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			WatchEventsErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			WatchEventsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			WatchEventsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			WatchEventsErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for WatchEventsError {
	fn code(&self) -> Option<&str> {
		WatchEventsError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			WatchEventsErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			WatchEventsErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl WatchEventsError {
	/// Creates a new `WatchEventsError`.
	pub fn new(kind: WatchEventsErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `WatchEventsError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: WatchEventsErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `WatchEventsError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: WatchEventsErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `WatchEventsErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, WatchEventsErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `WatchEventsErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, WatchEventsErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `WatchEventsErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, WatchEventsErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `WatchEventsErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, WatchEventsErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `WatchEventsErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, WatchEventsErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `WatchEventsErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, WatchEventsErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for WatchEventsError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			WatchEventsErrorKind::InternalError(_inner) => Some(_inner),
			WatchEventsErrorKind::RateLimitError(_inner) => Some(_inner),
			WatchEventsErrorKind::ForbiddenError(_inner) => Some(_inner),
			WatchEventsErrorKind::UnauthorizedError(_inner) => Some(_inner),
			WatchEventsErrorKind::NotFoundError(_inner) => Some(_inner),
			WatchEventsErrorKind::BadRequestError(_inner) => Some(_inner),
			WatchEventsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// An error thrown when the requestee has sent an invalid or malformed request.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BadRequestError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub documentation: std::option::Option<std::string::String>,
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub metadata: std::option::Option<aws_smithy_types::Document>,
}
impl BadRequestError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn documentation(&self) -> std::option::Option<&str> {
		self.documentation.as_deref()
	}
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub fn metadata(&self) -> std::option::Option<&aws_smithy_types::Document> {
		self.metadata.as_ref()
	}
}
impl std::fmt::Debug for BadRequestError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("BadRequestError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.field("documentation", &self.documentation);
		formatter.field("metadata", &self.metadata);
		formatter.finish()
	}
}
impl BadRequestError {
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for BadRequestError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "BadRequestError")?;
		if let Some(inner_1) = &self.message {
			write!(f, ": {}", inner_1)?;
		}
		Ok(())
	}
}
impl std::error::Error for BadRequestError {}
/// See [`BadRequestError`](crate::error::BadRequestError)
pub mod bad_request_error {
	/// A builder for [`BadRequestError`](crate::error::BadRequestError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
		pub(crate) documentation: std::option::Option<std::string::String>,
		pub(crate) metadata: std::option::Option<aws_smithy_types::Document>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn documentation(mut self, input: impl Into<std::string::String>) -> Self {
			self.documentation = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_documentation(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.documentation = input;
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn metadata(mut self, input: aws_smithy_types::Document) -> Self {
			self.metadata = Some(input);
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn set_metadata(
			mut self,
			input: std::option::Option<aws_smithy_types::Document>,
		) -> Self {
			self.metadata = input;
			self
		}
		/// Consumes the builder and constructs a [`BadRequestError`](crate::error::BadRequestError)
		pub fn build(self) -> crate::error::BadRequestError {
			crate::error::BadRequestError {
				code: self.code,
				message: self.message,
				documentation: self.documentation,
				metadata: self.metadata,
			}
		}
	}
}
impl BadRequestError {
	/// Creates a new builder-style object to manufacture [`BadRequestError`](crate::error::BadRequestError)
	pub fn builder() -> crate::error::bad_request_error::Builder {
		crate::error::bad_request_error::Builder::default()
	}
}

/// An error thrown when the requestee requests a non existant resource.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub documentation: std::option::Option<std::string::String>,
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub metadata: std::option::Option<aws_smithy_types::Document>,
}
impl NotFoundError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn documentation(&self) -> std::option::Option<&str> {
		self.documentation.as_deref()
	}
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub fn metadata(&self) -> std::option::Option<&aws_smithy_types::Document> {
		self.metadata.as_ref()
	}
}
impl std::fmt::Debug for NotFoundError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("NotFoundError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.field("documentation", &self.documentation);
		formatter.field("metadata", &self.metadata);
		formatter.finish()
	}
}
impl NotFoundError {
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for NotFoundError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "NotFoundError")?;
		if let Some(inner_2) = &self.message {
			write!(f, ": {}", inner_2)?;
		}
		Ok(())
	}
}
impl std::error::Error for NotFoundError {}
/// See [`NotFoundError`](crate::error::NotFoundError)
pub mod not_found_error {
	/// A builder for [`NotFoundError`](crate::error::NotFoundError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
		pub(crate) documentation: std::option::Option<std::string::String>,
		pub(crate) metadata: std::option::Option<aws_smithy_types::Document>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn documentation(mut self, input: impl Into<std::string::String>) -> Self {
			self.documentation = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_documentation(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.documentation = input;
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn metadata(mut self, input: aws_smithy_types::Document) -> Self {
			self.metadata = Some(input);
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn set_metadata(
			mut self,
			input: std::option::Option<aws_smithy_types::Document>,
		) -> Self {
			self.metadata = input;
			self
		}
		/// Consumes the builder and constructs a [`NotFoundError`](crate::error::NotFoundError)
		pub fn build(self) -> crate::error::NotFoundError {
			crate::error::NotFoundError {
				code: self.code,
				message: self.message,
				documentation: self.documentation,
				metadata: self.metadata,
			}
		}
	}
}
impl NotFoundError {
	/// Creates a new builder-style object to manufacture [`NotFoundError`](crate::error::NotFoundError)
	pub fn builder() -> crate::error::not_found_error::Builder {
		crate::error::not_found_error::Builder::default()
	}
}

/// An error thrown when the requestee is not authenticated.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnauthorizedError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub documentation: std::option::Option<std::string::String>,
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub metadata: std::option::Option<aws_smithy_types::Document>,
}
impl UnauthorizedError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn documentation(&self) -> std::option::Option<&str> {
		self.documentation.as_deref()
	}
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub fn metadata(&self) -> std::option::Option<&aws_smithy_types::Document> {
		self.metadata.as_ref()
	}
}
impl std::fmt::Debug for UnauthorizedError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("UnauthorizedError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.field("documentation", &self.documentation);
		formatter.field("metadata", &self.metadata);
		formatter.finish()
	}
}
impl UnauthorizedError {
	/// Returns `Some(ErrorKind)` if the error is retryable. Otherwise, returns `None`.
	pub fn retryable_error_kind(&self) -> aws_smithy_types::retry::ErrorKind {
		aws_smithy_types::retry::ErrorKind::ClientError
	}
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for UnauthorizedError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "UnauthorizedError")?;
		if let Some(inner_3) = &self.message {
			write!(f, ": {}", inner_3)?;
		}
		Ok(())
	}
}
impl std::error::Error for UnauthorizedError {}
/// See [`UnauthorizedError`](crate::error::UnauthorizedError)
pub mod unauthorized_error {
	/// A builder for [`UnauthorizedError`](crate::error::UnauthorizedError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
		pub(crate) documentation: std::option::Option<std::string::String>,
		pub(crate) metadata: std::option::Option<aws_smithy_types::Document>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn documentation(mut self, input: impl Into<std::string::String>) -> Self {
			self.documentation = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_documentation(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.documentation = input;
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn metadata(mut self, input: aws_smithy_types::Document) -> Self {
			self.metadata = Some(input);
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn set_metadata(
			mut self,
			input: std::option::Option<aws_smithy_types::Document>,
		) -> Self {
			self.metadata = input;
			self
		}
		/// Consumes the builder and constructs a [`UnauthorizedError`](crate::error::UnauthorizedError)
		pub fn build(self) -> crate::error::UnauthorizedError {
			crate::error::UnauthorizedError {
				code: self.code,
				message: self.message,
				documentation: self.documentation,
				metadata: self.metadata,
			}
		}
	}
}
impl UnauthorizedError {
	/// Creates a new builder-style object to manufacture [`UnauthorizedError`](crate::error::UnauthorizedError)
	pub fn builder() -> crate::error::unauthorized_error::Builder {
		crate::error::unauthorized_error::Builder::default()
	}
}

/// An error thrown when the requestee requests a resource they do not have access to.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ForbiddenError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub documentation: std::option::Option<std::string::String>,
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub metadata: std::option::Option<aws_smithy_types::Document>,
}
impl ForbiddenError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn documentation(&self) -> std::option::Option<&str> {
		self.documentation.as_deref()
	}
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub fn metadata(&self) -> std::option::Option<&aws_smithy_types::Document> {
		self.metadata.as_ref()
	}
}
impl std::fmt::Debug for ForbiddenError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ForbiddenError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.field("documentation", &self.documentation);
		formatter.field("metadata", &self.metadata);
		formatter.finish()
	}
}
impl ForbiddenError {
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for ForbiddenError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "ForbiddenError")?;
		if let Some(inner_4) = &self.message {
			write!(f, ": {}", inner_4)?;
		}
		Ok(())
	}
}
impl std::error::Error for ForbiddenError {}
/// See [`ForbiddenError`](crate::error::ForbiddenError)
pub mod forbidden_error {
	/// A builder for [`ForbiddenError`](crate::error::ForbiddenError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
		pub(crate) documentation: std::option::Option<std::string::String>,
		pub(crate) metadata: std::option::Option<aws_smithy_types::Document>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn documentation(mut self, input: impl Into<std::string::String>) -> Self {
			self.documentation = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_documentation(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.documentation = input;
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn metadata(mut self, input: aws_smithy_types::Document) -> Self {
			self.metadata = Some(input);
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn set_metadata(
			mut self,
			input: std::option::Option<aws_smithy_types::Document>,
		) -> Self {
			self.metadata = input;
			self
		}
		/// Consumes the builder and constructs a [`ForbiddenError`](crate::error::ForbiddenError)
		pub fn build(self) -> crate::error::ForbiddenError {
			crate::error::ForbiddenError {
				code: self.code,
				message: self.message,
				documentation: self.documentation,
				metadata: self.metadata,
			}
		}
	}
}
impl ForbiddenError {
	/// Creates a new builder-style object to manufacture [`ForbiddenError`](crate::error::ForbiddenError)
	pub fn builder() -> crate::error::forbidden_error::Builder {
		crate::error::forbidden_error::Builder::default()
	}
}

/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RateLimitError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub documentation: std::option::Option<std::string::String>,
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub metadata: std::option::Option<aws_smithy_types::Document>,
}
impl RateLimitError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn documentation(&self) -> std::option::Option<&str> {
		self.documentation.as_deref()
	}
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub fn metadata(&self) -> std::option::Option<&aws_smithy_types::Document> {
		self.metadata.as_ref()
	}
}
impl std::fmt::Debug for RateLimitError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("RateLimitError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.field("documentation", &self.documentation);
		formatter.field("metadata", &self.metadata);
		formatter.finish()
	}
}
impl RateLimitError {
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for RateLimitError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "RateLimitError")?;
		if let Some(inner_5) = &self.message {
			write!(f, ": {}", inner_5)?;
		}
		Ok(())
	}
}
impl std::error::Error for RateLimitError {}
/// See [`RateLimitError`](crate::error::RateLimitError)
pub mod rate_limit_error {
	/// A builder for [`RateLimitError`](crate::error::RateLimitError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
		pub(crate) documentation: std::option::Option<std::string::String>,
		pub(crate) metadata: std::option::Option<aws_smithy_types::Document>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn documentation(mut self, input: impl Into<std::string::String>) -> Self {
			self.documentation = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_documentation(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.documentation = input;
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn metadata(mut self, input: aws_smithy_types::Document) -> Self {
			self.metadata = Some(input);
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn set_metadata(
			mut self,
			input: std::option::Option<aws_smithy_types::Document>,
		) -> Self {
			self.metadata = input;
			self
		}
		/// Consumes the builder and constructs a [`RateLimitError`](crate::error::RateLimitError)
		pub fn build(self) -> crate::error::RateLimitError {
			crate::error::RateLimitError {
				code: self.code,
				message: self.message,
				documentation: self.documentation,
				metadata: self.metadata,
			}
		}
	}
}
impl RateLimitError {
	/// Creates a new builder-style object to manufacture [`RateLimitError`](crate::error::RateLimitError)
	pub fn builder() -> crate::error::rate_limit_error::Builder {
		crate::error::rate_limit_error::Builder::default()
	}
}

/// An error caused by internal server problems.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub documentation: std::option::Option<std::string::String>,
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub metadata: std::option::Option<aws_smithy_types::Document>,
}
impl InternalError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn documentation(&self) -> std::option::Option<&str> {
		self.documentation.as_deref()
	}
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub fn metadata(&self) -> std::option::Option<&aws_smithy_types::Document> {
		self.metadata.as_ref()
	}
}
impl std::fmt::Debug for InternalError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("InternalError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.field("documentation", &self.documentation);
		formatter.field("metadata", &self.metadata);
		formatter.finish()
	}
}
impl InternalError {
	/// Returns `Some(ErrorKind)` if the error is retryable. Otherwise, returns `None`.
	pub fn retryable_error_kind(&self) -> aws_smithy_types::retry::ErrorKind {
		aws_smithy_types::retry::ErrorKind::ServerError
	}
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for InternalError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "InternalError")?;
		if let Some(inner_6) = &self.message {
			write!(f, ": {}", inner_6)?;
		}
		Ok(())
	}
}
impl std::error::Error for InternalError {}
/// See [`InternalError`](crate::error::InternalError)
pub mod internal_error {
	/// A builder for [`InternalError`](crate::error::InternalError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
		pub(crate) documentation: std::option::Option<std::string::String>,
		pub(crate) metadata: std::option::Option<aws_smithy_types::Document>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn documentation(mut self, input: impl Into<std::string::String>) -> Self {
			self.documentation = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_documentation(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.documentation = input;
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn metadata(mut self, input: aws_smithy_types::Document) -> Self {
			self.metadata = Some(input);
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn set_metadata(
			mut self,
			input: std::option::Option<aws_smithy_types::Document>,
		) -> Self {
			self.metadata = input;
			self
		}
		/// Consumes the builder and constructs a [`InternalError`](crate::error::InternalError)
		pub fn build(self) -> crate::error::InternalError {
			crate::error::InternalError {
				code: self.code,
				message: self.message,
				documentation: self.documentation,
				metadata: self.metadata,
			}
		}
	}
}
impl InternalError {
	/// Creates a new builder-style object to manufacture [`InternalError`](crate::error::InternalError)
	pub fn builder() -> crate::error::internal_error::Builder {
		crate::error::internal_error::Builder::default()
	}
}
